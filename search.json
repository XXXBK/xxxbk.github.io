[{"title":"Python 魔法：一键让 Excel 正确选项「脸红」","url":"/2025/07/15/Python-%E9%AD%94%E6%B3%95%EF%BC%9A%E4%B8%80%E9%94%AE%E8%AE%A9-Excel-%E6%AD%A3%E7%A1%AE%E9%80%89%E9%A1%B9%E3%80%8C%E8%84%B8%E7%BA%A2%E3%80%8D/","content":"在数据处理工作中，我们经常需要处理 Excel 文件中的试题数据，特别是需要对正确答案进行特殊标记。本文将分享我从最初实现到最终优化的完整改进过程。\n初始需求\n我们需要处理一个包含试题的 Excel 文件，具体要求：\n\n文件包含 “试题选项” 和 “试题答案” 两列\n\n试题选项用 “$;$” 分隔多个选项\n\n需要根据 “试题答案” 将正确答案标记为红色\n\n处理后的结果直接修改原文件\n\n\n第一版实现\n核心思路：&#xA;\n使用 pandas 读取 Excel 文件\n\n用 openpyxl 修改原文件样式\n\n在正确答案前后添加 “**” 标记\n\n提示用户手动替换 “**” 为红色格式\n\n\n# 主要处理逻辑marked_options = []for i, option in enumerate(options):    if i in correct_indices:        marked_options.append(f&quot;**&#123;option&#125;**&quot;)  # 用**标记正确答案    else:        marked_options.append(option)cell.value = &#x27;$;$&#x27;.join(marked_options)\n\n问题：\n不能自动设置红色，需要用户手动替换，** 的标记方式不够直观\n第二版改进\n改进点：&#xA;\n改用 xlsxwriter 引擎\n\n直接处理 ** 标记的内容并设置为红色\n\n保留 ** 标记\n\n\n# 使用正则匹配**内容并设置格式for match in re.finditer(r&#x27;\\*\\*(.*?)\\*\\*&#x27;, cell_value):    parts.append(&#123;        &#x27;text&#x27;: f&quot;**&#123;match.group(1)&#125;**&quot;,        &#x27;format&#x27;: red_format    &#125;)\n问题：\n使用 ** 将正确答案括起来的话，xlsxwriter 无法非常准确地解析出来，因为答案可能是 A$;$B$;$C$;$D 这样子的，相同的符号会干扰它的判断，从而导致效果不好\n最终版改进\n改进思路：&#xA;\n改回使用 openpyxl\n\n正确答案用 [] 标记\n\n非正确答案不做标记\n\n\nmarked_options = []for i, option in enumerate(options):    if i in correct_indices:        marked_options.append(f&quot;[&#123;option&#125;]&quot;)  # 正确答案标记    else:        marked_options.append(option)\n\n然后再进行标红处理：\n\n使用富文本 (CellRichText) 直接设置红色\n\n自动移除 [] 标记\n\n添加异常处理，失败时回退到普通文本\n\n更友好的提示信息\n\n\nrich_text = CellRichText()for i, option in enumerate(options):    if i &gt; 0:        rich_text.append(&#x27;$;$&#x27;)    clean_option = option.replace(&#x27;[&#x27;, &#x27;&#x27;).replace(&#x27;]&#x27;, &#x27;&#x27;)    if i in correct_indices:        rich_text.append(TextBlock(inline_red_font, clean_option))    else:        rich_text.append(clean_option)cell.value = rich_text\n\n关键改进点：&#xA;\n富文本支持：使用 CellRichText 和 TextBlock 实现对单个字符的样式设置\n\n自动清理：移除选项中的 [] 标记\n\n\n拓展功能：标记检查与统一分隔符\n在最终版的基础上，我进一步完善了代码，增加了两项重要的功能：统一处理非标准分隔符和全面的标记检查报告。这使得整个流程更加健壮和智能化。\n1. 统一分隔符&#xA;很多时候，Excel 中的选项分隔符可能不统一，除了标准的$;$，还可能出现$;、$$等，甚至单空格加 $ 等多种形式。为了确保选项能够被正确解析，我加入了强大的正则表达式来识别并统一这些非标准分隔符为 $;$。\n实现方式：使用 re.compile 定义了一个详细的正则表达式 separator_pattern，涵盖了多种常见的非标准分隔符。\n效果：在处理每个选项字符串时，首先使用 separator_pattern.sub (‘$;$’, options_str) 将所有识别到的非标准分隔符统一替换为 $;$ 。这大大提高了数据处理的鲁棒性，减少了因格式不一致导致的问题。\n# 正则表达式定义separator_pattern = re.compile(r&#x27;&#x27;&#x27;    \\$;\\$|       # 标准 $;$    \\$[:：]\\$|   # $:$ 或 $：$    ;\\$|         # ;$    \\$；|        # $；    [；:：]\\$|   # ；$ 或 ：$    \\$[;；:：]|  # $; 或 $；或 $: 或 $：    \\$\\$|        # $$    \\s&#123;2,&#125;|      # 两个或更多空格    \\$\\s|\\s\\$|   # $ 后或前有单个空格    ;           # 单独的分号&#x27;&#x27;&#x27;, re.VERBOSE)# 替换处理modified_str = separator_pattern.sub(&#x27;$;$&#x27;, options_str)\n\n2. 标记检查报告&#xA;仅仅对正确答案进行标记是不够的，我们还需要验证标记是否正确、是否有遗漏。此功能可以生成详细的报告，指出 “正确答案未被标记” 和 “错误答案被标记” 的情况。\n核心逻辑优化：&#xA;\n未标记检查：传统的检查方法是看 “标记索引” 中是否包含正确答案的索引。但如果正确答案完全没有被标记（即选项中根本没有 []），这种方法就无法识别。新的逻辑直接检查正确答案的选项内容是否被 [] 包裹 。只要正确答案未被 [] 包裹，无论是否有其他标记动作，都会被识别为 “未标记” 。\n\n错误标记检查：检查所有被 [] 包裹的选项，如果其索引不在正确答案的索引列表中，则视为错误标记 。\n\n\n输出报告：&#xA;生成清晰的报告，包含：\n\n检查的总行数 。\n\n“未标记正确答案的行” 数量及具体详情（Excel 行号、应标记的字母、未被包裹的实际内容） 。\n\n“错误标记的行” 数量及具体详情（Excel 行号、错误标记的内容、正确的答案） 。\n\n\n#未标记检查代码：has_unmarked = Falsefor i in correct_indices:    opt = options[i]    if not (opt.strip().startswith(&#x27;[&#x27;) and opt.strip().endswith(&#x27;]&#x27;)):        has_unmarked = True        breakif has_unmarked:    unmarked_rows.append(&#123;        &#x27;row&#x27;: row_num,        &#x27;expected&#x27;: [chr(65 + i) for i in correct_indices],        &#x27;actual&#x27;: [options[i].strip() for i in correct_indices]    &#125;)#错误标记检查代码：marked_indices = []for i, opt in enumerate(options):    if opt.strip().startswith(&#x27;[&#x27;) and opt.strip().endswith(&#x27;]&#x27;):        marked_indices.append(i)for i in marked_indices:    if i not in correct_indices:        wrong_marking.append(&#123;            &#x27;row&#x27;: row_num,            &#x27;wrong_marked&#x27;: options[i].strip(),            &#x27;correct&#x27;: [chr(65 + i) for i in correct_indices]        &#125;)        break\n\n验证示例：&#xA;如果一个 Excel 行的正确答案是 D，但选项 D 没有被 [] 包裹，运行代码后会输出：\n=== 标记检查报告 ===共检查 1000 行数据1. 未标记正确答案的行: 1 行    行X: 应标记[&#x27;D&#x27;]（内容：D、xxxxxxxx）未被[]包裹2. 错误标记的行: 0 行\n\n这使得我们能够精准识别 “应该标记但完全没标记” 的情况 。\nPS:代码仅供参考，内容不一定正确，要根据实际情况处理喵\n","categories":["Excel","Python","数据处理"],"tags":["Excel","Pandas","Python","Openpyxl","Xlsxwriter","正则表达式"]},{"title":"Dify镜像源替换与服务启动","url":"/2025/07/15/Dify-%E9%83%A8%E7%BD%B2%E6%B5%81%E7%A8%8B%EF%BC%9A%E9%95%9C%E5%83%8F%E6%BA%90%E6%9B%BF%E6%8D%A2%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%90%AF%E5%8A%A8/","content":"一、Dify 镜像源替换操作\n批量替换镜像前缀&#xA;在 docker-compose.yaml 所在目录执行全局替换，添加 docker.1ms.run&#x2F; 前缀：\nsed -i &#x27;s/image: /image: docker.1ms.run\\\\//g&#x27; docker-compose.yaml\n\n特殊镜像路径修正&#xA;问题路径&#xA;image: docker.1ms.run/docker.elastic.co/elasticsearch/elasticsearch:8.14.3\n\n修正命令&#xA;sed -i &#x27;s|docker.1ms.run/docker.elastic.co/|docker.1ms.run/elastic/|g&#x27; docker-compose.yaml\n\n正确路径&#xA;image: docker.1ms.run/elastic/elasticsearch:8.14.3\n\n基础镜像补充替换&#xA;sed -i &#x27;s|image: postgres:|image: docker.1ms.run/postgres:|g&#x27; docker-compose.yamlsed -i &#x27;s|image: redis:|image: docker.1ms.run/redis:|g&#x27; docker-compose.yamlsed -i &#x27;s|image: nginx:|image: docker.1ms.run/nginx:|g&#x27; docker-compose.yaml\n\n二、部署前准备工作\n赋予挂载目录权限：\nchmod -R 777 ./volumes ./elasticsearch\n\n三、启动与验证 Dify 服务\n后台启动服务&#xA;docker-compose up -d\n\n验证服务状态&#xA;docker-compose ps  # 检查容器运行状态docker-compose logs -f  # 查看实时日志\n\n访问 Dify 界面&#xA;浏览器输入 http:&#x2F;&#x2F; 服务器 IP:3000，默认账号 admin@example.com，密码 password。\n四、部署过程常见问题\n镜像路径嵌套错误&#xA;问题&#xA;镜像路径包含 docker.1ms.run&#x2F;docker.elastic.co&#x2F; 嵌套结构。\n解决&#xA;使用 sed 精准替换：\nsed -i &#x27;s|docker.1ms.run/docker.elastic.co/|docker.1ms.run/elastic/|g&#x27; docker-compose.yaml\n\n权限不足导致启动失败&#xA;问题&#xA;挂载目录无读写权限。\n解决&#xA;递归设置目录权限：\nchmod -R 777 ./volumes\n服务启动异常&#xA;解决&#xA;通过日志排查问题：&#x20;\ndocker-compose logs -f  # 查看所有服务日志docker-compose logs dify-api  # 查看指定服务日志\n\n五、核心操作总结\n镜像替换流程&#xA;全局前缀替换 → 特殊镜像路径修正 → 基础镜像补充替换\n启动验证流程&#xA;docker-compose up -d → docker-compose ps → 访问 Web 界面\n关键命令&#xA;sed -i &#x27;s/image: /image: docker.1ms.run\\\\//g&#x27; docker-compose.yamlchmod -R 777 ./volumesdocker-compose up -d\n\nPS:代码仅供参考，内容不一定正确，要根据实际情况处理喵\n","categories":["Dify"],"tags":["Dify","镜像源"]},{"title":"Portainer容器管理实战：从镜像加速到安全部署","url":"/2025/07/15/Portainer%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86%E5%AE%9E%E6%88%98%EF%BC%9A%E4%BB%8E%E9%95%9C%E5%83%8F%E5%8A%A0%E9%80%9F%E5%88%B0%E5%AE%89%E5%85%A8%E9%83%A8%E7%BD%B2/","content":"一、背景：为什么选择从第三方镜像源拉取 Portainer？\n近期在学习容器管理工具 Portainer 时，参考了一篇技术教程（知乎链接：https://zhuanlan.zhihu.com&#x2F;p&#x2F;27740131259），教程中推荐使用官方镜像源部署。但由于网络环境限制，尝试从第三方镜像源docker.1ms.run拉取 Portainer 镜像，意外发现该镜像源提供了更稳定的下载速度，因此记录下完整操作流程，供遇到类似问题的开发者参考。\n二、操作步骤：从镜像拉取到容器启动的全流程\n1. 拉取 Portainer 镜像&#xA;通常情况下，Portainer 官方镜像的拉取命令为：\ndocker pull portainer/portainer-ce:latest\n\n但本次尝试使用第三方镜像源：\ndocker pull docker.1ms.run/portainer/portainer-ce:latest\n\n\n注意事项：\n\n第三方镜像源可能存在安全风险，建议优先使用官方镜像（portainer/portainer-ce）。\n若拉取失败，可检查镜像源是否可用（如执行ping docker.1ms.run），或切换至国内加速源（如 Docker 中国镜像站）。\n\n2. 验证镜像是否成功拉取&#xA;通过docker images命令查看本地镜像列表：\ndocker images\n3. 启动 Portainer 容器&#xA;使用以下命令启动容器，并配置挂载与端口映射：\ndocker run -d \\  --name portainer \\  -p 9000:9000 \\  -v /var/run/docker.sock:/var/run/docker.sock \\  -v portainer_data:/data \\  --restart=always \\  docker.1ms.run/portainer/portainer-ce:latest\n参数解析：\n\n-d：后台运行容器；\n\n-p 9000:9000：映射宿主机 9000 端口到容器 9000 端口，用于访问 Web 界面；\n\n-v /var/run/docker.sock:/var/run/docker.sock：挂载 Docker 套接字，允许 Portainer 管理宿主机 Docker 环境；\n\n-v portainer_data:/data：创建数据卷持久化存储 Portainer 配置；\n\n--restart=always：确保容器随系统重启自动运行。\n\n\n4. 访问 Portainer Web 界面&#xA;容器启动后，在浏览器中输入http://宿主机IP:9000，首次访问需设置管理员密码，随后进入 Portainer 管理界面。\n三、遇到的问题与解决方案\n1. 镜像拉取失败：manifest unknown&#xA;错误信息：\nError response from daemon: manifest for docker.1ms.run/portainer-ce:latest not found: manifest unknown\n\n原因：\n镜像源中无该镜像，或镜像名称拼写错误（如portainer-ce写成portainer）。\n解决方法：\n确认镜像名称正确性，或更换为官方镜像源拉取：\ndocker pull portainer/portainer-ce:latest\n\n2. Docker Hub 连接超时&#xA;错误信息：\nError response from daemon: Get &quot;https://registry-1.docker.io/v2/&quot;: context deadline exceeded\n\n解决方法：\n配置国内镜像加速源，编辑/etc/docker/daemon.json添加：\n&#123;  &quot;registry-mirrors&quot;: [&quot;https://registry.docker-cn.com&quot;, &quot;https://docker.mirrors.ustc.edu.cn&quot;]&#125;\n\n重启 Docker 服务：sudo systemctl restart docker。\n四、使用第三方镜像源的风险与建议\n\n安全风险：第三方镜像源可能被篡改，建议优先使用官方镜像（portainer/portainer-ce）。\n\n版本兼容性：第三方镜像可能非最新版本，建议定期通过docker pull更新镜像。\n\n网络稳定性：若第三方源频繁失效，优先使用官方源或国内大厂加速源（如阿里云、腾讯云镜像站）。\n\n\n五、总结：Portainer 的价值与容器管理实践\n通过 Docker 部署 Portainer 后，可直观管理容器、镜像、网络及数据卷，尤其适合新手快速上手容器化部署。本次从第三方镜像源拉取的经历表明：技术实践中需在效率与安全性间权衡，建议在测试环境尝试非官方源，生产环境务必使用官方可信镜像。\n后续可进一步探索 Portainer 的 Kubernetes 管理、RBAC 权限控制等高级功能，提升容器化应用的部署与运维效率。\nPS:代码仅供参考，内容不一定正确，要根据实际情况处理喵\n","categories":["Docker实践"],"tags":["Docker","Portainer","镜像加速","容器管理"]},{"title":"Python异闻录（一）","url":"/2025/08/05/Python%E5%BC%82%E9%97%BB%E5%BD%95%EF%BC%88%E4%B8%80%EF%BC%89/","content":"1. Python 基础语法1.1 变量与数据类型1.1.1 变量的命名规则与赋值方式\n命名规则：需遵循 Python 标识符命名规范，由字母、数字和下划线组成，且不能以数字开头\n\n赋值方式：使用等号=进行赋值，如variable_name = value\n\n\n1.1.2 基本数据类型\n整数 (int)：表示没有小数部分的数字\n\n浮点数 (float)：带有小数部分的数字\n\n字符串 (str)：由字符组成的序列，用单引号&#39;或双引号&quot;包裹\n\n布尔值 (bool)：只有True和False两个值，分别表示真和假\n\n\n1.1.3 字符串的格式化方法\nf-string（Python 3.6+）：在字符串前加f，通过&#123;&#125;嵌入变量或表达式\n\n.format()方法：使用&#123;&#125;作为占位符，通过format()方法传入参数\n\n%操作符：使用%作为占位符，按照指定格式进行格式化\n\n\nname = &quot;Alice&quot;print(f&quot;Hello, &#123;name&#125;!&quot;)  # f-string（Python 3.6+）print(&quot;Hello, &#123;&#125;!&quot;.format(name))  # format方法print(&quot;Hello, %s!&quot; % name)  # %操作符\n\n1.1.4 布尔值的隐式转换规则\n以下值在布尔判断中会被视为False：\n\n数字0（包括整数 0、浮点数 0.0 等）\n\n空字符串&quot;&quot;\n\n空列表[]、空元组()、空字典&#123;&#125;、空集合set()\n\nNone\n\n\n\n其他值通常被视为True\n\n\n1.1.5 数据类型转换及实例应用\n常用转换函数：int()、float()、str()、bool()\n\n实例应用：在不同数据处理场景中进行类型转换以满足运算或操作需求\n\n\n# 数据类型转换示例num_str = &quot;123&quot;num_int = int(num_str)print(num_int + 1)  # 输出124\n\n1.2 运算符与表达式1.2.1 算术运算符及优先级\n常用算术运算符：+（加）、-（减）、*（乘）、/（除）、//（整除）、%（取余）、**（幂运算）\n\n优先级：先进行幂运算，再进行乘除运算，最后进行加减运算，可使用括号改变运算顺序\n\n\n1.2.2 比较运算符与逻辑运算符\n比较运算符：&gt;（大于）、&lt;（小于）、==（等于）、!=（不等于）、&gt;=（大于等于）、&lt;=（小于等于），返回布尔值\n\n逻辑运算符：and（与）、or（或）、not（非），用于组合多个条件\n\n\n1.2.3 成员运算符和身份运算符\n成员运算符：\n\nin：判断某个元素是否在序列或集合中，存在返回True，否则返回False\n\nnot in：判断某个元素是否不在序列或集合中，不在返回True，否则返回False\n\n\n\n身份运算符：\n\nis：判断两个对象是否为同一个对象，是返回True，否则返回False\n\nis not：判断两个对象是否不为同一个对象，不是返回True，否则返回False\n\n\n\n\n# 成员运算符示例list1 = [1, 2, 3]print(2 in list1)  # 输出Trueprint(4 not in list1)  # 输出True# 身份运算符示例a = [1, 2, 3]b = ac = [1, 2, 3]print(a is b)  # 输出Trueprint(a is not c)  # 输出True\n\n1.2.4 海象运算符（:&#x3D;，Python 3.8+）\n作用：在表达式中同时完成赋值和判断操作\n\n用法：将赋值表达式写在:=左侧，右侧为要赋的值\n\n\nif (n := len(&quot;hello&quot;)) &gt; 3:   print(f&quot;Length is &#123;n&#125;&quot;)  # 输出Length is 5\n\n1.2.5 运算符的链式比较\nPython 特有的语法糖，可同时进行多个比较操作\n\n等价于使用and连接多个比较表达式\n\n\nif 1 &lt; x &lt; 5:  # 等价于 x &gt; 1 and x &lt; 5   print(&quot;Valid range&quot;)\n\n1.2.6 赋值运算符及复合赋值的使用\n基本赋值运算符：=，将右边的值赋给左边的变量\n\n复合赋值运算符：+=、-=、*=、/=等，如a += b等价于a = a + b\n\n\n1.3 流程控制1.3.1 条件语句\nif 单分支：当条件满足时执行相应代码块\n\nif condition:   # 条件满足时执行的代码\n\n\n\nif-else 双分支：条件满足执行一个代码块，不满足执行另一个代码块\n\nif condition:   # 条件满足时执行的代码else:   # 条件不满足时执行的代码\n\n\nif-elif-else 多分支：多个条件依次判断，满足其中一个条件就执行相应代码块\n\nif condition1:   # 满足条件1时执行的代码elif condition2:   # 满足条件2时执行的代码else:   # 所有条件都不满足时执行的代码\n\n1.3.2 三元表达式\n概念：是一种简洁的条件表达式，可在一行代码中实现简单的条件判断和赋值操作\n\n语法：value_if_true if condition else value_if_false\n\n应用场景：适用于简单的条件判断，使代码更简洁紧凑\n\n\n# 三元表达式示例age = 18status = &quot;成年人&quot; if age &gt;= 18 else &quot;未成年人&quot;print(status)  # 输出&quot;成年人&quot;\n\n1.3.3 循环语句\nfor 循环：用于遍历序列或使用range函数生成的数字序列\n\n# 遍历序列for item in sequence:   # 循环体代码# range函数应用for i in range(1, 5):   print(i)\n\n\nwhile 循环：当条件满足时，重复执行循环体\n\nwhile condition:   # 循环体代码\n1.3.4 循环控制\nbreak 语句：用于跳出当前循环\n\ncontinue 语句：用于跳过当前循环中的剩余语句，直接进入下一次循环\n\n\n1.3.5 嵌套循环的逻辑与实例\n逻辑：在一个循环内部再包含一个或多个循环\n\n实例：\n\n\nfor i in range(1, 4):   for j in range(1, 4):       print(i * j, end=&quot; &quot;)   print()\n\n1.4 变量作用域1.4.1 全局变量与局部变量\n全局变量：在函数外部定义的变量，作用域为整个程序\n\n局部变量：在函数内部定义的变量，作用域仅为该函数内部\n\nglobal关键字：在函数内部声明变量为全局变量，可修改全局变量的值\n\n\nx = 10  # 全局变量def func():   global x  # 声明x为全局变量   x = 20  # 修改全局变量的值func()print(x)  # 输出20\n\n1.5 字符串的原始字符串（Raw String）\n定义：在字符串前加r或R，字符串中的转义字符不被解析\n\n应用场景：处理路径或正则表达式时避免转义字符干扰\n\n\npath = r&quot;C:UsersNameDocuments&quot;  # 原始字符串，反斜杠不被转义print(path)  # 输出C:UsersNameDocuments\n\n1.6 内存机制\n引用计数：Python中主要的内存管理方式，每个对象都有一个引用计数器，当引用计数为 0 时，对象被销毁\n\n垃圾回收：\n\n当对象之间存在循环引用时，引用计数无法将其回收，此时会启动垃圾回收机制\n\n通过gc模块可以手动控制垃圾回收\n\n\n\n内存池：为了提高内存分配效率，Python会预先分配一定数量的小内存块，用于存储小型对象（如整数、短字符串等）\n\n不可变对象与内存：不可变对象（如整数、字符串、元组）在创建后不能修改，当对其进行操作时会创建新的对象\n\n\nimport sysimport gc# 引用计数示例a = [1, 2, 3]print(sys.getrefcount(a))  # 输出2，因为getrefcount函数也会增加一次引用b = aprint(sys.getrefcount(a))  # 输出3# 手动触发垃圾回收gc.collect()\n\n2. 数据结构基础2.1 序列类型2.1.1 列表（List）\n创建：使用方括号[]创建，如list_name = [element1, element2, ...]\n\n索引与切片：通过索引访问单个元素，通过切片获取子列表，索引从 0 开始\n\n增删改查操作：\n\n增加：append()、insert()、extend()等方法\n\n删除：remove()、pop()、del语句等\n\n修改：通过索引直接赋值修改元素\n\n查询：in关键字、index()方法等\n\n\n\n\n2.1.2 列表推导式与生成器表达式\n列表推导式：是一种简化循环和条件判断的写法，能快速生成列表\n\n生成器表达式：与列表推导式类似，但返回的是一个生成器对象，更节省内存\n\n\n# 列表推导式示例squares = [x**2 for x in range(10) if x % 2 == 0]# 生成器表达式示例gen = (x**2 for x in range(10) if x % 2 == 0)\n\n2.1.3 元组（Tuple）\n不可变特性：一旦创建，元素不能被修改\n\n适用场景：用于存储不希望被修改的数据，如坐标、配置信息等\n\n创建：使用圆括号()创建，如tuple_name = (element1, element2, ...)\n\n\n2.1.4 字符串（String）\n常用方法：\n\n拼接：使用+运算符\n\n分割：split()方法\n\n替换：replace()方法\n\n大小写转换：upper()、lower()方法等\n\n\n\n创建：使用单引号&#39;或双引号&quot;包裹，如str_name = &quot;string content&quot;\n\n\n2.2 映射类型2.2.1 字典（Dictionary）\n键值对结构：由键和对应的值组成，格式为&#123;key1: value1, key2: value2, ...&#125;\n\n创建与访问：\n\n创建：dict_name = &#123;key1: value1, key2: value2, ...&#125;或dict()函数\n\n访问：通过键访问对应的值，如dict_name[key]\n\n\n\n键的特性：键必须是不可变类型（如字符串、数字、元组），且不能重复\n\n字典的常用操作：\n\n添加：dict_name[new_key] = new_value\n\n删除：del语句、pop()方法等\n\n遍历键值对：for key, value in dict_name.items():\n\n\n\n\n2.2.2 字典的 setdefault 与 defaultdict\nsetdefault()方法：获取指定键的值，若键不存在则设置默认值并返回\n\ndefaultdict（来自collections模块）：创建字典时指定默认值类型，避免键不存在的错误\n\n\n# setdefault示例d = &#123;&#125;d.setdefault(&quot;key&quot;, []).append(1)  # 无需先检查键是否存在print(d)  # 输出&#123;&#x27;key&#x27;: [1]&#125;# defaultdict示例from collections import defaultdictdd = defaultdict(list)dd[&quot;key&quot;].append(1)print(dd)  # 输出defaultdict(list, &#123;&#x27;key&#x27;: [1]&#125;)\n\n2.3 集合类型2.3.1 集合（Set）\n去重特性：自动去除重复元素\n\n集合运算：\n\n交集：&amp;运算符或intersection()方法\n\n并集：|运算符或union()方法\n\n差集：-运算符或difference()方法等\n\n\n\n创建：使用花括号&#123;&#125;或set()函数，如set_name = &#123;element1, element2, ...&#125;\n\n\n2.3.2 集合的基本操作与应用场景\n基本操作：添加元素add()、删除元素remove()、清空集合clear()等\n\n应用场景：用于数据去重、集合运算等场景\n\n\n2.3.3 浅拷贝与深拷贝\ncopy()（浅拷贝）：只拷贝对象本身，对于对象中的嵌套对象，只拷贝其引用，原对象和拷贝对象的嵌套对象会相互影响\n\ndeepcopy()（深拷贝）：不仅拷贝对象本身，还会递归拷贝对象中的所有嵌套对象，原对象和拷贝对象的嵌套对象互不影响\n\n\nimport copy# 浅拷贝示例list1 = [1, [2, 3]]list2 = list1.copy()list1[1].append(4)print(list2)  # 输出[1, [2, 3, 4]]# 深拷贝示例list3 = [1, [2, 3]]list4 = copy.deepcopy(list3)list3[1].append(4)print(list4)  # 输出[1, [2, 3]]\n\n2.3.4 集合的不可变版本 frozenset\n特性：创建后不可修改，可作为字典的键或其他集合的元素\n\n创建：使用frozenset()函数\n\n\nfs = frozenset([1, 2, 3])d = &#123;fs: &quot;value&quot;&#125;  # 可作为字典的键print(d)  # 输出&#123;frozenset(&#123;1, 2, 3&#125;): &#x27;value&#x27;&#125;\n\n2.4 队列与栈的实现\n使用collections.deque高效实现，提供两端快速添加和删除元素的操作\n\n队列：先进先出（FIFO），使用append()入队，popleft()出队\n\n栈：后进先出（LIFO），使用append()入栈，pop()出栈\n\n\nfrom collections import deque# 队列实现queue = deque()queue.append(1)  # 入队queue.append(2)print(queue.popleft())  # 出队，输出1# 栈实现stack = deque()stack.append(1)  # 入栈stack.append(2)print(stack.pop())  # 出栈，输出2\n\n3. 函数编程3.1 函数基础3.1.1 函数的定义与调用\n函数的语法结构：使用def关键字定义，包含函数名、参数和返回值\n\ndef function_name(parameters):   # 函数体代码   return return_value\n\n\n函数调用的方式及参数传递：通过函数名加括号调用，如function_name(arguments)，参数按位置或关键字传递\n\n3.1.2 函数参数\n位置参数与关键字参数的使用区别：\n\n位置参数：按参数位置顺序传递\n\n关键字参数：通过参数名指定传递的值，可改变参数顺序\n\n\n\n默认参数的设置与注意事项：在定义函数时为参数指定默认值，默认参数必须放在位置参数后面\n\n不定长参数的应用：\n\n*args：接收任意数量的位置参数，返回一个元组\n\n**kwargs：接收任意数量的关键字参数，返回一个字典\n\n\n\n\n3.1.3 函数的返回值\nreturn 语句的作用：用于返回函数的计算结果，结束函数执行\n\n多返回值的处理方式：返回多个值时，以元组形式返回，可通过多个变量接收\n\n函数的嵌套调用：在一个函数内部调用另一个函数\n\n\n3.2 lambda 表达式\n概念：是一种匿名函数，即没有函数名的函数，语法简洁，适用于创建简单的函数\n\n语法：lambda parameters: expression，其中parameters是参数列表，expression是函数体，返回表达式的结果\n\n应用场景：作为参数传递给高阶函数（如map()、filter()、sorted()等），简化代码编写\n\n\n# lambda表达式示例add = lambda x, y: x + yprint(add(3, 5))  # 输出8# 作为sorted函数的key参数students = [(&quot;Alice&quot;, 20), (&quot;Bob&quot;, 18), (&quot;Charlie&quot;, 22)]sorted_students = sorted(students, key=lambda x: x[1])  # 按年龄排序\n\n3.3 类型注解\n概念：是一种为函数参数、返回值以及变量指定数据类型的方式，提高代码的可读性和可维护性，便于静态类型检查工具进行类型检查\n\n语法：\n\n函数参数注解：def function_name(param: type) -&gt; return_type:\n\n变量注解：variable_name: type = value\n\n\n\n注意事项：类型注解不会影响程序的运行，仅作为提示信息\n\n\n# 函数参数和返回值注解def add(a: int, b: int) -&gt; int:   return a + b# 变量注解name: str = &quot;Alice&quot;age: int = 18scores: list[float] = [90.5, 88.0, 95.5]\n\n3.4 高阶函数3.4.1 高阶函数的定义\n接受函数作为参数或返回函数的函数\n\n高阶函数在代码复用和逻辑抽象中的作用：提高代码的复用性，简化复杂逻辑的实现\n\n\n3.4.2 常用高阶函数\nmap()函数：对可迭代对象中的元素应用指定函数，返回一个迭代器\n\nfilter()函数：根据指定条件筛选可迭代对象中的元素，返回一个迭代器\n\nsorted()函数：对可迭代对象进行排序，可通过key参数自定义排序规则\n\n\n3.4.3 高阶函数的应用实例\n利用map()实现数据类型批量转换：\n\nstr_list = [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;]int_list = list(map(int, str_list))\n\n\n借助filter()筛选符合条件的数据：\n\nnumbers = [1, 2, 3, 4, 5, 6]even_numbers = list(filter(lambda x: x % 2 == 0, numbers))\n\n\n通过sorted()对复杂数据结构进行排序：\n\nstudents = [(&quot;Alice&quot;, 20), (&quot;Bob&quot;, 18), (&quot;Charlie&quot;, 22)]sorted_students = sorted(students, key=lambda x: x[1])\n\n3.5 闭包与装饰器3.5.1 闭包\n概念：函数嵌套时，内部函数引用了外部函数的变量，并且外部函数返回内部函数，这样的内部函数称为闭包\n\n作用：保留外部变量的状态，实现数据封装和复用\n\n\ndef outer():  x = 1  def inner():      print(x)  # 记住x的值  return innerclosure_func = outer()closure_func()  # 输出1\n\n3.5.2 装饰器\n概念：是一种修改函数行为的工具，本质上是一个高阶函数，接受函数作为参数，并返回一个新的函数\n\n作用：在不修改原函数代码的情况下，为函数添加额外功能，如日志记录、性能测试等\n\n\nimport timedef log_time(func):  def wrapper(*args, **kwargs):      start = time.time()      result = func(*args, **kwargs)      print(f&quot;Time used: &#123;time.time() - start&#125;&quot;)      return result  return wrapper@log_timedef add(a, b):  return a + badd(3, 5)  # 输出Time used: ...（具体时间）并返回8\n\n3.6 偏函数（functools.partial）\n概念：通过固定函数的部分参数，生成一个新的函数\n\n作用：简化函数调用，当函数的某些参数经常取固定值时，可使用偏函数减少重复传递参数的工作\n\n\nfrom functools import partial# 原函数pow(base, exp)，计算base的exp次方pow_2 = partial(pow, exp=2)  # 固定exp参数为2print(pow_2(5))  # 输出25，等价于pow(5, 2)pow_3 = partial(pow, exp=3)  # 固定exp参数为3print(pow_3(2))  # 输出8，等价于pow(2, 3)","categories":["Python教程","语法详解"],"tags":["Python基础","数据类型","函数编程"]},{"title":"Python异闻录（三）","url":"/2025/08/05/Python%E5%BC%82%E9%97%BB%E5%BD%95%EF%BC%88%E4%B8%89%EF%BC%89/","content":"7. 元编程7.1 动态创建类\n概念：在程序运行时动态地创建类，而不是在代码中静态定义。\n\n实现方式：使用 type() 函数，type() 函数既可以返回对象的类型，也可以用于动态创建类。\n\ntype() 动态创建类的语法：type(class_name, bases, namespace)，其中 class_name 是类名，bases 是父类元组，namespace 是类的属性和方法字典。\n\n\n#定义类的方法def say_hello(self):   print(f&quot;Hello, I&#x27;m &#123;self.name&#125;&quot;)def set_age(self, age):self.age = age# 动态创建类Person = type(&quot;Person&quot;, (object,), &#123;   &quot;name&quot;: &quot;Unknown&quot;,   &quot;say_hello&quot;: say_hello,   &quot;set_age&quot;: set_age&#125;)# 使用动态创建的类p = Person()p.say_hello()  # 输出Hello, I&#x27;m Unknownp.name = &quot;Alice&quot;p.say_hello()  # 输出Hello, I&#x27;m Alicep.set_age(18)print(p.age)  # 输出18\n\n8. 性能优化8.1 生成器\n概念：生成器是一种特殊的迭代器，通过 yield 关键字返回值，每次调用 next() 方法时，从上次 yield 的位置继续执行。\n\n特点：\n\n惰性计算：生成器不会一次性生成所有数据，而是在需要时生成，节省内存空间。\n\n可迭代性：生成器是可迭代对象，可以使用 for 循环遍历。\n\n\n\n应用场景：处理大量数据、实现无限序列等。\n\n\n# 生成器函数def number_generator(n):   for i in range(n):       yield i       print(f&quot;Yielded &#123;i&#125;&quot;)# 使用生成器gen = number_generator(3)print(next(gen))  # 输出0，之后打印Yielded 0print(next(gen))  # 输出1，之后打印Yielded 1print(next(gen))  # 输出2，之后打印Yielded 2# 使用for循环遍历for num in number_generator(3):   print(num)  # 依次输出0、1、2，每次输出前会打印Yielded相应数字\n\n8.2 __slots__\n概念：__slots__ 是一个类属性，用于限制类的实例可以添加的属性，同时可以提高属性访问速度和节省内存。\n\n原理：默认情况下，类的实例会使用字典存储属性，__slots__ 会让实例使用固定大小的数组存储属性，而不是字典。\n\n注意事项：\n\n__slots__ 中定义的属性是固定的，实例不能添加 __slots__ 之外的属性。\n\n子类如果没有定义 __slots__，则可以继承父类的 __slots__ 并添加新属性；如果子类定义了 __slots__，则是父类 __slots__ 与子类 __slots__ 的并集。\n\n\n\n\nclass Person:   __slots__ = (&quot;name&quot;, &quot;age&quot;)  # 限制只能有name和age属性p = Person()p.name = &quot;Alice&quot;p.age = 18# p.gender = &quot;female&quot;  # 会抛出AttributeError，因为gender不在__slots__中\n\n9. 标准库9.1 re 模块（正则表达式）\n概念：re 模块提供了正则表达式的支持，用于字符串的匹配、查找、替换等操作。\n\n常用函数：\n\nre.match(pattern, string)：从字符串开头匹配模式，返回匹配对象或 None。\n\nre.search(pattern, string)：在整个字符串中查找第一个匹配模式的位置，返回匹配对象或 None。\n\nre.findall(pattern, string)：返回所有匹配模式的子串列表。\n\nre.sub(pattern, repl, string)：将匹配模式的子串替换为 repl，返回替换后的字符串。\n\n\n\n常用元字符：. （匹配任意字符）、*（匹配前一个字符 0 次或多次）、+（匹配前一个字符 1 次或多次）、?（匹配前一个字符 0 次或 1 次）、^（匹配字符串开头）、$（匹配字符串结尾）、[]（字符集）、()（分组）等。\n\n\nimport re# match示例result = re.match(r&quot;Hello&quot;, &quot;Hello World&quot;)print(result.group())  # 输出Hello# search示例result = re.search(r&quot;World&quot;, &quot;Hello World&quot;)print(result.group())  # 输出World# findall示例result = re.findall(r&quot;d+&quot;, &quot;There are 123 apples and 456 bananas&quot;)print(result)  # 输出[&#x27;123&#x27;, &#x27;456&#x27;]# sub示例result = re.sub(r&quot;d+&quot;, &quot;many&quot;, &quot;There are 123 apples and 456 bananas&quot;)print(result)  # 输出There are many apples and many bananas\n\n9.2 pathlib 模块\n概念：pathlib 模块提供了面向对象的文件系统路径操作方式，相比传统的 os.path 模块更直观、易用。\n\n常用类：Path 是主要的类，用于表示文件或目录的路径。\n\n常用方法：\n\nexists()：判断路径是否存在。\n\nis_file()：判断是否为文件。\n\nis_dir()：判断是否为目录。\n\nmkdir()：创建目录。\n\nglob()：查找匹配的文件或目录。\n\nread_text()：读取文本文件内容。\n\nwrite_text()：写入文本内容到文件。\n\n\n\n\nfrom pathlib import Path# 创建Path对象path = Path(&quot;example.txt&quot;)# 检查路径是否存在print(path.exists())  # 输出False（假设文件不存在）# 创建文件并写入内容path.write_text(&quot;Hello, pathlib!&quot;)print(path.exists())  # 输出Trueprint(path.is_file())  # 输出True# 读取文件内容print(path.read_text())  # 输出Hello, pathlib!# 查找当前目录下的txt文件txt_files = list(Path(&quot;.&quot;).glob(&quot;*.txt&quot;))print(txt_files)  # 输出包含example.txt的列表\n\n10. 类型系统10.1 泛型\n概念：泛型允许在定义函数、类或接口时使用类型变量，而不是具体的类型，从而实现代码的复用和类型安全。\n\n作用：在不牺牲类型检查的前提下，使代码能够处理多种不同类型的数据。\n\n实现：使用 typing 模块中的 Generic、TypeVar 等工具。TypeVar 用于定义类型变量，Generic 用于使类支持泛型。\n\n\nfrom typing import TypeVar, Generic, List# 定义类型变量T = TypeVar(&#x27;T&#x27;)# 泛型函数def first_element(lst: List[T]) -&gt; T:   return lst[0]# 泛型类class Stack(Generic[T]):   def __init__(self):       self.items: List[T] = []   def push(self, item: T) -&gt; None:       self.items.append(item)   def pop(self) -&gt; T:       return self.items.pop()# 使用泛型函数int_list = [1, 2, 3]print(first_element(int_list))  # 输出1，类型为intstr_list = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]print(first_element(str_list))  # 输出a，类型为str# 使用泛型类int_stack = Stack[int]()int_stack.push(1)int_stack.push(2)print(int_stack.pop())  # 输出2，类型为intstr_stack = Stack[str]()str_stack.push(&quot;hello&quot;)str_stack.push(&quot;world&quot;)print(str_stack.pop())  # 输出world，类型为str\n","categories":["Python","类型注解"],"tags":["正则表达式","元编程","生成器","类型系统"]},{"title":"Python异闻录（二）","url":"/2025/08/05/Python%E5%BC%82%E9%97%BB%E5%BD%95%EF%BC%88%E4%BA%8C%EF%BC%89/","content":"4. 面向对象4.1 类与对象基础4.1.1 类的定义与对象的创建\n类的语法结构：使用class关键字定义，包含类名、属性和方法\n\nclass ClassName:  # 类属性  class_attribute = value &amp;#x20;  # 实例方法  def method_name(self, parameters):      # 方法体代码\n\n\n\n\n对象的实例化过程及调用类中方法的方式：通过类名加括号实例化对象，如object_name = ClassName()；调用方法为object_name.method_name(arguments)\n\n类与对象的关系：类是对象的模板，对象是类的实例\n\n\n4.1.2 类的属性与方法\n实例属性与类属性的定义及区别：\n\n实例属性：在__init__方法中通过self定义，每个对象的实例属性独立\n\n类属性：在类中直接定义，所有对象共享类属性\n\n\n\n实例方法、类方法与静态方法的定义和使用场景：\n\n实例方法：第一个参数为self，用于操作实例属性\n\n类方法：使用@classmethod装饰，第一个参数为cls，用于操作类属性\n\n静态方法：使用@staticmethod装饰，无默认参数，与类和实例的状态无关\n\n\n\n方法中self参数的含义及作用：代表实例对象本身，用于访问实例属性和实例方法\n\n\n4.1.3 继承与多态\n继承的基本语法：子类继承父类的属性和方法，语法为class SubClassName(ParentClassName):\n\n方法重写：子类对父类方法的重新定义，覆盖父类的方法实现\n\n多态的概念及在代码中的体现：不同对象调用相同方法呈现不同行为，提高代码的灵活性\n\n\n4.2 枚举（Enum）\n概念：是一种特殊的类，用于定义命名的常量集合，每个常量都是枚举类的实例\n\n作用：使代码更具可读性和可维护性，避免使用魔法数字\n\n实现：通过enum模块的Enum类实现\n\n\nfrom enum import Enumclass Color(Enum):  RED = 1  GREEN = 2  BLUE = 3print(Color.RED)  # 输出Color.REDprint(Color.RED.value)  # 输出1print(Color(2))  # 输出Color.GREEN\n\n4.3 数据类（dataclass）\n概念：是一种用于存储数据的类，通过@dataclass装饰器可以自动生成__init__、__repr__、__eq__等方法，简化类的定义\n\n作用：减少样板代码，专注于数据的定义\n\n语法：使用@dataclass装饰类，在类中定义数据字段\n\n\nfrom dataclasses import dataclass@dataclassclass Person:  name: str  age: int  gender: str = &quot;unknown&quot;  # 带有默认值p = Person(&quot;Alice&quot;, 18)print(p)  # 输出Person(name=&#x27;Alice&#x27;, age=18, gender=&#x27;unknown&#x27;)print(p.name)  # 输出Alicep2 = Person(&quot;Bob&quot;, 20)print(p == p2)  # 输出False\n\n4.4 魔法方法4.4.1 魔法方法的特点与作用\n以双下划线开头和结尾的特殊方法\n\n自动调用的机制及在面向对象编程中的意义：在特定操作时自动触发，用于自定义对象的行为\n\n\n4.4.2 常用魔法方法\n__init__方法：对象初始化时的操作，用于设置实例属性\n\n__str__与__repr__方法：控制对象的字符串表示，__str__更注重可读性，__repr__更注重准确性\n\n__add__等运算符重载方法：自定义对象的运算规则，如__add__定义+运算符的行为\n\n__len__方法：获取对象长度的自定义实现，通过len()函数调用\n\n\n4.5 抽象基类（ABC）\n概念：抽象基类是不能被实例化的类，用于定义接口，强制子类实现特定的方法\n\n实现：通过abc模块的ABC类和abstractmethod装饰器实现\n\n\nfrom abc import ABC, abstractmethodclass Animal(ABC):  @abstractmethod  def sound(self):      pass  # 抽象方法，无具体实现class Dog(Animal):  def sound(self):  # 必须实现父类的抽象方法      return &quot;Woof!&quot;class Cat(Animal):  def sound(self):  # 必须实现父类的抽象方法      return &quot;Meow!&quot;dog = Dog()print(dog.sound())  # 输出Woof!cat = Cat()print(cat.sound())  # 输出Meow!\n\n4.6 属性装饰器（@property）\n作用：将方法转换为属性，可像访问属性一样调用方法，同时能控制属性的访问和修改逻辑\n\n组成：包含@property装饰的 getter 方法，以及@属性名.setter装饰的 setter 方法\n\n\nclass Circle:  def __init__(self, radius):      self._radius = radius  # 私有变量，约定以单下划线开头 &amp;#x20;  @property  def radius(self):  # getter方法，用于获取属性值      return self._radius &amp;#x20;  @radius.setter  def radius(self, value):  # setter方法，用于设置属性值，可添加验证逻辑      if value &gt; 0:          self._radius = value      else:          raise ValueError(&quot;Radius must be positive&quot;)circle = Circle(5)print(circle.radius)  # 输出5，调用getter方法circle.radius = 10print(circle.radius)  # 输出10，调用setter方法circle.radius = -3  # 抛出ValueError异常\n\n4.7 多继承与 MRO（方法解析顺序）\n多继承：一个类可以同时继承多个父类，语法为class SubClassName(Parent1, Parent2, ...):\n\nMRO（Method Resolution Order）：方法解析顺序，用于确定多继承中方法的调用顺序，Python 中采用 C3 线性化算法\n\nsuper()的工作原理：根据 MRO 顺序调用父类的方法，而非直接调用某个特定父类\n\n\nclass A:  def show(self):      print(&quot;A&quot;)class B(A):  def show(self):      super().show()  # 调用MRO中下一个类的show方法      print(&quot;B&quot;)class C(A):  def show(self):      super().show()      print(&quot;C&quot;)class D(B, C):  def show(self):      super().show()      print(&quot;D&quot;)d = D()d.show()# 输出顺序：A、C、B、D（根据D的MRO：D -&gt; B -&gt; C -&gt; A -&gt; object）\n5. 文件操作与异常处理5.1 文件操作基础5.1.1 文件的打开与关闭\nopen()函数的参数：\n\n文件名：指定要操作的文件路径\n\n模式：如r（只读）、w（写入）、a（追加）等\n\n编码：如utf-8，指定文件的编码格式\n\n\n\nwith 语句的使用：自动关闭文件，避免资源泄露，语法为with open(filename, mode, encoding) as file_object:\n\n\n5.1.2 文件读写操作\n文本文件的读取：\n\nread()：读取整个文件内容\n\nreadline()：读取一行内容\n\nreadlines()：读取所有行，返回一个列表\n\n\n\n文本文件的写入：\n\nwrite()：写入字符串\n\nwritelines()：写入字符串列表\n\n\n\n常见文件操作异常及处理：如FileNotFoundError（文件未找到）、PermissionError（权限错误）等\n\n\n5.2 永久存储5.2.1 数据持久化的概念\n将内存中的数据保存到外部存储介质（如硬盘）\n\n实现数据长期保存和复用的意义：避免程序运行结束后数据丢失，便于数据的共享和二次处理\n\n\n5.2.2 常见的永久存储方式\n文本文件存储：适用于简单的字符串数据\n\nCSV 文件存储：用于表格形式的数据存储，以逗号分隔字段\n\nJSON 格式存储：轻量级的数据交换格式，适用于结构化数据\n\n\n5.2.3 永久存储的实现\n使用 Python 内置模块操作不同格式的存储文件：如csv模块操作 CSV 文件，json模块操作 JSON 文件\n\n数据的序列化与反序列化：\n\njson模块的dump()函数：将数据序列化并写入文件\n\njson模块的load()函数：从文件中读取数据并反序列化\n\n\n\n\n5.3 异常5.3.1 异常的概念与类型\n异常：程序运行过程中出现的错误，会导致程序终止\n\n常见异常类型：SyntaxError（语法错误）、TypeError（类型错误）、ValueError（值错误）、FileNotFoundError（文件未找到错误）等\n\n\n5.3.2 异常处理机制\ntry-except 语句：捕获并处理异常\n\ntry:   # 可能发生异常的代码except ExceptionType:   # 处理异常的代码\n\n\n\n\ntry-except-else 语句：当没有异常发生时执行 else 块\n\ntry:   # 可能发生异常的代码except ExceptionType:   # 处理异常的代码else:   # 没有异常时执行的代码\n\n\n\n\ntry-except-finally 语句：无论是否发生异常，finally 块都会执行\n\ntry:   # 可能发生异常的代码except ExceptionType:   # 处理异常的代码finally:   # 无论是否异常都执行的代码\n\n5.3.3 异常的抛出与自定义\nraise 语句：主动抛出异常，如raise Exception(&quot;错误信息&quot;)\n\n自定义异常类：根据业务需求定义特定的异常类型，继承自Exception类\n\n\nclass CustomException(Exception):   pass\n\n5.4 上下文管理器的自定义实现\n概念：用于管理资源的对象，确保资源在使用后被正确释放，通过with语句使用\n\n实现：定义一个类，包含__enter__和__exit__方法\n\n__enter__：进入with语句块时调用，返回要管理的资源\n\n__exit__：离开with语句块时调用，释放资源\n\n\n\n\nclass FileManager:   def __init__(self, filename):       self.filename = filename       self.file = None         def __enter__(self):       self.file = open(self.filename, &#x27;r&#x27;)  # 获取资源       return self.file  # 返回资源供with语句使用         def __exit__(self, exc_type, exc_val, exc_tb):       if self.file:           self.file.close()  # 释放资源       # 处理异常（若有），返回True表示异常已处理，不会向外传播       return Falsewith FileManager(&quot;example.txt&quot;) as f:   content = f.read()  # 使用资源# 离开with块后，文件自动关闭\n\n5.5 异常链与 from 语法\n异常链：当一个异常引发另一个异常时，形成异常链，保留原始异常信息\n\nfrom语法：显式指定异常的原因，将原始异常关联到新异常\n\n\ntry:   1 / 0  # 引发ZeroDivisionErrorexcept ZeroDivisionError as e:   # 使用from语法将原始异常e作为新异常的原因   raise ValueError(&quot;Invalid input&quot;) from e\n\n执行上述代码会输出：\nTraceback (most recent call last): File &quot;...&quot;, line 2, in &lt;module&gt;   1 / 0ZeroDivisionError: division by zeroThe above exception was the direct cause of the following exception:Traceback (most recent call last): File &quot;...&quot;, line 5, in &lt;module&gt;   raise ValueError(&quot;Invalid input&quot;) from eValueError: Invalid input\n6. 并发编程6.1 多线程基础6.1.1 线程的概念与特点\n线程：是程序执行的最小单位，一个进程可以包含多个线程，线程共享进程的资源。\n\n特点：\n\n轻量级：线程的创建和销毁开销比进程小。\n\n共享资源：同一进程内的线程共享内存空间等资源，便于数据交换，但需要注意线程安全。\n\n并发执行：多个线程可以同时执行，提高程序的执行效率，尤其是在 I&#x2F;O 密集型任务中。\n\n\n\n\n6.1.2 线程的创建与启动\n使用 threading 模块创建线程，主要有两种方式：\n\n继承 threading.Thread 类，重写 run() 方法。\n\n直接将函数作为参数传递给 threading.Thread 类的构造函数。\n\n\n\n\nimport threadingimport time# 方式一：继承Thread类class MyThread(threading.Thread):   def run(self):       for i in range(3):           print(f&quot;Thread &#123;self.name&#125; is running: &#123;i&#125;&quot;)           time.sleep(1)# 方式二：以函数为参数def thread_func(name):   for i in range(3):       print(f&quot;Thread &#123;name&#125; is running: &#123;i&#125;&quot;)       time.sleep(1)# 启动线程t1 = MyThread(name=&quot;Thread-1&quot;)t1.start()t2 = threading.Thread(target=thread_func, args=(&quot;Thread-2&quot;,))t2.start()# 等待线程结束t1.join()t2.join()print(&quot;All threads finished&quot;)\n\n6.1.3 线程同步与锁机制\n线程同步：当多个线程共享资源时，为了避免数据竞争和不一致，需要进行线程同步。\n\n锁机制：threading.Lock 是常用的同步机制，通过 acquire() 获取锁，release() 释放锁，确保同一时间只有一个线程访问共享资源。\n\n\nimport threadingcount = 0lock = threading.Lock()def increment():   global count   for _ in range(100000):       lock.acquire()  # 获取锁       count += 1       lock.release()  # 释放锁t1 = threading.Thread(target=increment)t2 = threading.Thread(target=increment)t1.start()t2.start()t1.join()t2.join()print(f&quot;Final count: &#123;count&#125;&quot;)  # 输出200000，保证了结果的正确性\n\n6.2 多进程基础6.2.1 进程的概念与特点\n进程：是程序的一次执行过程，拥有独立的内存空间和系统资源。\n\n特点：\n\n独立性：进程之间相互独立，各自拥有独立的内存空间，互不干扰。\n\n开销大：进程的创建、销毁和切换开销比线程大。\n\n安全性高：由于进程间内存独立，不会出现线程间的资源竞争问题，但进程间通信相对复杂。\n\n\n\n\n6.2.2 进程的创建与启动\n使用 multiprocessing 模块创建进程，常用方式与线程类似：\n\n继承 multiprocessing.Process 类，重写 run() 方法。\n\n将函数作为参数传递给 multiprocessing.Process 类的构造函数。\n\n\n\n\nimport multiprocessingimport time# 方式一：继承Process类class MyProcess(multiprocessing.Process):   def run(self):       for i in range(3):           print(f&quot;Process &#123;self.name&#125; is running: &#123;i&#125;&quot;)           time.sleep(1)# 方式二：以函数为参数def process_func(name):   for i in range(3):       print(f&quot;Process &#123;name&#125; is running: &#123;i&#125;&quot;)       time.sleep(1)if __name__ == &quot;__main__&quot;:  # 多进程在Windows下必须加上这句   p1 = MyProcess(name=&quot;Process-1&quot;)   p1.start()   p2 = multiprocessing.Process(target=process_func, args=(&quot;Process-2&quot;,))   p2.start()   p1.join()   p2.join()   print(&quot;All processes finished&quot;)\n\n6.2.3 进程间通信\n由于进程间内存独立，需要特定的机制进行通信，常用的有队列（Queue）和管道（Pipe）。\n\n队列：multiprocessing.Queue 是线程安全的，可用于多个进程间传递数据。\n\n管道：multiprocessing.Pipe 用于两个进程间的通信，返回两个连接对象，分别代表管道的两端。\n\n\n\n\nimport multiprocessingdef producer(queue):   for i in range(5):       queue.put(i)       print(f&quot;Produced: &#123;i&#125;&quot;)def consumer(queue):   while True:       item = queue.get()       if item is None:           break       print(f&quot;Consumed: &#123;item&#125;&quot;)if __name__ == &quot;__main__&quot;:   queue = multiprocessing.Queue()   p1 = multiprocessing.Process(target=producer, args=(queue,))   p2 = multiprocessing.Process(target=consumer, args=(queue,))   p1.start()   p2.start()   p1.join()   queue.put(None)  # 发送结束信号   p2.join()\n","categories":["Python"],"tags":["面向对象","类与对象","魔法方法"]},{"title":"docker离线部署：穿越网络屏障的容器编排利器","url":"/2025/07/16/docker%E7%A6%BB%E7%BA%BF%E9%83%A8%E7%BD%B2%EF%BC%9A%E7%A9%BF%E8%B6%8A%E7%BD%91%E7%BB%9C%E5%B1%8F%E9%9A%9C%E7%9A%84%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E5%88%A9%E5%99%A8/","content":"一、Docker Compose 离线安装步骤\n在 GitHub 上找到对应的 docker-compose 网站，下载适合当前系统的离线安装包（如 docker-compose-linux-x86_64），并将其放置在 &#x2F;tmp 目录下。\n赋予执行权限并移动至系统路径&#xA;# 赋予可执行权限chmod +x /tmp/docker-compose-linux-x86_64# 移动到系统可执行目录sudo mv /tmp/docker-compose-linux-x86_64 /usr/local/bin/docker-compose\n\n验证安装结果&#xA;docker-compose --version# 输出示例：docker-compose version 2.20.3, build a8266d3\n\n二、常见问题与解决方法\n权限不足问题&#xA;问题&#xA;执行 mv 时提示权限错误。\n解决&#xA;使用 sudo 命令获取管理员权限：\nsudo mv /tmp/docker-compose-linux-x86_64 /usr/local/bin/docker-compose\n\n命令不存在问题&#xA;问题&#xA;输入 docker-compose 提示命令未找到。\n解决&#xA;检查系统路径是否包含 &#x2F;usr&#x2F;local&#x2F;bin：\necho $PATH  # 若不含 /usr/local/bin，添加至环境变量export PATH=$PATH:/usr/local/bin\n\n文件名空格问题&#xA;问题&#xA;脚本文件名含前导空格导致命令失败。\n解决&#xA;重命名文件去除空格：\nmv &#x27; replace_image_registry.sh&#x27; replace_image_registry.sh\n\n三、核心命令总结\n安装核心步骤&#xA;下载 → 赋权 → 移动 → 验证\n关键命令&#xA;chmod +x /tmp/docker-compose-linux-x86_64sudo mv /tmp/docker-compose-linux-x86_64 /usr/local/bin/docker-composedocker-compose --version\n\nPS:代码仅供参考，内容不一定正确，要根据实际情况处理喵\n","categories":["容器技术","部署实践"],"tags":["Docker Compose","离线安装","Linux"]},{"title":"揭秘xlsxwriter：富文本格式如何精准“染色”？","url":"/2025/07/16/xlsxwriter%EF%BC%9A%E5%AF%8C%E6%96%87%E6%9C%AC%E6%A0%BC%E5%BC%8F%E5%A6%82%E4%BD%95%E7%B2%BE%E5%87%86%E2%80%9C%E6%9F%93%E8%89%B2%E2%80%9D%EF%BC%9F/","content":"核心概念\nxlsxwriter 通过单元格格式和文本位置索引来精确控制文本区间样式，其判定逻辑基于以下关键内容：\n1. 文本区间定义方式&#xA;# 基本语法（非真实代码，仅示意逻辑）worksheet.write_rich_string(    row, col,    [format1, &quot;红色文本&quot;, format2, &quot;普通文本&quot;])\n\n位置判定：根据字符串在参数列表中的顺序确定位置\n\n格式继承：格式对象作用于紧随其后的文本段\n\n\n2. 关键判定规则&#xA;\n\n\n判定维度&#xA;\n说明&#xA;\n\n\n\n格式对象位置&#xA;\n格式总是应用于下一个字符串元素&#xA;\n\n\n文本分段&#xA;\n每个字符串元素被视为独立文本段&#xA;\n\n\n空格式处理&#xA;\nNone 或省略格式时继承单元格默认格式&#xA;\n\n\n特殊字符&#xA;\n换行符 (\\n) 会创建新文本段但不中断格式应用&#xA;\n\n\n3. 实际应用示例&#xA;案例 1：基础红黑文本&#xA;red = workbook.add_format(&#123;&#x27;color&#x27;: &#x27;red&#x27;&#125;)black = workbook.add_format(&#123;&#x27;color&#x27;: &#x27;black&#x27;&#125;)# &quot;答案&quot;红色，&quot;:&quot;黑色，&quot;42&quot;红色worksheet.write_rich_string(&#x27;A1&#x27;,    red, &#x27;答案&#x27;,    black, &#x27;:&#x27;,    red, &#x27;42&#x27;)\n\n内存中的区间映射：\n[0-2): 红色格式 (对应&quot;答案&quot;)[2-3): 黑色格式 (对应&quot;:&quot;) [3-5): 红色格式 (对应&quot;42&quot;)\n\n案例 2：带格式继承的文本&#xA;bold = workbook.add_format(&#123;&#x27;bold&#x27;: True&#125;)default = workbook.add_format()# &quot;注意&quot;加粗，后续文本默认格式worksheet.write_rich_string(&#x27;A2&#x27;,    bold, &#x27;注意&#x27;,    None, &#x27;：请检查数据&#x27;  # None继承单元格默认格式)\n\n4. 特殊场景处理&#xA;混合格式文本&#xA;# 同一单词中部分字母标红worksheet.write_rich_string(&#x27;A3&#x27;,    black, &#x27;Pri&#x27;,    red, &#x27;mar&#x27;,    black, &#x27;y&#x27;)\n效果：显示为 “Primary” 其中 “mar” 为红色\n动态文本构建&#xA;parts = [black, &quot;随机值：&quot;]if highlight:    parts.extend([red, str(value)])else:    parts.extend([black, str(value)])    worksheet.write_rich_string(&#x27;A4&#x27;, *parts)\n\n5. 底层实现原理&#xA;\nOpenXML 映射：最终生成类似以下 XML 结构\n\n&lt;r&gt;  &lt;rPr&gt;&lt;color rgb=&quot;FFFF0000&quot;/&gt;&lt;/rPr&gt;  &lt;t&gt;答案&lt;/t&gt;&lt;/r&gt;&lt;r&gt;  &lt;rPr&gt;&lt;color rgb=&quot;FF000000&quot;/&gt;&lt;/rPr&gt;  &lt;t&gt;:&lt;/t&gt;&lt;/r&gt;\n\n索引计算：库内部维护格式栈，根据参数顺序计算每个文本段的起止位置\n\n6. 使用限制与注意事项&#xA;\n不可变特性：一旦写入无法修改单个文本段格式\n\n性能影响：每个格式变化都会创建新的&lt;r&gt;元素，过多分段影响文件大小\n\n边界情况：\n\n空字符串仍会占用格式区间\n连续的相同格式不会自动合并\n\n\n\n7. 调试技巧&#xA;# 查看实际生成的XML（需要保存文件后解压查看）workbook.filename = &#x27;output.xlsx&#x27;workbook.close()# 解压后查看xl/worksheets/sheet1.xml\n\n最佳实践建议&#xA;\n批量合并相同格式的文本段\n\n对静态内容预先生成格式列表\n\n避免单个单元格内超过 20 个格式分段\n\n对动态内容使用辅助函数构建参数列表\n\n\ndef build_rich_text(text_parts):    result = []    for text, fmt in text_parts:        result.extend([fmt, text])    return result\n\n注：与 openpyxl 的 CellRichText 不同，xlsxwriter 采用更底层的格式绑定机制，对文本区间的判定完全基于参数序列顺序，不依赖任何文本标记符号。\n关键要点总结&#xA;\nxlsxwriter 的文本区间判定是顺序敏感的\n\n格式对象总是向前绑定到下一个文本元素\n\n实际渲染时会将文本区间映射为 OpenXML 的&lt;r&gt;元素\n\n处理富文本时需要特别注意参数列表的构建顺序\n\n\nPS:代码仅供参考，内容不一定正确，要根据实际情况处理喵\n","categories":["Python库应用"],"tags":["Excel","Python","xlsxwriter","格式化"]},{"title":"Python 魔法：一键让 Excel 正确选项「脸红」","url":"/2025/07/15/Python%E9%AD%94%E6%B3%95%EF%BC%9A%E5%A6%82%E4%BD%95%E7%94%A8%E7%89%B9%E5%BE%81%E8%AF%86%E5%88%AB%E8%AE%A9PDF%E6%B0%B4%E5%8D%B0%E9%9A%90%E5%BD%A2%EF%BC%9F/","content":"在日常工作中，我们经常会遇到带有特定特征的 PDF 水印，比如固定的字体大小、倾斜角度、透明度和颜色。这些特性为我们提供了更精准地识别水印的依据。今天，我们就来深入探讨如何利用 PyMuPDF (Fitz) 库，基于这些特征实现 PDF 水印的精确识别和去除，并整合多种实用方法，帮你应对不同场景。\n特定特征水印的识别原理\nPDF 文件中的文本和图形对象都包含了丰富的元数据信息，例如字体大小、旋转角度、透明度和颜色。当水印具有固定特征时，我们可以通过以下步骤实现精准识别：\n\n解析 PDF 页面内容： 获取页面上所有的文本和图形对象。\n\n提取对象特征： 获取每个对象的字体大小、旋转角度、透明度和颜色等信息。\n\n特征匹配： 将提取到的特征与我们已知的水印特征进行比对。\n\n处理匹配对象： 对符合水印特征的对象进行删除或覆盖处理。\n\n\n典型的 PDF 水印通常具备以下特征：\n\n📐 固定倾斜角度 (常见 15-45 度)\n\n🎨 固定颜色 (常见浅灰色 #C0C0C0)\n\n🌫 固定透明度 (约 30-50%)\n\n🔠 固定字体大小 (通常较大)\n\n🔄 重复出现在每一页相同位置\n\n\n使用 PyMuPDF 实现基于特征的水印处理\n方法一：基于字体大小和旋转角度的水印识别&#xA;这个方法非常适合那些字体大小和倾斜角度都比较固定的水印。\nimport fitzimport mathdef remove_watermark_by_font_size_and_rotation(input_pdf, output_pdf, font_size, rotation_angle):    doc = fitz.open(input_pdf)    for page in doc:        text_infos = page.get_text(&quot;dict&quot;)        for block in text_infos[&quot;blocks&quot;]:            if &quot;lines&quot; in block:                for line in block[&quot;lines&quot;]:                    for span in line[&quot;spans&quot;]:                        current_size = span[&quot;size&quot;]                        matrix = fitz.Matrix(span[&quot;matrix&quot;])                        current_rotation = math.degrees(math.atan2(matrix.b, matrix.a))                        if (abs(current_size - font_size) &lt; 1.5 and                             abs(current_rotation - rotation_angle) &lt; 5.0):                            page.add_redact_annot(fitz.Rect(span[&quot;bbox&quot;]), text=&quot;&quot;)        page.apply_redactions()    doc.save(output_pdf)    doc.close()\n\n代码解析：\n\n我们使用 page.get_text(&quot;dict&quot;) 获取页面上所有的文本信息，包括它们的各种属性。\n\n从文本跨度 (span) 中提取 字体大小 和 变换矩阵。\n\n通过分解变换矩阵来计算文本的 旋转角度。这里使用了 math.atan2(matrix.b, matrix.a) 来更准确地获取旋转角度。\n\n将提取到的特征与你已知的水印特征进行比较，如果匹配（并允许一定的误差范围），就用一个空白矩形覆盖水印区域。\n\n\n难易度：★★★☆☆\n优点： 对具有固定字体大小和倾斜角度的水印效果特别好，误判率低。\n缺点： 需要你预先知道水印的字体大小和旋转角度参数。\n方法二：基于透明度和颜色的水印识别&#xA;这种方法适用于那些有固定透明度和颜色的水印，特别是半透明的浅色水印。\nimport fitzdef remove_watermark_by_opacity_and_color(input_pdf, output_pdf, opacity_threshold, color_rgb_target, color_tolerance=10):    doc = fitz.open(input_pdf)    for page in doc:        text_infos = page.get_text(&quot;dict&quot;)        for block in text_infos[&quot;blocks&quot;]:            if &quot;lines&quot; in block:                for line in block[&quot;lines&quot;]:                    for span in line[&quot;spans&quot;]:                        color_int = span[&quot;color&quot;]                        r = (color_int &gt;&gt; 16) &amp; 0xFF                        g = (color_int &gt;&gt; 8) &amp; 0xFF                        b = color_int &amp; 0xFF                        current_color_rgb = (r, g, b)                        color_match = (                            abs(current_color_rgb[0] - color_rgb_target[0]) &lt;= color_tolerance and                            abs(current_color_rgb[1] - color_rgb_target[1]) &lt;= color_tolerance and                            abs(current_color_rgb[2] - color_rgb_target[2]) &lt;= color_tolerance                        )                        if color_match:                            page.add_redact_annot(fitz.Rect(span[&quot;bbox&quot;]), text=&quot;&quot;)        page.apply_redactions()    doc.save(output_pdf)    doc.close()\n\n代码解析：\n\n我们从文本跨度中提取 RGB 颜色值。\n\n注意： 直接从 span 中提取透明度信息在 PyMuPDF 中比较复杂，因为它通常是 PDF 内容流中的图形状态参数。为了实现真正的透明度识别，你可能需要渲染页面为图像后分析像素的 alpha 通道，或者进行更复杂的 PDF 内容流解析。在上面的代码中，我暂时移除了透明度的判断，主要依赖颜色匹配。\n\n比较提取的颜色与已知水印特征，并设置一个容差范围。\n\n\n难易度：★★★★☆\n优点： 对具有固定颜色（特别是浅色）的水印效果好。\n缺点： 透明度提取是难点，可能需要深入解析 PDF 内部结构或借助图像处理库。\n方法三：综合多特征的水印识别&#xA;当水印特征明确且固定时，这个方法能提供最高的识别准确性，因为它结合了多种特征进行判断。\nimport fitzimport mathdef remove_watermark_by_multiple_features(input_pdf, output_pdf,                                        font_size, rotation_angle,                                        color_rgb,                                        size_tolerance=1.5, rotation_tolerance=5.0, color_tolerance=10):    doc = fitz.open(input_pdf)    for page in doc:        text_infos = page.get_text(&quot;dict&quot;)        for block in text_infos[&quot;blocks&quot;]:            if &quot;lines&quot; in block:                for line in block[&quot;lines&quot;]:                    for span in line[&quot;spans&quot;]:                        current_size = span[&quot;size&quot;]                        matrix = fitz.Matrix(span[&quot;matrix&quot;])                        current_rotation = math.degrees(math.atan2(matrix.b, matrix.a))                        color_int = span[&quot;color&quot;]                        r = (color_int &gt;&gt; 16) &amp; 0xFF                        g = (color_int &gt;&gt; 8) &amp; 0xFF                        b = color_int &amp; 0xFF                        current_color_rgb = (r, g, b)                        size_match = abs(current_size - font_size) &lt; size_tolerance                        rotation_match = abs(current_rotation - rotation_angle) &lt; rotation_tolerance                        color_match = (                            abs(current_color_rgb[0] - color_rgb[0]) &lt;= color_tolerance and                            abs(current_color_rgb[1] - color_rgb[1]) &lt;= color_tolerance and                            abs(current_color_rgb[2] - color_rgb[2]) &lt;= color_tolerance                        )                        if size_match and rotation_match and color_match:                            page.add_redact_annot(fitz.Rect(span[&quot;bbox&quot;]), text=&quot;&quot;)        page.apply_redactions()    doc.save(output_pdf)    doc.close()\n\n代码解析：\n\n综合提取字体大小、旋转角度和颜色三个特征（为了简化和实用性，移除了直接在 span 中获取的透明度判断）。\n\n设置了合理的匹配容差范围，你可以根据实际情况调整这些容差值。\n\n只有当所有选定的特征都匹配时才判定为水印，这大大提高了识别的准确性。\n\n\n难易度：★★★★★\n优点： 识别准确性高，误判率极低。\n缺点： 实现相对复杂，需要精确的水印特征参数。\n方法四：基于文本特征的直接删除法&#xA;如果你知道水印的具体文本内容，或者可以通过一些简单的文本属性来识别，这个方法最直接、最快速。\nimport fitzdef is_watermark_span(span, target_text=None, min_size=None, max_size=None, target_color_rgb=None, color_tolerance=10):    size_match = True    if min_size is not None and span[&quot;size&quot;] &lt; min_size:        size_match = False    if max_size is not None and span[&quot;size&quot;] &gt; max_size:        size_match = False    text_match = True    if target_text is not None and target_text.lower() not in span[&quot;text&quot;].lower():        text_match = False    color_match = True    if target_color_rgb is not None:        color_int = span[&quot;color&quot;]        r = (color_int &gt;&gt; 16) &amp; 0xFF        g = (color_int &gt;&gt; 8) &amp; 0xFF        b = color_int &amp; 0xFF        current_color_rgb = (r, g, b)        if not (abs(current_color_rgb[0] - target_color_rgb[0]) &lt;= color_tolerance and                abs(current_color_rgb[1] - target_color_rgb[1]) &lt;= color_tolerance and                abs(current_color_rgb[2] - target_color_rgb[2]) &lt;= color_tolerance):            color_match = False    return size_match and text_match and color_matchdef remove_watermark_by_text_features(doc_path, output_path, **kwargs):    doc = fitz.open(doc_path)    for page in doc:        for block in page.get_text(&quot;dict&quot;)[&quot;blocks&quot;]:            if block[&quot;type&quot;] == 0:                for line in block[&quot;lines&quot;]:                    for span in line[&quot;spans&quot;]:                        if is_watermark_span(span, **kwargs):                            page.add_redact_annot(span[&quot;bbox&quot;])        page.apply_redactions()    doc.save(output_path)    doc.close()\n\n代码解析：\n\n通过一个可自定义的 is_watermark_span 函数直接搜索符合特定文本特征的水印内容。\n\n你可以传入 target_text、min_size、max_size 和 target_color_rgb 等参数来精确定义水印的特征。\n\n对判定为水印的文本进行覆盖处理。\n\n\n难易度：★★☆☆☆\n优点： 实现简单，处理速度快，非常适合处理简单的文本水印。\n缺点： 仅适用于文本水印，无法处理图像水印。\n方法五：基于混合特征的高级识别法&#xA;对于更复杂的 PDF 水印（例如包含文本和图像），这种方法结合了文本和图像特征识别，能够提供更高的识别精度。请注意，图像处理部分需要 numpy 和 opencv-python 库。\nimport fitzimport numpy as npimport cv2def advanced_watermark_removal(doc_path, output_path, watermark_template_path=None):    doc = fitz.open(doc_path)    if watermark_template_path:        watermark_template = cv2.imread(watermark_template_path, cv2.IMREAD_GRAYSCALE)        sift = cv2.SIFT_create()        kp1, des1 = sift.detectAndCompute(watermark_template, None)        for page in doc:        text_spans_to_redact = []        image_regions_to_redact = []        text_infos = page.get_text(&quot;dict&quot;)        for block in text_infos[&quot;blocks&quot;]:            if &quot;lines&quot; in block:                for line in block[&quot;lines&quot;]:                    for span in line[&quot;spans&quot;]:                        if (100 &lt;= span[&quot;color_rgb&quot;][0] &lt;= 220 and                             100 &lt;= span[&quot;color_rgb&quot;][1] &lt;= 220 and                             100 &lt;= span[&quot;color_rgb&quot;][2] &lt;= 220) and span[&quot;size&quot;] &gt; 15:                            text_spans_to_redact.append(span[&quot;bbox&quot;])                if watermark_template_path and des1 is not None:            pix = page.get_pixmap(matrix=fitz.Matrix(2,2))            img = cv2.cvtColor(np.frombuffer(pix.samples, np.uint8).reshape(                pix.h, pix.w, pix.n), cv2.COLOR_RGB2GRAY)            kp2, des2 = sift.detectAndCompute(img, None)            if des2 is not None and len(des1) &gt; 0 and len(des2) &gt; 0:                matcher = cv2.BFMatcher()                matches = matcher.knnMatch(des1, des2, k=2)                good_matches = [m for m, n in matches if m.distance &lt; 0.75 * n.distance]                if len(good_matches) &gt; 10:                    src_pts = np.float32([kp1[m.queryIdx].pt for m in good_matches]).reshape(-1, 1, 2)                    dst_pts = np.float32([kp2[m.trainIdx].pt for m in good_matches]).reshape(-1, 1, 2)                    M, mask = cv2.findHomography(src_pts, dst_pts, cv2.RANSAC, 5.0)                    if M is not None:                        h, w = watermark_template.shape                        pts = np.float32([[0, 0], [0, h-1], [w-1, h-1], [w-1, 0]]).reshape(-1, 1, 2)                        dst = cv2.perspectiveTransform(pts, M)                        min_x = int(np.min(dst[:, 0, 0]) / pix.matrix.a)                        min_y = int(np.min(dst[:, 0, 1]) / pix.matrix.d)                        max_x = int(np.max(dst[:, 0, 0]) / pix.matrix.a)                        max_y = int(np.max(dst[:, 0, 1]) / pix.matrix.d)                        image_regions_to_redact.append((min_x, min_y, max_x, max_y))                for span_bbox in text_spans_to_redact:            page.add_redact_annot(fitz.Rect(span_bbox))        for region_bbox in image_regions_to_redact:            page.add_redact_annot(fitz.Rect(region_bbox))        page.apply_redactions()    doc.save(output_path)    doc.close()\n\n代码解析：\n\n文本特征识别： 沿用了之前 is_watermark_text 的概念，但你需要根据实际水印特性来完善这个逻辑。\n\n图像特征识别：\n\n将 PDF 页面渲染为图像，并转换为灰度图，以便进行特征检测。\n\n使用 SIFT 算法（或其他特征匹配算法如 ORB, SURF）来检测并匹配图像水印模板。\n\n通过 findHomography 计算水印在页面上的变换，从而确定水印的精确位置和边界框。\n\n注意： 图像处理库 (如 OpenCV) 通常在像素坐标系下操作，你需要将检测到的像素坐标转换回 PyMuPDF 使用的 PDF 坐标。\n\n综合处理： 将文本和图像识别的结果结合起来，对所有识别出的水印区域进行处理。\n\n\n难易度：★★★★☆\n优点： 识别精度高，适用于复杂水印环境（文本与图像混合），鲁棒性强。\n缺点： 实现复杂，需要水印模板，处理速度相对较慢，需要额外的图像处理库。\n方法六：基于 PDF 底层结构的终极方案&#xA;这种方法最为彻底，因为它直接操作 PDF 文件的底层结构。但它也要求你对 PDF 规范有深入的了解，操作不当可能会导致文件损坏。\nimport fitzdef deep_watermark_removal(doc_path, output_path):    print(&quot;警告：此方法在PyMuPDF中难以直接实现，推荐使用更安全的redaction方法&quot;)    doc = fitz.open(doc_path)    doc.save(output_path)    doc.close()\n\n代码解析：\n\n这个方法旨在直接操作 PDF 的 XObject (外部对象，可以是图像或 Form XObject) 和内容流。\n\n重要提示： PyMuPDF (Fitz) 并没有直接暴露修改或删除底层 PDF 对象的 API。 add_redact_annot 是 PyMuPDF 中最安全和推荐的方式来 “删除” 页面内容的。直接修改 PDF 的底层内容流非常危险，操作不当很可能导致 PDF 文件损坏且无法打开。\n\n因此，我调整了此方法的描述和代码示例，强调其复杂性和风险，并指出在 PyMuPDF 中，更推荐使用 add_redact_annot 来实现 “删除” 效果。如果你真的需要深入到 PDF 底层修改，可能需要更专业的 PDF 处理库或对 PDF 规范有极其深入的了解。\n\n\n难易度：★★★★★ (理论上)\n优点： 理论上可以彻底清除不留痕迹，适用于各种类型水印。\n缺点： 实现非常复杂，需要深入的 PDF 结构知识，且在 PyMuPDF 中直接实现此类操作难度极高且风险大。\n方法对比与选择建议\n\n\n\n方法&#xA;\n难易度&#xA;\n适用场景&#xA;\n关键优势&#xA;\n局限性&#xA;\n\n\n\n字体大小 + 旋转角度&#xA;\n★★★☆☆&#xA;\n水印有固定大小和倾斜角度&#xA;\n实现相对简单，识别准确率较高&#xA;\n需要精确的大小和角度参数&#xA;\n\n\n透明度 + 颜色&#xA;\n★★★★☆&#xA;\n水印有固定颜色（特别是浅色）&#xA;\n对浅色水印效果好&#xA;\n透明度提取是难点，可能需要深入解析 PDF 内部结构或借助图像处理库&#xA;\n\n\n多特征综合&#xA;\n★★★★★&#xA;\n水印特征明确且固定&#xA;\n识别准确性高，误判率极低&#xA;\n实现相对复杂，需要精确的水印特征参数&#xA;\n\n\n基于文本特征&#xA;\n★★☆☆☆&#xA;\n简单文本水印&#xA;\n实现简单，处理速度快&#xA;\n仅适用于文本水印，无法处理图像水印&#xA;\n\n\n混合特征识别&#xA;\n★★★★☆&#xA;\n复杂水印环境（文本与图像混合）&#xA;\n识别精度高&#xA;\n实现复杂，需要水印模板，处理速度慢&#xA;\n\n\n底层结构处理&#xA;\n★★★★★&#xA;\n各种类型水印&#xA;\n理论上最彻底&#xA;\n高风险，PyMuPDF 中难以直接实现，需要深厚知识&#xA;\n\n\n特征参数提取方法\n在实际应用中，我们首先需要获取水印的特征参数。可以通过以下方式初步提取：\nimport fitzimport mathfrom collections import Counterdef extract_watermark_features(pdf_path, page_num=0):    doc = fitz.open(pdf_path)    page = doc[page_num]    possible_font_sizes = []    possible_rotations = []    possible_colors = []        text_infos = page.get_text(&quot;dict&quot;)    for block in text_infos[&quot;blocks&quot;]:        if &quot;lines&quot; in block:            for line in block[&quot;lines&quot;]:                for span in line[&quot;spans&quot;]:                    possible_font_sizes.append(round(span[&quot;size&quot;], 1))                    matrix = fitz.Matrix(span[&quot;matrix&quot;])                    rotation = round(math.degrees(math.atan2(matrix.b, matrix.a)), 1)                    possible_rotations.append(rotation)                    color_int = span[&quot;color&quot;]                    r = (color_int &gt;&gt; 16) &amp; 0xFF                    g = (color_int &gt;&gt; 8) &amp; 0xFF                    b = color_int &amp; 0xFF                    possible_colors.append((r, g, b))        font_size = Counter(possible_font_sizes).most_common(1)[0][0] if possible_font_sizes else None    rotation_angle = Counter(possible_rotations).most_common(1)[0][0] if possible_rotations else None    if rotation_angle and rotation_angle &lt; 0:        rotation_angle += 360    color_rgb = Counter(possible_colors).most_common(1)[0][0] if possible_colors else None        doc.close()    return &#123;        &quot;font_size&quot;: font_size,        &quot;rotation_angle&quot;: rotation_angle,        &quot;color_rgb&quot;: color_rgb,        &quot;opacity&quot;: 0.5    &#125;\n\n代码解析：\n\n此函数会遍历指定页面的所有文本跨度，收集它们的字体大小、旋转角度和颜色。\n\n为了方便统计，对浮点数（大小和角度）进行了四舍五入。\n\n使用 collections.Counter 找出最常见的字体大小、旋转角度和颜色，作为可能的水印特征。\n\n注意： 提取透明度仍然是一个挑战，opacity 参数在此处仍作为占位符，需要通过其他方式（例如手动观察或更复杂的 PDF 内容流解析）来确定。\n\n\n总结与最佳实践\n基于特征的 PDF 水印处理方法能够实现更精确的水印识别和去除，但这要求你对水印的特征有充分了解。在实际应用中，我建议你遵循以下最佳实践：\n\n预处理分析： 首先使用 extract_watermark_features 函数分析水印特征，初步了解水印的字体大小、旋转角度、颜色等关键信息。必要时，手工观察水印，确认其透明度、具体文本内容或图像样式。\n\n从简到繁尝试： 从最简单的方法开始。如果水印是纯文本且特征明显，可以先尝试 基于文本特征的直接删除法。如果水印有固定的字体大小和倾斜角度，就用 基于字体大小和旋转角度的方法。只有当简单方法效果不佳时，再逐步增加特征维度，尝试 多特征综合识别。\n\n合理调整参数： 根据实际水印情况细致调整匹配容差值，在识别准确率和误判率之间取得最佳平衡。例如，对于字体大小，可以允许 1.0 到 2.0 的误差范围；对于旋转角度，可允许 3 到 5 度左右的误差。\n\n复杂场景组合： 对于包含多种类型水印的复杂 PDF，考虑结合多种方法进行处理。例如，对于既有文本又有图像的混合水印，可以结合 混合特征识别法。\n\n批量处理技巧： 如果你需要处理大量 PDF 文件，利用多线程或多进程可以显著提高处理效率。\n\n\nfrom concurrent.futures import ThreadPoolExecutorimport osdef batch_process_pdfs(file_list, output_dir, **watermark_params):    os.makedirs(output_dir, exist_ok=True)    with ThreadPoolExecutor(max_workers=os.cpu_count()) as executor:        futures = []        for file_path in file_list:            file_name = os.path.basename(file_path)            output_path = os.path.join(output_dir, file_name)            futures.append(executor.submit(                remove_watermark_by_multiple_features,                file_path, output_path, **watermark_params            ))        for future in futures:            try:                future.result()                print(f&quot;文件处理完成：&#123;file_path&#125;&quot;)            except Exception as exc:                print(f&quot;文件 &#123;file_path&#125; 处理时发生错误：&#123;exc&#125;&quot;)\n\n\n\n\n操作安全保障： 在处理任何重要文件之前，务必先备份原始文件！这能确保即使处理不当，你也不会丢失原始数据。同时，请始终遵守相关法律法规，仅处理你有权修改的文档，尊重知识产权和版权保护。\n\n通过合理选择和组合这些方法，你就能高效且精准地处理各种具有特定特征的 PDF 水印。\nPS:代码仅供参考，内容不一定正确，要根据实际情况处理喵\n","categories":["PDF 处理","Python","数据处理"],"tags":["Python","PyMuPDF","PDF","水印去除","特征识别","文本处理"]},{"title":"《水印处理的成长日记：从0开始的PDF处理之路》","url":"/2025/07/16/%E3%80%8A%E6%B0%B4%E5%8D%B0%E5%A4%84%E7%90%86%E7%9A%84%E6%88%90%E9%95%BF%E6%97%A5%E8%AE%B0%EF%BC%9A%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84PDF%E5%A4%84%E7%90%86%E4%B9%8B%E8%B7%AF%E3%80%8B/","content":"在日常办公和学习中，我们经常会遇到带有水印的 PDF 文档，这些水印不仅影响阅读体验，还可能干扰文档的二次编辑和使用。本文将带你从零开始，一步步构建一个功能完善的 PDF 水印去除工具，实现从单文件处理到批量转换的完整解决方案。\n需求分析：为什么需要 PDF 水印去除工具\nPDF 水印通常分为可见水印和不可见水印两类。可见水印多以文字、Logo 等形式存在，虽然不影响内容的可读性，但在文档分发、打印等场景下会显得不够专业。特别是一些带有 “内部资料”、”草稿” 等字样的水印，在正式场合使用时需要去除。\n理想的 PDF 水印去除工具应具备以下功能：\n\n精准识别并去除各类可见水印\n\n保留原文档的文本格式和图片内容\n\n支持批量处理多个 PDF 文件\n\n提供直观易用的图形界面\n\n输出格式支持 Word，方便后续编辑\n\n\n基础版本：实现单文件水印去除功能\n我们先从基础版本开始，搭建一个能够处理单个 PDF 文件的水印去除工具。这个版本将实现水印识别、内容提取和格式转换的核心功能。\n核心技术选型&#xA;实现 PDF 水印去除需要用到以下关键库：\n\nfitz（PyMuPDF）：用于 PDF 文件的解析和内容提取\n\npython-docx：用于生成 Word 格式的输出文件\n\nPIL（Pillow）：用于处理 PDF 中的图片内容\n\nPyQt5：用于构建图形用户界面\n\n\n核心功能实现&#xA;基础版本的核心功能主要分为三个模块：PDF 信息提取、水印识别与去除、Word 文档生成。\nPDF 信息提取模块&#xA;extract_full_pdf_info函数负责从 PDF 中提取文本内容、图片和格式信息：\ndef extract_full_pdf_info(pdf_path: str) -&gt; List[Dict[str, Any]]:    if not os.path.exists(pdf_path):        raise FileNotFoundError(f&quot;PDF文件未找到: &#123;pdf_path&#125;&quot;)    doc = fitz.open(pdf_path)    full_info = []    temp_image_dir = os.path.abspath(&quot;temp_pdf_images&quot;)    os.makedirs(temp_image_dir, exist_ok=True)    for page_num in range(len(doc)):        page = doc[page_num]        page_data = &#123;            &quot;page_number&quot;: page_num + 1,            &quot;page_size&quot;: &#123;&quot;width&quot;: page.rect.width, &quot;height&quot;: page.rect.height&#125;,            &quot;rotation&quot;: page.rotation,            &quot;text_content&quot;: [],            &quot;images&quot;: []        &#125;        # 提取文本内容        text_blocks = page.get_text(&quot;dict&quot;)[&quot;blocks&quot;]        for block in text_blocks:            if block[&quot;type&quot;] == 0:  # 文本块                # 处理文本块、行和文字片段...        # 提取图片        images = page.get_images(full=True)        # 处理图片提取、软掩码合并和格式转换...        full_info.append(page_data)    doc.close()    return full_info\n水印识别与去除模块&#xA;remove_watermark_by_alpha函数通过分析文本的透明度、字体大小和颜色来识别并去除水印：\ndef remove_watermark_by_alpha(full_info: List[Dict[str, Any]]) -&gt; List[Dict[str, Any]]:    clean_full_info = []    watermark_removed_count = 0    ALPHA_THRESHOLD = 150  # 透明度阈值    TARGET_FONT_SIZE = 18  # 水印字体大小    FONT_SIZE_TOLERANCE = 1  # 字体大小容差    TARGET_COLOR_INT_VALUE = 13882323  # 水印颜色值    for page in full_info:        clean_text_blocks = []        for text_block in page[&quot;text_content&quot;]:            # 处理文本块，过滤水印内容...            watermark_removed_count += 1  # 统计去除的水印数量        clean_page = &#123;**page, &quot;text_content&quot;: clean_text_blocks, &quot;images&quot;: page[&quot;images&quot;]&#125;        clean_full_info.append(clean_page)    print(f&quot;水印移除完成。共移除 &#123;watermark_removed_count&#125; 处水印文本。&quot;)    return clean_full_info\nWord 文档生成模块&#xA;generate_word_from_data函数将清理后的内容转换为 Word 文档：\ndef generate_word_from_data(clean_info: List[Dict[str, Any]], output_word_path: str) -&gt; None:    doc = Document()    font_mapping = get_system_font_mapping()  # 字体映射表    # 收集并排序文本和图片元素...    # 生成Word内容，保留原格式...    try:        doc.save(output_word_path)        print(f&quot;Word文档已保存至：&#123;output_word_path&#125;&quot;)    except Exception as e:       print(f&quot;保存Word文档失败：&#123;e&#125;&quot;)\n基础版本界面设计&#xA;基础版本采用简洁的图形界面，主要包含文件选择、处理和状态显示功能：\nclass PdfWatermarkRemoverApp(QWidget):    def __init__(self):        super().__init__()        self.setWindowTitle(&quot;PDF水印移除工具&quot;)        self.setFixedSize(750, 400)        self.init_ui()        # 初始化其他属性...    def init_ui(self):        main_layout = QVBoxLayout()        # 设置布局、添加文件选择框、处理按钮和状态标签...    def browse_pdf_file(self):        # 打开文件对话框，选择PDF文件...    def start_processing(self):        # 开始处理PDF文件...\n优化版本：功能增强与体验提升\n在基础版本的基础上，我们进一步优化功能，增加批量处理能力，提升用户体验，打造一个更实用的工具。\n核心功能改进&#xA;优化版本主要在以下几个方面进行了改进：\n1. 增加文件夹批量处理功能&#xA;用户可以选择整个文件夹进行批量处理，工具会自动识别并处理文件夹中的所有 PDF 文件：\ndef browse_folder(self):    folder_path = QFileDialog.getExistingDirectory(self, &quot;选择包含 PDF 文件的文件夹&quot;)    if folder_path:        self.processing_queue = []        # 遍历文件夹，收集所有PDF文件...        self.total_files_to_process = len(self.processing_queue)        self.processing_mode = &quot;folder&quot;       # 更新界面显示...\n\n2. 改进的文件处理流程&#xA;引入处理队列和工作线程，支持连续处理多个文件，并显示实时进度：\ndef process_next_file(self):    if not self.processing_queue:        self.on_all_processing_finished()  # 所有文件处理完成        return    current_pdf_path = self.processing_queue.pop(0)    # 确定输出路径...    # 检查文件是否已存在，处理覆盖逻辑...    self.processed_count += 1   self.status_label.setText(f&quot;正在处理第 &#123;self.processed_count&#125; / &#123;self.total_files_to_process&#125; 个文件...&quot;)    # 启动工作线程处理当前文件...\n3. 增强的图片处理能力&#xA;优化图片提取和转换逻辑，更好地保留图片质量和透明度：\ndef convert_image_format(temp_path, target_format=&#x27;png&#x27;):    try:        with Image.open(temp_path) as img:            original_mode = img.mode            new_path = os.path.splitext(temp_path)[0] + f&#x27;.&#123;target_format&#125;&#x27;            if &#x27;A&#x27; in original_mode:  # 处理透明图片                if original_mode != &#x27;RGBA&#x27;:                    img = img.convert(&#x27;RGBA&#x27;)               img.save(new_path, format=target_format.upper())               # 输出转换信息...           else:               # 处理非透明图片...           return new_path   except Exception as e:       # 处理转换错误...\n\n4. 更智能的文本格式处理&#xA;优化文本排版逻辑，自动识别标题、段落，保持原文档的格式风格：\n# 分析最常见的字体大小作为正文字体if all_font_sizes:   from collections import Counter   most_common_size = Counter(all_font_sizes).most_common(1)[0][0]   print(f&quot;分析得出正文字体大小: &#123;most_common_size&#125;&quot;)   title_font_threshold = most_common_size * 1.2  # 标题字体阈值else:   # 使用默认值...\n\n界面与交互优化&#xA;优化版本的界面更加友好，交互更加流畅：\n1. 直观的文件选择界面&#xA;提供文件和文件夹两种选择方式，满足不同场景需求：\n# 选择文件按钮self.browse_files_button = QPushButton(&quot;选择文件...&quot;)self.browse_files_button.clicked.connect(self.browse_pdf_files)# 选择文件夹按钮self.browse_folder_button = QPushButton(&quot;选择文件夹...&quot;)self.browse_folder_button.clicked.connect(self.browse_folder)\n\n2. 实时进度显示&#xA;清晰展示当前处理进度和状态，让用户了解处理情况：\nself.status_label = QLabel(&quot;等待选择文件/文件夹...&quot;)self.current_file_status_label = QLabel(&quot;&quot;)  # 显示当前处理的文件名\n\n3. 文件覆盖策略选择&#xA;当输出文件已存在时，提供灵活的覆盖选项：\n# 覆盖所有文件复选框self.overwrite_all_checkbox = QCheckBox(&quot;对当前批次的所有冲突文件执行此操作&quot;)self.overwrite_all_checkbox.setVisible(False)  # 默认隐藏\n\n工具使用指南\n使用优化后的 PDF 水印去除工具非常简单，只需几个步骤即可完成水印去除：\n\n选择文件或文件夹：点击 “选择文件” 按钮处理单个 PDF，或点击 “选择文件夹” 按钮批量处理多个 PDF。\n\n开始处理：点击 “开始处理” 按钮，工具将自动去除水印并转换为 Word 格式。\n\n查看结果：处理完成后，工具会显示成功和失败的文件统计，结果文件将保存在源文件所在目录的 “_无水印” 子文件夹中。\n\n\n常见问题与解决方案\n在使用过程中，可能会遇到一些常见问题，以下是解决方案：\n\n水印去除不彻底：可能是水印特征发生变化，可以调整 remove_watermark_by_alpha 函数中的阈值参数。\n\n图片显示异常：部分特殊格式的图片可能转换失败，可以尝试更新 Pillow 库到最新版本。\n\n格式错乱：复杂排版的 PDF 转换后可能出现格式问题，可以手动调整 Word 文档的样式。\n\n处理速度慢：大型 PDF 文件处理需要较长时间，请耐心等待，工具正在后台工作。\n\n\n总结与展望\n通过本文介绍的方法，我们成功构建了一个功能完善的 PDF 水印去除工具，实现了从单文件处理到批量转换的完整解决方案。该工具能够精准去除水印，保留原文档的文本格式和图片内容，大大提高了文档处理效率。\n未来，我们可以从以下几个方面进一步优化这个工具：\n\n增加对更多水印类型的支持，如图片水印、倾斜文字水印等\n\n优化 OCR 功能，提高扫描版 PDF 的处理效果\n\n增加自定义水印规则的功能，允许用户手动标记水印特征\n\n支持更多输出格式，如 Markdown、HTML 等\n\n开发云同步功能，实现跨设备使用\n\n\n完整代码实现\n以下是完整的 PDF 水印去除工具代码，包含所有功能模块和界面实现：\nimport osimport sysimport tempfilefrom typing import List, Dict, Any, Tuple, Optionalfrom collections import Counterfrom PyQt5.QtWidgets import (QApplication, QWidget, QVBoxLayout, QHBoxLayout,                          QPushButton, QLabel, QFileDialog, QProgressBar,                          QMessageBox, QCheckBox, QFrame)from PyQt5.QtCore import Qt, QThread, pyqtSignalfrom PyQt5.QtGui import QFontimport fitz  # PyMuPDFfrom docx import Documentfrom docx.shared import Pt, Inchesfrom docx.oxml.ns import qnfrom docx.enum.text import WD_ALIGN_PARAGRAPHfrom PIL import Image# 全局临时目录，用于存储提取的图片GLOBAL_TEMP_DIR = os.path.join(tempfile.gettempdir(), &quot;pdf_watermark_remover&quot;)os.makedirs(GLOBAL_TEMP_DIR, exist_ok=True)class PDFProcessor:   &quot;&quot;&quot;PDF处理核心类，负责提取内容、去除水印和生成Word文档&quot;&quot;&quot;   @staticmethod   def extract_full_pdf_info(pdf_path: str) -&gt; List[Dict[str, Any]]:       &quot;&quot;&quot;提取PDF中的文本、图片和格式信息&quot;&quot;&quot;       if not os.path.exists(pdf_path):           raise FileNotFoundError(f&quot;PDF文件未找到: &#123;pdf_path&#125;&quot;)       doc = fitz.open(pdf_path)       full_info = []       temp_image_dir = os.path.join(GLOBAL_TEMP_DIR, os.path.basename(pdf_path).replace(&#x27;.pdf&#x27;, &#x27;&#x27;))       os.makedirs(temp_image_dir, exist_ok=True)       for page_num in range(len(doc)):           page = doc[page_num]           page_data = &#123;               &quot;page_number&quot;: page_num + 1,               &quot;page_size&quot;: &#123;&quot;width&quot;: page.rect.width, &quot;height&quot;: page.rect.height&#125;,               &quot;rotation&quot;: page.rotation,               &quot;text_content&quot;: [],               &quot;images&quot;: []           &#125;           # 提取文本内容           text_blocks = page.get_text(&quot;dict&quot;)[&quot;blocks&quot;]           for block in text_blocks:               if block[&quot;type&quot;] == 0:  # 文本块                   text_block_data = &#123;                       &quot;bbox&quot;: block[&quot;bbox&quot;],                       &quot;lines&quot;: []                   &#125;                   for line in block[&quot;lines&quot;]:                       line_data = &#123;                           &quot;spans&quot;: [],                           &quot;bbox&quot;: line[&quot;bbox&quot;]                       &#125;                       for span in line[&quot;spans&quot;]:                           span_data = &#123;                               &quot;text&quot;: span[&quot;text&quot;],                               &quot;font&quot;: span[&quot;font&quot;],                               &quot;size&quot;: span[&quot;size&quot;],                               &quot;color&quot;: span[&quot;color&quot;],                               &quot;flags&quot;: span[&quot;flags&quot;],                               &quot;bbox&quot;: span[&quot;bbox&quot;]                           &#125;                           line_data[&quot;spans&quot;].append(span_data)                       text_block_data[&quot;lines&quot;].append(line_data)                   page_data[&quot;text_content&quot;].append(text_block_data)           # 提取图片           images = page.get_images(full=True)           for img_index, img in enumerate(images):               xref = img[0]               base_image = doc.extract_image(xref)               image_bytes = base_image[&quot;image&quot;]               image_ext = base_image[&quot;ext&quot;]               image_width = base_image[&quot;width&quot;]               image_height = base_image[&quot;height&quot;]               # 构建图片路径               img_filename = f&quot;page_&#123;page_num+1&#125;_img_&#123;img_index&#125;.&#123;image_ext&#125;&quot;               img_path = os.path.join(temp_image_dir, img_filename)               # 保存图片               with open(img_path, &quot;wb&quot;) as f:                   f.write(image_bytes)               # 处理软掩码（透明度）               if base_image[&quot;smask&quot;]:                   smask_image = doc.extract_image(base_image[&quot;smask&quot;])                   smask_bytes = smask_image[&quot;image&quot;]                   smask_path = os.path.join(temp_image_dir, f&quot;page_&#123;page_num+1&#125;_img_&#123;img_index&#125;_mask.&#123;image_ext&#125;&quot;)                   with open(smask_path, &quot;wb&quot;) as f:                       f.write(smask_bytes)                   # 合并图片和掩码                   img_path = PDFProcessor.merge_image_with_mask(img_path, smask_path)                   os.remove(smask_path)  # 清理临时掩码文件               # 转换图片格式为PNG以确保兼容性               if image_ext.lower() != &#x27;png&#x27;:                   img_path = PDFProcessor.convert_image_format(img_path, &#x27;png&#x27;)               # 获取图片在页面中的位置               img_rect = page.get_image_rects(xref)[0]               page_data[&quot;images&quot;].append(&#123;                   &quot;path&quot;: img_path,                   &quot;ext&quot;: image_ext,                   &quot;width&quot;: image_width,                   &quot;height&quot;: image_height,                   &quot;rect&quot;: img_rect,                   &quot;index&quot;: img_index               &#125;)           full_info.append(page_data)       doc.close()       return full_info   @staticmethod   def merge_image_with_mask(image_path: str, mask_path: str) -&gt; str:       &quot;&quot;&quot;合并图片和掩码以保留透明度&quot;&quot;&quot;       try:           with Image.open(image_path) as img, Image.open(mask_path) as mask:               # 确保图片和掩码尺寸一致               if img.size != mask.size:                   mask = mask.resize(img.size)               # 合并图片和掩码               img.putalpha(mask)               new_path = os.path.splitext(image_path)[0] + &#x27;_merged.png&#x27;               img.save(new_path, &#x27;PNG&#x27;)               os.remove(image_path)  # 移除原始图片               return new_path       except Exception as e:           print(f&quot;合并图片和掩码失败: &#123;e&#125;&quot;)           return image_path  # 失败时返回原始图片路径   @staticmethod   def convert_image_format(temp_path: str, target_format: str = &#x27;png&#x27;) -&gt; str:       &quot;&quot;&quot;转换图片格式&quot;&quot;&quot;       try:           with Image.open(temp_path) as img:               original_mode = img.mode               new_path = os.path.splitext(temp_path)[0] + f&#x27;.&#123;target_format&#125;&#x27;               # 处理透明图片               if &#x27;A&#x27; in original_mode:                   if original_mode != &#x27;RGBA&#x27;:                       img = img.convert(&#x27;RGBA&#x27;)                   img.save(new_path, format=target_format.upper())               else:                   # 非透明图片直接转换                   img.save(new_path, format=target_format.upper())               os.remove(temp_path)  # 移除原始格式图片               return new_path       except Exception as e:           print(f&quot;转换图片格式失败: &#123;e&#125;&quot;)           return temp_path  # 失败时返回原始路径   @staticmethod   def remove_watermark_by_alpha(full_info: List[Dict[str, Any]]) -&gt; List[Dict[str, Any]]:       &quot;&quot;&quot;通过透明度、字体大小和颜色识别并去除水印&quot;&quot;&quot;       clean_full_info = []       watermark_removed_count = 0       # 水印特征参数       ALPHA_THRESHOLD = 150  # 透明度阈值       TARGET_FONT_SIZE = 18  # 水印字体大小       FONT_SIZE_TOLERANCE = 1  # 字体大小容差       TARGET_COLOR_INT_VALUE = 13882323  # 水印颜色值       for page in full_info:           clean_text_blocks = []           for text_block in page[&quot;text_content&quot;]:               clean_lines = []               for line in text_block[&quot;lines&quot;]:                   clean_spans = []                   for span in line[&quot;spans&quot;]:                       # 检查是否为水印文本                       is_watermark = False                       # 检查字体大小                       size_diff = abs(span[&quot;size&quot;] - TARGET_FONT_SIZE)                       if size_diff &lt;= FONT_SIZE_TOLERANCE:                           # 检查颜色                           if span[&quot;color&quot;] == TARGET_COLOR_INT_VALUE:                               # 检查透明度（通过flags判断）                               # flags的第3位表示透明度                               if (span[&quot;flags&quot;] &amp; 0b100) != 0:                                   is_watermark = True                       if not is_watermark:                           clean_spans.append(span)                       else:                           watermark_removed_count += 1                   if clean_spans:  # 只保留有内容的行                       clean_line = &#123;**line, &quot;spans&quot;: clean_spans&#125;                       clean_lines.append(clean_line)               if clean_lines:  # 只保留有内容的文本块                   clean_block = &#123;** text_block, &quot;lines&quot;: clean_lines&#125;                   clean_text_blocks.append(clean_block)           # 保留图片信息           clean_page = &#123;**page, &quot;text_content&quot;: clean_text_blocks, &quot;images&quot;: page[&quot;images&quot;]&#125;           clean_full_info.append(clean_page)       print(f&quot;水印移除完成。共移除 &#123;watermark_removed_count&#125; 处水印文本。&quot;)       return clean_full_info   @staticmethod   def get_system_font_mapping() -&gt; Dict[str, str]:       &quot;&quot;&quot;获取系统字体映射表，用于PDF到Word的字体转换&quot;&quot;&quot;       return &#123;           &quot;SimSun&quot;: &quot;宋体&quot;,           &quot;SimHei&quot;: &quot;黑体&quot;,           &quot;Microsoft YaHei&quot;: &quot;微软雅黑&quot;,           &quot;KaiTi&quot;: &quot;楷体&quot;,           &quot;FangSong&quot;: &quot;仿宋&quot;,           &quot;Arial&quot;: &quot;Arial&quot;,           &quot;Times New Roman&quot;: &quot;Times New Roman&quot;,           # 可以根据需要添加更多字体映射       &#125;   @staticmethod   def generate_word_from_data(clean_info: List[Dict[str, Any]], output_word_path: str) -&gt; None:       &quot;&quot;&quot;从清理后的PDF信息生成Word文档&quot;&quot;&quot;       doc = Document()       font_mapping = PDFProcessor.get_system_font_mapping()       # 收集所有字体大小用于分析       all_font_sizes = []       for page in clean_info:           for block in page[&quot;text_content&quot;]:               for line in block[&quot;lines&quot;]:                   for span in line[&quot;spans&quot;]:                       all_font_sizes.append(span[&quot;size&quot;])       # 分析最常见的字体大小作为正文字体       if all_font_sizes:           most_common_size = Counter(all_font_sizes).most_common(1)[0][0]           print(f&quot;分析得出正文字体大小: &#123;most_common_size&#125;&quot;)           title_font_threshold = most_common_size * 1.2  # 标题字体阈值       else:           most_common_size = 12  # 默认正文字体大小           title_font_threshold = 14  # 默认标题字体阈值       # 处理每一页内容       for page in clean_info:           # 为新页面添加分页符（第一页除外）           if page[&quot;page_number&quot;] &gt; 1:               doc.add_page_break()           # 添加页码           page_paragraph = doc.add_paragraph()           page_run = page_paragraph.add_run(f&quot;第 &#123;page[&#x27;page_number&#x27;]&#125; 页&quot;)           page_run.font.size = Pt(9)           page_paragraph.alignment = WD_ALIGN_PARAGRAPH.CENTER           # 收集页面上的所有元素（文本块和图片）并按位置排序           page_elements = []           # 添加文本块           for block in page[&quot;text_content&quot;]:               # 使用文本块的边界框顶部作为排序依据               block_top = block[&quot;bbox&quot;][1]               page_elements.append(&#123;                   &quot;type&quot;: &quot;text&quot;,                   &quot;top&quot;: block_top,                   &quot;data&quot;: block               &#125;)           # 添加图片           for img in page[&quot;images&quot;]:               # 使用图片的顶部位置作为排序依据               img_top = img[&quot;rect&quot;][1]               page_elements.append(&#123;                   &quot;type&quot;: &quot;image&quot;,                   &quot;top&quot;: img_top,                   &quot;data&quot;: img               &#125;)           # 按元素在页面中的垂直位置排序           page_elements.sort(key=lambda x: x[&quot;top&quot;])           # 处理排序后的元素           for element in page_elements:               if element[&quot;type&quot;] == &quot;text&quot;:                   PDFProcessor._add_text_block_to_doc(doc, element[&quot;data&quot;], font_mapping,                                                     title_font_threshold, most_common_size)               elif element[&quot;type&quot;] == &quot;image&quot;:                   PDFProcessor._add_image_to_doc(doc, element[&quot;data&quot;])       # 保存生成的Word文档       try:           # 确保输出目录存在           output_dir = os.path.dirname(output_word_path)           os.makedirs(output_dir, exist_ok=True)           doc.save(output_word_path)           print(f&quot;Word文档已保存至：&#123;output_word_path&#125;&quot;)       except Exception as e:           print(f&quot;保存Word文档失败：&#123;e&#125;&quot;)           raise   @staticmethod   def _add_text_block_to_doc(doc, text_block, font_mapping, title_threshold, normal_size):       &quot;&quot;&quot;将文本块添加到Word文档&quot;&quot;&quot;       for line in text_block[&quot;lines&quot;]:           paragraph = doc.add_paragraph()           for span in line[&quot;spans&quot;]:               run = paragraph.add_run(span[&quot;text&quot;])               # 设置字体               font_name = span[&quot;font&quot;]               # 映射到系统可用字体               mapped_font = font_mapping.get(font_name, font_name)               try:                   run.font.name = mapped_font                   # 设置中文字体                   run._element.rPr.rFonts.set(qn(&#x27;w:eastAsia&#x27;), mapped_font)               except Exception as e:                   print(f&quot;设置字体 &#123;mapped_font&#125; 失败: &#123;e&#125;&quot;)                   run.font.name = &quot;宋体&quot;                   run._element.rPr.rFonts.set(qn(&#x27;w:eastAsia&#x27;), &quot;宋体&quot;)               # 设置字体大小               try:                   run.font.size = Pt(span[&quot;size&quot;])               except:                   run.font.size = Pt(normal_size)               # 设置字体颜色（简化处理，仅使用黑白两色）               if span[&quot;color&quot;] in (0, 255):  # 黑色或白色                   run.font.color.rgb = None  # 使用默认颜色               else:                   # 转换PDF颜色值（整数）为RGB                   rgb = PDFProcessor._int_to_rgb(span[&quot;color&quot;])                   run.font.color.rgb = rgb           # 根据字体大小判断是否为标题           if line[&quot;spans&quot;]:               first_span_size = line[&quot;spans&quot;][0][&quot;size&quot;]               if first_span_size &gt;= title_threshold:                   paragraph.style = doc.styles[&quot;Heading 2&quot;]               else:                   paragraph.style = doc.styles[&quot;Normal&quot;]   @staticmethod   def _add_image_to_doc(doc, img_data):       &quot;&quot;&quot;将图片添加到Word文档&quot;&quot;&quot;       try:           if os.path.exists(img_data[&quot;path&quot;]):               # 计算图片在Word中的尺寸（英寸）               # 72像素 = 1英寸               width_in_inches = img_data[&quot;width&quot;] / 72               height_in_inches = img_data[&quot;height&quot;] / 72               # 限制最大宽度为6英寸，保持比例               if width_in_inches &gt; 6:                   ratio = 6 / width_in_inches                   width_in_inches = 6                   height_in_inches *= ratio               # 添加图片               paragraph = doc.add_paragraph()               run = paragraph.add_run()               run.add_picture(img_data[&quot;path&quot;], width=Inches(width_in_inches),                              height=Inches(height_in_inches))               paragraph.alignment = WD_ALIGN_PARAGRAPH.CENTER  # 图片居中对齐       except Exception as e:           print(f&quot;添加图片到文档失败: &#123;e&#125;&quot;)   @staticmethod   def _int_to_rgb(color_int: int) -&gt; Tuple[int, int, int]:       &quot;&quot;&quot;将整数颜色值转换为RGB tuple&quot;&quot;&quot;       blue = color_int &amp; 0xff       green = (color_int &gt;&gt; 8) &amp; 0xff       red = (color_int &gt;&gt; 16) &amp; 0xff       return (red, green, blue)class ProcessingThread(QThread):   &quot;&quot;&quot;处理PDF文件的工作线程&quot;&quot;&quot;   finished = pyqtSignal(bool, str, str)  # 处理完成信号 (成功, 原文件路径, 结果文件路径)   progress_updated = pyqtSignal(str)  # 进度更新信号   def __init__(self, pdf_path: str, output_path: str):       super().__init__()       self.pdf_path = pdf_path       self.output_path = output_path   def run(self):       try:           self.progress_updated.emit(f&quot;正在提取PDF内容: &#123;os.path.basename(self.pdf_path)&#125;&quot;)           # 提取PDF信息           pdf_info = PDFProcessor.extract_full_pdf_info(self.pdf_path)           self.progress_updated.emit(f&quot;正在去除水印: &#123;os.path.basename(self.pdf_path)&#125;&quot;)           # 去除水印           clean_info = PDFProcessor.remove_watermark_by_alpha(pdf_info)           self.progress_updated.emit(f&quot;正在生成Word文档: &#123;os.path.basename(self.output_path)&#125;&quot;)           # 生成Word文档           PDFProcessor.generate_word_from_data(clean_info, self.output_path)           self.finished.emit(True, self.pdf_path, self.output_path)       except Exception as e:           error_msg = f&quot;处理失败: &#123;str(e)&#125;&quot;           print(error_msg)           self.progress_updated.emit(error_msg)           self.finished.emit(False, self.pdf_path, str(e))class PdfWatermarkRemoverApp(QWidget):   &quot;&quot;&quot;PDF水印去除工具主界面&quot;&quot;&quot;   def __init__(self):       super().__init__()       self.processing_queue = []  # 待处理文件队列       self.processed_count = 0  # 已处理文件数       self.total_files_to_process = 0  # 总文件数       self.success_count = 0  # 处理成功数       self.failure_count = 0  # 处理失败数       self.failed_files = []  # 处理失败的文件列表       self.processing_mode = None  # &#x27;file&#x27; 或 &#x27;folder&#x27;       self.overwrite_all = None  # None:未设置, True:全部覆盖, False:全部跳过       self.init_ui()   def init_ui(self):       &quot;&quot;&quot;初始化用户界面&quot;&quot;&quot;       self.setWindowTitle(&quot;PDF水印去除工具&quot;)       self.setFixedSize(750, 400)       # 设置中文字体       font = QFont()       font.setFamily(&quot;SimHei&quot;)       self.setFont(font)       main_layout = QVBoxLayout()       main_layout.setSpacing(15)       main_layout.setContentsMargins(20, 20, 20, 20)       # 标题       title_label = QLabel(&quot;PDF水印去除与Word转换工具&quot;)       title_font = QFont()       title_font.setFamily(&quot;SimHei&quot;)       title_font.setPointSize(14)       title_font.setBold(True)       title_label.setFont(title_font)       title_label.setAlignment(Qt.AlignCenter)       main_layout.addWidget(title_label)       # 分隔线       line = QFrame()       line.setFrameShape(QFrame.HLine)       line.setFrameShadow(QFrame.Sunken)       main_layout.addWidget(line)       # 文件选择区域       file_selection_layout = QVBoxLayout()       # 选择文件按钮       self.browse_files_button = QPushButton(&quot;选择文件...&quot;)       self.browse_files_button.setFont(font)       self.browse_files_button.clicked.connect(self.browse_pdf_files)       file_selection_layout.addWidget(self.browse_files_button)       # 选择文件夹按钮       self.browse_folder_button = QPushButton(&quot;选择文件夹...&quot;)       self.browse_folder_button.setFont(font)       self.browse_folder_button.clicked.connect(self.browse_folder)       file_selection_layout.addWidget(self.browse_folder_button)       # 选中的文件/文件夹显示       self.selected_path_label = QLabel(&quot;未选择任何文件或文件夹&quot;)       self.selected_path_label.setFont(font)       self.selected_path_label.setWordWrap(True)       file_selection_layout.addWidget(self.selected_path_label)       main_layout.addLayout(file_selection_layout)       # 处理按钮       self.process_button = QPushButton(&quot;开始处理&quot;)       self.process_button.setFont(font)       self.process_button.setMinimumHeight(40)       self.process_button.clicked.connect(self.start_processing)       self.process_button.setEnabled(False)  # 初始禁用       main_layout.addWidget(self.process_button)       # 进度显示区域       progress_layout = QVBoxLayout()       self.status_label = QLabel(&quot;等待选择文件/文件夹...&quot;)       self.status_label.setFont(font)       progress_layout.addWidget(self.status_label)       self.current_file_status_label = QLabel(&quot;&quot;)       self.current_file_status_label.setFont(font)       self.current_file_status_label.setWordWrap(True)       progress_layout.addWidget(self.current_file_status_label)       self.progress_bar = QProgressBar()       self.progress_bar.setValue(0)       progress_layout.addWidget(self.progress_bar)       main_layout.addLayout(progress_layout)       # 覆盖选项（默认隐藏）       self.overwrite_layout = QHBoxLayout()       self.overwrite_label = QLabel(&quot;文件已存在，是否覆盖？&quot;)       self.overwrite_label.setFont(font)       self.overwrite_layout.addWidget(self.overwrite_label)       self.overwrite_button = QPushButton(&quot;覆盖&quot;)       self.overwrite_button.setFont(font)       self.overwrite_button.clicked.connect(lambda: self.handle_overwrite_choice(True))       self.overwrite_layout.addWidget(self.overwrite_button)       self.skip_button = QPushButton(&quot;跳过&quot;)       self.skip_button.setFont(font)       self.skip_button.clicked.connect(lambda: self.handle_overwrite_choice(False))       self.overwrite_layout.addWidget(self.skip_button)       self.overwrite_all_checkbox = QCheckBox(&quot;对当前批次的所有冲突文件执行此操作&quot;)       self.overwrite_all_checkbox.setFont(font)       self.overwrite_all_checkbox.setVisible(False)       self.overwrite_layout.addWidget(self.overwrite_all_checkbox)       main_layout.addLayout(self.overwrite_layout)       self.overwrite_layout.setVisible(False)  # 默认隐藏       # 状态统计区域       self.stats_label = QLabel(&quot;处理统计: 0 成功, 0 失败&quot;)       self.stats_label.setFont(font)       main_layout.addWidget(self.stats_label)       # 底部说明       note_label = QLabel(&quot;说明: 处理后的文件将保存至源文件所在目录的 &#x27;_无水印&#x27; 子文件夹中&quot;)       note_font = QFont()       note_font.setFamily(&quot;SimHei&quot;)       note_font.setPointSize(9)       note_label.setFont(note_font)       note_label.setAlignment(Qt.AlignRight)       main_layout.addWidget(note_label)       self.setLayout(main_layout)   def browse_pdf_files(self):       &quot;&quot;&quot;浏览并选择PDF文件&quot;&quot;&quot;       file_paths, _ = QFileDialog.getOpenFileNames(self, &quot;选择PDF文件&quot;, &quot;&quot;, &quot;PDF文件 (*.pdf)&quot;)       if file_paths:           self.processing_mode = &quot;file&quot;           self.processing_queue = list(file_paths)           self.total_files_to_process = len(self.processing_queue)           self.selected_path_label.setText(f&quot;已选择 &#123;self.total_files_to_process&#125; 个PDF文件&quot;)           self.process_button.setEnabled(True)           self.reset_processing_stats()   def browse_folder(self):       &quot;&quot;&quot;浏览并选择文件夹&quot;&quot;&quot;       folder_path = QFileDialog.getExistingDirectory(self, &quot;选择包含 PDF 文件的文件夹&quot;)       if folder_path:           self.processing_mode = &quot;folder&quot;           # 查找文件夹中的所有PDF文件           pdf_files = []           for root, _, files in os.walk(folder_path):               for file in files:                   if file.lower().endswith(&#x27;.pdf&#x27;):                       pdf_files.append(os.path.join(root, file))           self.processing_queue = pdf_files           self.total_files_to_process = len(self.processing_queue)           self.selected_path_label.setText(               f&quot;已选择文件夹: &#123;folder_path&#125;n包含 &#123;self.total_files_to_process&#125; 个PDF文件&quot;)           self.process_button.setEnabled(self.total_files_to_process &gt; 0)           self.reset_processing_stats()   def reset_processing_stats(self):       &quot;&quot;&quot;重置处理统计信息&quot;&quot;&quot;       self.processed_count = 0       self.success_count = 0       self.failure_count = 0       self.failed_files = []       self.progress_bar.setValue(0)       self.stats_label.setText(&quot;处理统计: 0 成功, 0 失败&quot;)       self.status_label.setText(&quot;就绪，点击开始处理&quot;)       self.current_file_status_label.setText(&quot;&quot;)       self.overwrite_all = None   def start_processing(self):       &quot;&quot;&quot;开始处理文件队列&quot;&quot;&quot;       if not self.processing_queue or self.total_files_to_process == 0:           QMessageBox.information(self, &quot;提示&quot;, &quot;没有可处理的文件&quot;)           return       self.process_button.setEnabled(False)       self.browse_files_button.setEnabled(False)       self.browse_folder_button.setEnabled(False)       self.process_next_file()   def process_next_file(self):       &quot;&quot;&quot;处理队列中的下一个文件&quot;&quot;&quot;       if not self.processing_queue:           self.on_all_processing_finished()           return       current_pdf_path = self.processing_queue.pop(0)       pdf_filename = os.path.basename(current_pdf_path)       pdf_dir = os.path.dirname(current_pdf_path)       # 创建输出目录       output_dir = os.path.join(pdf_dir, pdf_filename.replace(&#x27;.pdf&#x27;, &#x27;&#x27;) + &quot;_无水印&quot;)       os.makedirs(output_dir, exist_ok=True)       # 构建输出文件路径       output_filename = os.path.splitext(pdf_filename)[0] + &quot;_无水印.docx&quot;       output_word_path = os.path.join(output_dir, output_filename)       # 检查文件是否已存在       if os.path.exists(output_word_path):           # 如果已设置全局覆盖策略，则直接应用           if self.overwrite_all is not None:               if not self.overwrite_all:                   # 跳过此文件                   self.current_file_status_label.setText(f&quot;已跳过已存在文件: &#123;pdf_filename&#125;&quot;)                   self.processed_count += 1                   self.update_progress()                   QApplication.processEvents()  # 更新界面                   self.process_next_file()                   return           else:               # 显示覆盖选择对话框               self.current_file_path = current_pdf_path               self.current_output_path = output_word_path               self.status_label.setText(f&quot;文件已存在: &#123;pdf_filename&#125;&quot;)               self.current_file_status_label.setText(&quot;请选择处理方式&quot;)               self.overwrite_layout.setVisible(True)               self.overwrite_all_checkbox.setVisible(True)               return       # 启动处理线程       self.status_label.setText(f&quot;正在处理第 &#123;self.processed_count + 1&#125; / &#123;self.total_files_to_process&#125; 个文件...&quot;)       self.current_file_status_label.setText(f&quot;正在处理: &#123;pdf_filename&#125;&quot;)       self.processing_thread = ProcessingThread(current_pdf_path, output_word_path)       self.processing_thread.finished.connect(self.on_file_processed)       self.processing_thread.progress_updated.connect(self.current_file_status_label.setText)       self.processing_thread.start()   def handle_overwrite_choice(self, overwrite: bool):       &quot;&quot;&quot;处理文件覆盖选择&quot;&quot;&quot;       self.overwrite_layout.setVisible(False)       # 检查是否需要应用到所有文件       if self.overwrite_all_checkbox.isChecked():           self.overwrite_all = overwrite       if overwrite:           # 继续处理当前文件，覆盖已存在文件           self.processing_thread = ProcessingThread(self.current_file_path, self.current_output_path)           self.processing_thread.finished.connect(self.on_file_processed)           self.processing_thread.progress_updated.connect(self.current_file_status_label.setText)           self.processing_thread.start()       else:           # 跳过当前文件           self.current_file_status_label.setText(f&quot;已跳过已存在文件: &#123;os.path.basename(self.current_file_path)&#125;&quot;)           self.processed_count += 1           self.update_progress()           self.process_next_file()   def on_file_processed(self, success: bool, file_path: str, result: str):       &quot;&quot;&quot;文件处理完成回调&quot;&quot;&quot;       filename = os.path.basename(file_path)       if success:           self.success_count += 1           self.current_file_status_label.setText(f&quot;处理成功: &#123;filename&#125; -&gt; &#123;os.path.basename(result)&#125;&quot;)       else:           self.failure_count += 1           self.failed_files.append(f&quot;&#123;filename&#125;: &#123;result&#125;&quot;)           self.current_file_status_label.setText(f&quot;处理失败: &#123;filename&#125; - &#123;result&#125;&quot;)       self.processed_count += 1       self.update_progress()       self.process_next_file()   def update_progress(self):       &quot;&quot;&quot;更新进度显示&quot;&quot;&quot;       progress_percentage = int((self.processed_count / self.total_files_to_process) * 100)       self.progress_bar.setValue(progress_percentage)       self.stats_label.setText(f&quot;处理统计: &#123;self.success_count&#125; 成功, &#123;self.failure_count&#125; 失败&quot;)   def on_all_processing_finished(self):       &quot;&quot;&quot;所有文件处理完成&quot;&quot;&quot;       self.status_label.setText(&quot;所有文件处理完成!&quot;)       self.current_file_status_label.setText(&quot;&quot;)       # 显示处理结果摘要       result_msg = f&quot;处理完成！共处理 &#123;self.total_files_to_process&#125; 个文件n&quot;       result_msg += f&quot;成功: &#123;self.success_count&#125; 个n&quot;       result_msg += f&quot;失败: &#123;self.failure_count&#125; 个&quot;       if self.failed_files:           result_msg += &quot;nn处理失败的文件：n&quot; + &quot;n&quot;.join(self.failed_files)       QMessageBox.information(self, &quot;处理完成&quot;, result_msg)       # 重置界面状态       self.process_button.setEnabled(True)       self.browse_files_button.setEnabled(True)       self.browse_folder_button.setEnabled(False)       self.overwrite_all = None       self.overwrite_all_checkbox.setChecked(False)if __name__ == &quot;__main__&quot;:   # 确保中文正常显示   import matplotlib   matplotlib.rcParams[&quot;font.family&quot;] = [&quot;SimHei&quot;, &quot;WenQuanYi Micro Hei&quot;, &quot;Heiti TC&quot;]   app = QApplication(sys.argv)   window = PdfWatermarkRemoverApp()   window.show()   sys.exit(app.exec_())\n\n以上代码实现了一个功能完整的 PDF 水印去除工具，包含了从 PDF 内容提取、水印识别与去除到 Word 文档生成的全流程。工具支持单个文件处理和文件夹批量处理，提供了友好的图形界面和详细的处理状态反馈。你可以直接使用这段代码，也可以根据实际需求进行进一步的定制和优化。\nPS:代码仅供参考，内容不一定正确，要根据实际情况处理喵\n","categories":["-Python -PDF -Word"],"tags":["Python","PyMuPDF","水印去除","PDF处理","PyQt5","Word"]},{"title":"从零开始的爬虫生活（一）：环境搭建与基础库应用","url":"/2025/07/15/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84%E7%88%AC%E8%99%AB%E7%94%9F%E6%B4%BB%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E5%9F%BA%E7%A1%80%E5%BA%93%E5%BA%94%E7%94%A8/","content":"一、环境搭建\n在开始学习爬虫之前，我们需要先搭建好开发环境。以下是一些常用的工具和库：\n1. Python 环境&#xA;确保已经安装了 Python 3.x 版本。可以前往 Python 官网 下载安装。\n2. 常用库安装&#xA;使用 pip 命令安装以下库：\npip install seleniumpip install beautifulsoup4pip install pyquerypip install pymysqlpip install pymongopip install redis\n\n3. 浏览器驱动&#xA;\nChromeDriver：根据你使用的 Chrome 浏览器版本，下载对应的 ChromeDriver。\n\nPhantomJS（已弃用）：在 Selenium 4.x 中已移除，建议使用无头模式的 Chrome。\n\n\n配置 Chrome 无头模式示例：\nfrom selenium import webdriverfrom selenium.webdriver.chrome.options import Options# 配置 Chrome 为无头模式chrome_options = Options()chrome_options.add_argument(&quot;--headless&quot;)  # 无头模式，不显示浏览器窗口# 创建 Chrome 浏览器实例driver = webdriver.Chrome(options=chrome_options)driver.get(&quot;https://www.example.com&quot;)print(driver.title)driver.quit()\n\n二、基础库应用\n1. BeautifulSoup 库&#xA;BeautifulSoup 是一个用于解析 HTML 和 XML 文档的库。示例：\nfrom bs4 import BeautifulSouphtml_doc = &quot;&quot;&quot;&lt;html&gt;    &lt;head&gt;        &lt;title&gt;示例页面&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;h1&gt;标题&lt;/h1&gt;        &lt;p&gt;段落内容&lt;/p&gt;    &lt;/body&gt;&lt;/html&gt;&quot;&quot;&quot;soup = BeautifulSoup(html_doc, &#x27;html.parser&#x27;)print(soup.title.string)  # 输出标题内容&quot;&quot;&quot;soup = BeautifulSoup(html_doc, &#x27;html.parser&#x27;)print(soup.title.string)  # 输出标题内容\n\n2. PyQuery 库&#xA;PyQuery 是一个类 jQuery 的 Python 库，用于操作 HTML 文档。示例：\nfrom pyquery import PyQuery as pqhtml_doc = &quot;&quot;&quot;&lt;html&gt;    &lt;head&gt;        &lt;title&gt;示例页面&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;h1&gt;标题&lt;/h1&gt;        &lt;p&gt;段落内容&lt;/p&gt;    &lt;/body&gt;&lt;/html&gt;&quot;&quot;&quot;doc = pq(html_doc)print(doc(&#x27;title&#x27;).text())  # 输出标题内容\n\n3. Requests 库&#xA;Requests 是一个简单的 HTTP 库，用于发送网络请求。示例：\nimport requestsurl = &quot;https://www.example.com&quot;response = requests.get(url)print(response.text)  # 输出网页内容\n\n三、数据存储\n1. MySQL 数据库&#xA;使用 PyMySQL 连接和操作 MySQL 数据库：\nimport pymysqlconn = pymysql.connect(    host=&#x27;localhost&#x27;,    user=&#x27;root&#x27;,    password=&#x27;123456&#x27;,    port=3306,    db=&#x27;mysql&#x27;)cursor = conn.cursor()cursor.execute(&#x27;SELECT * FROM db&#x27;)print(cursor.fetchone())conn.close()\n\n2. MongoDB 数据库&#xA;使用 PyMongo 连接和操作 MongoDB 数据库：\nimport pymongoclient = pymongo.MongoClient(&#x27;localhost&#x27;)db = client[&#x27;newtestdb&#x27;]db[&#x27;table&#x27;].insert_one(&#123;&#x27;name&#x27;: &#x27;Bob&#x27;&#125;)result = db[&#x27;table&#x27;].find_one(&#123;&#x27;name&#x27;: &#x27;Bob&#x27;&#125;)print(result)\n\n3. Redis 数据库&#xA;使用 RedisPy 连接和操作 Redis 数据库：\nimport redisr = redis.Redis(&#x27;localhost&#x27;, 6379)r.set(&#x27;name&#x27;, &#x27;Bob&#x27;)result = r.get(&#x27;name&#x27;)print(result)\n\n四、爬虫基本流程\n爬虫的基本流程如下：\n\n发送请求：使用 Requests 库发送 HTTP 请求获取网页内容。\n\n解析响应：使用 BeautifulSoup 或 PyQuery 库解析网页内容，提取所需数据。\n\n保存数据：将提取的数据存储到数据库或文件中。\n\n\n示例：爬取猫眼电影 TOP100\nimport requestsimport reimport jsonfrom multiprocessing import Pooldef get_one_page(url):    headers = &#123;        &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/137.0.0.0 Safari/537.36 Edg/137.0.0.0&#x27;    &#125;    response = requests.get(url, headers=headers)    if response.status_code == 200:        return response.text    return Nonedef parse_one_page(html):    pattern = re.compile(&#x27;&lt;dd&gt;.*?board-index.*?&gt;(d+)&lt;/i&gt;.*?data-src=&quot;(.*?)&quot;.*?name&quot;&gt;&lt;a&#x27;                         + &#x27;.*?&gt;(.*?)&lt;/a&gt;.*?star&quot;&gt;(.*?)&lt;/p&gt;.*?releasetime&quot;&gt;(.*?)&lt;/p&gt;&#x27;                         + &#x27;.*?integer&quot;&gt;(.*?)&lt;/i&gt;.*?fraction&quot;&gt;(.*?)&lt;/i&gt;.*?&lt;/dd&gt;&#x27;, re.S)    items = re.findall(pattern, html)    for item in items:        yield &#123;            &#x27;index&#x27;: item[0],            &#x27;image&#x27;: item[1],            &#x27;title&#x27;: item[2],            &#x27;actor&#x27;: item[3].strip()[3:],            &#x27;time&#x27;: item[4].strip()[5:],            &#x27;score&#x27;: item[5] + item[6]        &#125;def write_to_file(content):    with open(&#x27;result.txt&#x27;, &#x27;a&#x27;, encoding=&#x27;utf-8&#x27;) as f:        f.write(json.dumps(content, ensure_ascii=False) + &#x27;n&#x27;)def main(offset):    url = &#x27;http://maoyan.com/board/4?offset=&#x27; + str(offset)    html = get_one_page(url)    for item in parse_one_page(html):        print(item)        write_to_file(item)if __name__ == &#x27;__main__&#x27;:    pool = Pool()    pool.map(main, [i * 10 for i in range(10)])\n\n五、动态网页处理\n对于动态加载的网页，可以使用 Selenium 模拟浏览器操作。示例：\nfrom selenium import webdriverfrom selenium.webdriver.common.by import Bydriver = webdriver.Chrome()driver.get(&#x27;https://www.taobao.com&#x27;)input = driver.find_element(By.ID, &#x27;q&#x27;)input.send_keys(&#x27;美食&#x27;)button = driver.find_element(By.CLASS_NAME, &#x27;btn-search&#x27;)button.click()driver.quit()\n\n六、爬虫框架\n1. Scrapy 框架&#xA;Scrapy 是一个强大的爬虫框架，可以简化爬虫开发过程。安装命令：\npip install scrapy\n\n未完待续……\nPS:代码仅供参考，内容不一定正确，要根据实际情况处理喵\n","categories":["爬虫教程"],"tags":["Python爬虫","数据抓取","Selenium","BeautifulSoup","数据存储"]}]