[{"title":"Dify镜像源替换与服务启动","url":"/2025/07/15/Dify-%E9%83%A8%E7%BD%B2%E6%B5%81%E7%A8%8B%EF%BC%9A%E9%95%9C%E5%83%8F%E6%BA%90%E6%9B%BF%E6%8D%A2%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%90%AF%E5%8A%A8/","content":"一、Dify 镜像源替换操作\n批量替换镜像前缀&#xA;在 docker-compose.yaml 所在目录执行全局替换，添加 docker.1ms.run&#x2F; 前缀：\nsed -i &#x27;s/image: /image: docker.1ms.run\\\\//g&#x27; docker-compose.yaml\n\n特殊镜像路径修正&#xA;问题路径&#xA;image: docker.1ms.run/docker.elastic.co/elasticsearch/elasticsearch:8.14.3\n\n修正命令&#xA;sed -i &#x27;s|docker.1ms.run/docker.elastic.co/|docker.1ms.run/elastic/|g&#x27; docker-compose.yaml\n\n正确路径&#xA;image: docker.1ms.run/elastic/elasticsearch:8.14.3\n\n基础镜像补充替换&#xA;sed -i &#x27;s|image: postgres:|image: docker.1ms.run/postgres:|g&#x27; docker-compose.yamlsed -i &#x27;s|image: redis:|image: docker.1ms.run/redis:|g&#x27; docker-compose.yamlsed -i &#x27;s|image: nginx:|image: docker.1ms.run/nginx:|g&#x27; docker-compose.yaml\n\n二、部署前准备工作\n赋予挂载目录权限：\nchmod -R 777 ./volumes ./elasticsearch\n\n三、启动与验证 Dify 服务\n后台启动服务&#xA;docker-compose up -d\n\n验证服务状态&#xA;docker-compose ps  # 检查容器运行状态docker-compose logs -f  # 查看实时日志\n\n访问 Dify 界面&#xA;浏览器输入 http:&#x2F;&#x2F; 服务器 IP:3000，默认账号 admin@example.com，密码 password。\n四、部署过程常见问题\n镜像路径嵌套错误&#xA;问题&#xA;镜像路径包含 docker.1ms.run&#x2F;docker.elastic.co&#x2F; 嵌套结构。\n解决&#xA;使用 sed 精准替换：\nsed -i &#x27;s|docker.1ms.run/docker.elastic.co/|docker.1ms.run/elastic/|g&#x27; docker-compose.yaml\n\n权限不足导致启动失败&#xA;问题&#xA;挂载目录无读写权限。\n解决&#xA;递归设置目录权限：\nchmod -R 777 ./volumes\n服务启动异常&#xA;解决&#xA;通过日志排查问题：&#x20;\ndocker-compose logs -f  # 查看所有服务日志docker-compose logs dify-api  # 查看指定服务日志\n\n五、核心操作总结\n镜像替换流程&#xA;全局前缀替换 → 特殊镜像路径修正 → 基础镜像补充替换\n启动验证流程&#xA;docker-compose up -d → docker-compose ps → 访问 Web 界面\n关键命令&#xA;sed -i &#x27;s/image: /image: docker.1ms.run\\\\//g&#x27; docker-compose.yamlchmod -R 777 ./volumesdocker-compose up -d\n\nPS:代码仅供参考，内容不一定正确，要根据实际情况处理喵\n","categories":["Dify"],"tags":["Dify","镜像源"]},{"title":"Portainer容器管理实战：从镜像加速到安全部署","url":"/2025/07/15/Portainer%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86%E5%AE%9E%E6%88%98%EF%BC%9A%E4%BB%8E%E9%95%9C%E5%83%8F%E5%8A%A0%E9%80%9F%E5%88%B0%E5%AE%89%E5%85%A8%E9%83%A8%E7%BD%B2/","content":"一、背景：为什么选择从第三方镜像源拉取 Portainer？\n近期在学习容器管理工具 Portainer 时，参考了一篇技术教程（知乎链接：https://zhuanlan.zhihu.com&#x2F;p&#x2F;27740131259），教程中推荐使用官方镜像源部署。但由于网络环境限制，尝试从第三方镜像源docker.1ms.run拉取 Portainer 镜像，意外发现该镜像源提供了更稳定的下载速度，因此记录下完整操作流程，供遇到类似问题的开发者参考。\n二、操作步骤：从镜像拉取到容器启动的全流程\n1. 拉取 Portainer 镜像&#xA;通常情况下，Portainer 官方镜像的拉取命令为：\ndocker pull portainer/portainer-ce:latest\n\n但本次尝试使用第三方镜像源：\ndocker pull docker.1ms.run/portainer/portainer-ce:latest\n\n\n注意事项：\n\n第三方镜像源可能存在安全风险，建议优先使用官方镜像（portainer/portainer-ce）。\n若拉取失败，可检查镜像源是否可用（如执行ping docker.1ms.run），或切换至国内加速源（如 Docker 中国镜像站）。\n\n2. 验证镜像是否成功拉取&#xA;通过docker images命令查看本地镜像列表：\ndocker images\n3. 启动 Portainer 容器&#xA;使用以下命令启动容器，并配置挂载与端口映射：\ndocker run -d \\  --name portainer \\  -p 9000:9000 \\  -v /var/run/docker.sock:/var/run/docker.sock \\  -v portainer_data:/data \\  --restart=always \\  docker.1ms.run/portainer/portainer-ce:latest\n参数解析：\n\n-d：后台运行容器；\n\n-p 9000:9000：映射宿主机 9000 端口到容器 9000 端口，用于访问 Web 界面；\n\n-v /var/run/docker.sock:/var/run/docker.sock：挂载 Docker 套接字，允许 Portainer 管理宿主机 Docker 环境；\n\n-v portainer_data:/data：创建数据卷持久化存储 Portainer 配置；\n\n--restart=always：确保容器随系统重启自动运行。\n\n\n4. 访问 Portainer Web 界面&#xA;容器启动后，在浏览器中输入http://宿主机IP:9000，首次访问需设置管理员密码，随后进入 Portainer 管理界面。\n三、遇到的问题与解决方案\n1. 镜像拉取失败：manifest unknown&#xA;错误信息：\nError response from daemon: manifest for docker.1ms.run/portainer-ce:latest not found: manifest unknown\n\n原因：\n镜像源中无该镜像，或镜像名称拼写错误（如portainer-ce写成portainer）。\n解决方法：\n确认镜像名称正确性，或更换为官方镜像源拉取：\ndocker pull portainer/portainer-ce:latest\n\n2. Docker Hub 连接超时&#xA;错误信息：\nError response from daemon: Get &quot;https://registry-1.docker.io/v2/&quot;: context deadline exceeded\n\n解决方法：\n配置国内镜像加速源，编辑/etc/docker/daemon.json添加：\n&#123;  &quot;registry-mirrors&quot;: [&quot;https://registry.docker-cn.com&quot;, &quot;https://docker.mirrors.ustc.edu.cn&quot;]&#125;\n\n重启 Docker 服务：sudo systemctl restart docker。\n四、使用第三方镜像源的风险与建议\n\n安全风险：第三方镜像源可能被篡改，建议优先使用官方镜像（portainer/portainer-ce）。\n\n版本兼容性：第三方镜像可能非最新版本，建议定期通过docker pull更新镜像。\n\n网络稳定性：若第三方源频繁失效，优先使用官方源或国内大厂加速源（如阿里云、腾讯云镜像站）。\n\n\n五、总结：Portainer 的价值与容器管理实践\n通过 Docker 部署 Portainer 后，可直观管理容器、镜像、网络及数据卷，尤其适合新手快速上手容器化部署。本次从第三方镜像源拉取的经历表明：技术实践中需在效率与安全性间权衡，建议在测试环境尝试非官方源，生产环境务必使用官方可信镜像。\n后续可进一步探索 Portainer 的 Kubernetes 管理、RBAC 权限控制等高级功能，提升容器化应用的部署与运维效率。\nPS:代码仅供参考，内容不一定正确，要根据实际情况处理喵\n","categories":["Docker实践"],"tags":["Docker","Portainer","镜像加速","容器管理"]},{"title":"Python 魔法：一键让 Excel 正确选项「脸红」","url":"/2025/07/15/Python-%E9%AD%94%E6%B3%95%EF%BC%9A%E4%B8%80%E9%94%AE%E8%AE%A9-Excel-%E6%AD%A3%E7%A1%AE%E9%80%89%E9%A1%B9%E3%80%8C%E8%84%B8%E7%BA%A2%E3%80%8D/","content":"在数据处理工作中，我们经常需要处理 Excel 文件中的试题数据，特别是需要对正确答案进行特殊标记。本文将分享我从最初实现到最终优化的完整改进过程。\n初始需求\n我们需要处理一个包含试题的 Excel 文件，具体要求：\n\n文件包含 “试题选项” 和 “试题答案” 两列\n\n试题选项用 “$;$” 分隔多个选项\n\n需要根据 “试题答案” 将正确答案标记为红色\n\n处理后的结果直接修改原文件\n\n\n第一版实现\n核心思路：&#xA;\n使用 pandas 读取 Excel 文件\n\n用 openpyxl 修改原文件样式\n\n在正确答案前后添加 “**” 标记\n\n提示用户手动替换 “**” 为红色格式\n\n\n# 主要处理逻辑marked_options = []for i, option in enumerate(options):    if i in correct_indices:        marked_options.append(f&quot;**&#123;option&#125;**&quot;)  # 用**标记正确答案    else:        marked_options.append(option)cell.value = &#x27;$;$&#x27;.join(marked_options)\n\n问题：\n不能自动设置红色，需要用户手动替换，** 的标记方式不够直观\n第二版改进\n改进点：&#xA;\n改用 xlsxwriter 引擎\n\n直接处理 ** 标记的内容并设置为红色\n\n保留 ** 标记\n\n\n# 使用正则匹配**内容并设置格式for match in re.finditer(r&#x27;\\*\\*(.*?)\\*\\*&#x27;, cell_value):    parts.append(&#123;        &#x27;text&#x27;: f&quot;**&#123;match.group(1)&#125;**&quot;,        &#x27;format&#x27;: red_format    &#125;)\n问题：\n使用 ** 将正确答案括起来的话，xlsxwriter 无法非常准确地解析出来，因为答案可能是 A$;$B$;$C$;$D 这样子的，相同的符号会干扰它的判断，从而导致效果不好\n最终版改进\n改进思路：&#xA;\n改回使用 openpyxl\n\n正确答案用 [] 标记\n\n非正确答案不做标记\n\n\nmarked_options = []for i, option in enumerate(options):    if i in correct_indices:        marked_options.append(f&quot;[&#123;option&#125;]&quot;)  # 正确答案标记    else:        marked_options.append(option)\n\n然后再进行标红处理：\n\n使用富文本 (CellRichText) 直接设置红色\n\n自动移除 [] 标记\n\n添加异常处理，失败时回退到普通文本\n\n更友好的提示信息\n\n\nrich_text = CellRichText()for i, option in enumerate(options):    if i &gt; 0:        rich_text.append(&#x27;$;$&#x27;)    clean_option = option.replace(&#x27;[&#x27;, &#x27;&#x27;).replace(&#x27;]&#x27;, &#x27;&#x27;)    if i in correct_indices:        rich_text.append(TextBlock(inline_red_font, clean_option))    else:        rich_text.append(clean_option)cell.value = rich_text\n\n关键改进点：&#xA;\n富文本支持：使用 CellRichText 和 TextBlock 实现对单个字符的样式设置\n\n自动清理：移除选项中的 [] 标记\n\n\n拓展功能：标记检查与统一分隔符\n在最终版的基础上，我进一步完善了代码，增加了两项重要的功能：统一处理非标准分隔符和全面的标记检查报告。这使得整个流程更加健壮和智能化。\n1. 统一分隔符&#xA;很多时候，Excel 中的选项分隔符可能不统一，除了标准的$;$，还可能出现$;、$$等，甚至单空格加 $ 等多种形式。为了确保选项能够被正确解析，我加入了强大的正则表达式来识别并统一这些非标准分隔符为 $;$。\n实现方式：使用 re.compile 定义了一个详细的正则表达式 separator_pattern，涵盖了多种常见的非标准分隔符。\n效果：在处理每个选项字符串时，首先使用 separator_pattern.sub (‘$;$’, options_str) 将所有识别到的非标准分隔符统一替换为 $;$ 。这大大提高了数据处理的鲁棒性，减少了因格式不一致导致的问题。\n# 正则表达式定义separator_pattern = re.compile(r&#x27;&#x27;&#x27;    \\$;\\$|       # 标准 $;$    \\$[:：]\\$|   # $:$ 或 $：$    ;\\$|         # ;$    \\$；|        # $；    [；:：]\\$|   # ；$ 或 ：$    \\$[;；:：]|  # $; 或 $；或 $: 或 $：    \\$\\$|        # $$    \\s&#123;2,&#125;|      # 两个或更多空格    \\$\\s|\\s\\$|   # $ 后或前有单个空格    ;           # 单独的分号&#x27;&#x27;&#x27;, re.VERBOSE)# 替换处理modified_str = separator_pattern.sub(&#x27;$;$&#x27;, options_str)\n\n2. 标记检查报告&#xA;仅仅对正确答案进行标记是不够的，我们还需要验证标记是否正确、是否有遗漏。此功能可以生成详细的报告，指出 “正确答案未被标记” 和 “错误答案被标记” 的情况。\n核心逻辑优化：&#xA;\n未标记检查：传统的检查方法是看 “标记索引” 中是否包含正确答案的索引。但如果正确答案完全没有被标记（即选项中根本没有 []），这种方法就无法识别。新的逻辑直接检查正确答案的选项内容是否被 [] 包裹 。只要正确答案未被 [] 包裹，无论是否有其他标记动作，都会被识别为 “未标记” 。\n\n错误标记检查：检查所有被 [] 包裹的选项，如果其索引不在正确答案的索引列表中，则视为错误标记 。\n\n\n输出报告：&#xA;生成清晰的报告，包含：\n\n检查的总行数 。\n\n“未标记正确答案的行” 数量及具体详情（Excel 行号、应标记的字母、未被包裹的实际内容） 。\n\n“错误标记的行” 数量及具体详情（Excel 行号、错误标记的内容、正确的答案） 。\n\n\n#未标记检查代码：has_unmarked = Falsefor i in correct_indices:    opt = options[i]    if not (opt.strip().startswith(&#x27;[&#x27;) and opt.strip().endswith(&#x27;]&#x27;)):        has_unmarked = True        breakif has_unmarked:    unmarked_rows.append(&#123;        &#x27;row&#x27;: row_num,        &#x27;expected&#x27;: [chr(65 + i) for i in correct_indices],        &#x27;actual&#x27;: [options[i].strip() for i in correct_indices]    &#125;)#错误标记检查代码：marked_indices = []for i, opt in enumerate(options):    if opt.strip().startswith(&#x27;[&#x27;) and opt.strip().endswith(&#x27;]&#x27;):        marked_indices.append(i)for i in marked_indices:    if i not in correct_indices:        wrong_marking.append(&#123;            &#x27;row&#x27;: row_num,            &#x27;wrong_marked&#x27;: options[i].strip(),            &#x27;correct&#x27;: [chr(65 + i) for i in correct_indices]        &#125;)        break\n\n验证示例：&#xA;如果一个 Excel 行的正确答案是 D，但选项 D 没有被 [] 包裹，运行代码后会输出：\n=== 标记检查报告 ===共检查 1000 行数据1. 未标记正确答案的行: 1 行    行X: 应标记[&#x27;D&#x27;]（内容：D、xxxxxxxx）未被[]包裹2. 错误标记的行: 0 行\n\n这使得我们能够精准识别 “应该标记但完全没标记” 的情况 。\nPS:代码仅供参考，内容不一定正确，要根据实际情况处理喵\n","categories":["Excel","Python","数据处理"],"tags":["Excel","Pandas","Python","Openpyxl","Xlsxwriter","正则表达式"]},{"title":"Python 魔法：一键让 Excel 正确选项「脸红」","url":"/2025/07/15/Python%E9%AD%94%E6%B3%95%EF%BC%9A%E5%A6%82%E4%BD%95%E7%94%A8%E7%89%B9%E5%BE%81%E8%AF%86%E5%88%AB%E8%AE%A9PDF%E6%B0%B4%E5%8D%B0%E9%9A%90%E5%BD%A2%EF%BC%9F/","content":"在日常工作中，我们经常会遇到带有特定特征的 PDF 水印，比如固定的字体大小、倾斜角度、透明度和颜色。这些特性为我们提供了更精准地识别水印的依据。今天，我们就来深入探讨如何利用 PyMuPDF (Fitz) 库，基于这些特征实现 PDF 水印的精确识别和去除，并整合多种实用方法，帮你应对不同场景。\n特定特征水印的识别原理\nPDF 文件中的文本和图形对象都包含了丰富的元数据信息，例如字体大小、旋转角度、透明度和颜色。当水印具有固定特征时，我们可以通过以下步骤实现精准识别：\n\n解析 PDF 页面内容： 获取页面上所有的文本和图形对象。\n\n提取对象特征： 获取每个对象的字体大小、旋转角度、透明度和颜色等信息。\n\n特征匹配： 将提取到的特征与我们已知的水印特征进行比对。\n\n处理匹配对象： 对符合水印特征的对象进行删除或覆盖处理。\n\n\n典型的 PDF 水印通常具备以下特征：\n\n📐 固定倾斜角度 (常见 15-45 度)\n\n🎨 固定颜色 (常见浅灰色 #C0C0C0)\n\n🌫 固定透明度 (约 30-50%)\n\n🔠 固定字体大小 (通常较大)\n\n🔄 重复出现在每一页相同位置\n\n\n使用 PyMuPDF 实现基于特征的水印处理\n方法一：基于字体大小和旋转角度的水印识别&#xA;这个方法非常适合那些字体大小和倾斜角度都比较固定的水印。\nimport fitzimport mathdef remove_watermark_by_font_size_and_rotation(input_pdf, output_pdf, font_size, rotation_angle):    doc = fitz.open(input_pdf)    for page in doc:        text_infos = page.get_text(&quot;dict&quot;)        for block in text_infos[&quot;blocks&quot;]:            if &quot;lines&quot; in block:                for line in block[&quot;lines&quot;]:                    for span in line[&quot;spans&quot;]:                        current_size = span[&quot;size&quot;]                        matrix = fitz.Matrix(span[&quot;matrix&quot;])                        current_rotation = math.degrees(math.atan2(matrix.b, matrix.a))                        if (abs(current_size - font_size) &lt; 1.5 and                             abs(current_rotation - rotation_angle) &lt; 5.0):                            page.add_redact_annot(fitz.Rect(span[&quot;bbox&quot;]), text=&quot;&quot;)        page.apply_redactions()    doc.save(output_pdf)    doc.close()\n\n代码解析：\n\n我们使用 page.get_text(&quot;dict&quot;) 获取页面上所有的文本信息，包括它们的各种属性。\n\n从文本跨度 (span) 中提取 字体大小 和 变换矩阵。\n\n通过分解变换矩阵来计算文本的 旋转角度。这里使用了 math.atan2(matrix.b, matrix.a) 来更准确地获取旋转角度。\n\n将提取到的特征与你已知的水印特征进行比较，如果匹配（并允许一定的误差范围），就用一个空白矩形覆盖水印区域。\n\n\n难易度：★★★☆☆\n优点： 对具有固定字体大小和倾斜角度的水印效果特别好，误判率低。\n缺点： 需要你预先知道水印的字体大小和旋转角度参数。\n方法二：基于透明度和颜色的水印识别&#xA;这种方法适用于那些有固定透明度和颜色的水印，特别是半透明的浅色水印。\nimport fitzdef remove_watermark_by_opacity_and_color(input_pdf, output_pdf, opacity_threshold, color_rgb_target, color_tolerance=10):    doc = fitz.open(input_pdf)    for page in doc:        text_infos = page.get_text(&quot;dict&quot;)        for block in text_infos[&quot;blocks&quot;]:            if &quot;lines&quot; in block:                for line in block[&quot;lines&quot;]:                    for span in line[&quot;spans&quot;]:                        color_int = span[&quot;color&quot;]                        r = (color_int &gt;&gt; 16) &amp; 0xFF                        g = (color_int &gt;&gt; 8) &amp; 0xFF                        b = color_int &amp; 0xFF                        current_color_rgb = (r, g, b)                        color_match = (                            abs(current_color_rgb[0] - color_rgb_target[0]) &lt;= color_tolerance and                            abs(current_color_rgb[1] - color_rgb_target[1]) &lt;= color_tolerance and                            abs(current_color_rgb[2] - color_rgb_target[2]) &lt;= color_tolerance                        )                        if color_match:                            page.add_redact_annot(fitz.Rect(span[&quot;bbox&quot;]), text=&quot;&quot;)        page.apply_redactions()    doc.save(output_pdf)    doc.close()\n\n代码解析：\n\n我们从文本跨度中提取 RGB 颜色值。\n\n注意： 直接从 span 中提取透明度信息在 PyMuPDF 中比较复杂，因为它通常是 PDF 内容流中的图形状态参数。为了实现真正的透明度识别，你可能需要渲染页面为图像后分析像素的 alpha 通道，或者进行更复杂的 PDF 内容流解析。在上面的代码中，我暂时移除了透明度的判断，主要依赖颜色匹配。\n\n比较提取的颜色与已知水印特征，并设置一个容差范围。\n\n\n难易度：★★★★☆\n优点： 对具有固定颜色（特别是浅色）的水印效果好。\n缺点： 透明度提取是难点，可能需要深入解析 PDF 内部结构或借助图像处理库。\n方法三：综合多特征的水印识别&#xA;当水印特征明确且固定时，这个方法能提供最高的识别准确性，因为它结合了多种特征进行判断。\nimport fitzimport mathdef remove_watermark_by_multiple_features(input_pdf, output_pdf,                                        font_size, rotation_angle,                                        color_rgb,                                        size_tolerance=1.5, rotation_tolerance=5.0, color_tolerance=10):    doc = fitz.open(input_pdf)    for page in doc:        text_infos = page.get_text(&quot;dict&quot;)        for block in text_infos[&quot;blocks&quot;]:            if &quot;lines&quot; in block:                for line in block[&quot;lines&quot;]:                    for span in line[&quot;spans&quot;]:                        current_size = span[&quot;size&quot;]                        matrix = fitz.Matrix(span[&quot;matrix&quot;])                        current_rotation = math.degrees(math.atan2(matrix.b, matrix.a))                        color_int = span[&quot;color&quot;]                        r = (color_int &gt;&gt; 16) &amp; 0xFF                        g = (color_int &gt;&gt; 8) &amp; 0xFF                        b = color_int &amp; 0xFF                        current_color_rgb = (r, g, b)                        size_match = abs(current_size - font_size) &lt; size_tolerance                        rotation_match = abs(current_rotation - rotation_angle) &lt; rotation_tolerance                        color_match = (                            abs(current_color_rgb[0] - color_rgb[0]) &lt;= color_tolerance and                            abs(current_color_rgb[1] - color_rgb[1]) &lt;= color_tolerance and                            abs(current_color_rgb[2] - color_rgb[2]) &lt;= color_tolerance                        )                        if size_match and rotation_match and color_match:                            page.add_redact_annot(fitz.Rect(span[&quot;bbox&quot;]), text=&quot;&quot;)        page.apply_redactions()    doc.save(output_pdf)    doc.close()\n\n代码解析：\n\n综合提取字体大小、旋转角度和颜色三个特征（为了简化和实用性，移除了直接在 span 中获取的透明度判断）。\n\n设置了合理的匹配容差范围，你可以根据实际情况调整这些容差值。\n\n只有当所有选定的特征都匹配时才判定为水印，这大大提高了识别的准确性。\n\n\n难易度：★★★★★\n优点： 识别准确性高，误判率极低。\n缺点： 实现相对复杂，需要精确的水印特征参数。\n方法四：基于文本特征的直接删除法&#xA;如果你知道水印的具体文本内容，或者可以通过一些简单的文本属性来识别，这个方法最直接、最快速。\nimport fitzdef is_watermark_span(span, target_text=None, min_size=None, max_size=None, target_color_rgb=None, color_tolerance=10):    size_match = True    if min_size is not None and span[&quot;size&quot;] &lt; min_size:        size_match = False    if max_size is not None and span[&quot;size&quot;] &gt; max_size:        size_match = False    text_match = True    if target_text is not None and target_text.lower() not in span[&quot;text&quot;].lower():        text_match = False    color_match = True    if target_color_rgb is not None:        color_int = span[&quot;color&quot;]        r = (color_int &gt;&gt; 16) &amp; 0xFF        g = (color_int &gt;&gt; 8) &amp; 0xFF        b = color_int &amp; 0xFF        current_color_rgb = (r, g, b)        if not (abs(current_color_rgb[0] - target_color_rgb[0]) &lt;= color_tolerance and                abs(current_color_rgb[1] - target_color_rgb[1]) &lt;= color_tolerance and                abs(current_color_rgb[2] - target_color_rgb[2]) &lt;= color_tolerance):            color_match = False    return size_match and text_match and color_matchdef remove_watermark_by_text_features(doc_path, output_path, **kwargs):    doc = fitz.open(doc_path)    for page in doc:        for block in page.get_text(&quot;dict&quot;)[&quot;blocks&quot;]:            if block[&quot;type&quot;] == 0:                for line in block[&quot;lines&quot;]:                    for span in line[&quot;spans&quot;]:                        if is_watermark_span(span, **kwargs):                            page.add_redact_annot(span[&quot;bbox&quot;])        page.apply_redactions()    doc.save(output_path)    doc.close()\n\n代码解析：\n\n通过一个可自定义的 is_watermark_span 函数直接搜索符合特定文本特征的水印内容。\n\n你可以传入 target_text、min_size、max_size 和 target_color_rgb 等参数来精确定义水印的特征。\n\n对判定为水印的文本进行覆盖处理。\n\n\n难易度：★★☆☆☆\n优点： 实现简单，处理速度快，非常适合处理简单的文本水印。\n缺点： 仅适用于文本水印，无法处理图像水印。\n方法五：基于混合特征的高级识别法&#xA;对于更复杂的 PDF 水印（例如包含文本和图像），这种方法结合了文本和图像特征识别，能够提供更高的识别精度。请注意，图像处理部分需要 numpy 和 opencv-python 库。\nimport fitzimport numpy as npimport cv2def advanced_watermark_removal(doc_path, output_path, watermark_template_path=None):    doc = fitz.open(doc_path)    if watermark_template_path:        watermark_template = cv2.imread(watermark_template_path, cv2.IMREAD_GRAYSCALE)        sift = cv2.SIFT_create()        kp1, des1 = sift.detectAndCompute(watermark_template, None)        for page in doc:        text_spans_to_redact = []        image_regions_to_redact = []        text_infos = page.get_text(&quot;dict&quot;)        for block in text_infos[&quot;blocks&quot;]:            if &quot;lines&quot; in block:                for line in block[&quot;lines&quot;]:                    for span in line[&quot;spans&quot;]:                        if (100 &lt;= span[&quot;color_rgb&quot;][0] &lt;= 220 and                             100 &lt;= span[&quot;color_rgb&quot;][1] &lt;= 220 and                             100 &lt;= span[&quot;color_rgb&quot;][2] &lt;= 220) and span[&quot;size&quot;] &gt; 15:                            text_spans_to_redact.append(span[&quot;bbox&quot;])                if watermark_template_path and des1 is not None:            pix = page.get_pixmap(matrix=fitz.Matrix(2,2))            img = cv2.cvtColor(np.frombuffer(pix.samples, np.uint8).reshape(                pix.h, pix.w, pix.n), cv2.COLOR_RGB2GRAY)            kp2, des2 = sift.detectAndCompute(img, None)            if des2 is not None and len(des1) &gt; 0 and len(des2) &gt; 0:                matcher = cv2.BFMatcher()                matches = matcher.knnMatch(des1, des2, k=2)                good_matches = [m for m, n in matches if m.distance &lt; 0.75 * n.distance]                if len(good_matches) &gt; 10:                    src_pts = np.float32([kp1[m.queryIdx].pt for m in good_matches]).reshape(-1, 1, 2)                    dst_pts = np.float32([kp2[m.trainIdx].pt for m in good_matches]).reshape(-1, 1, 2)                    M, mask = cv2.findHomography(src_pts, dst_pts, cv2.RANSAC, 5.0)                    if M is not None:                        h, w = watermark_template.shape                        pts = np.float32([[0, 0], [0, h-1], [w-1, h-1], [w-1, 0]]).reshape(-1, 1, 2)                        dst = cv2.perspectiveTransform(pts, M)                        min_x = int(np.min(dst[:, 0, 0]) / pix.matrix.a)                        min_y = int(np.min(dst[:, 0, 1]) / pix.matrix.d)                        max_x = int(np.max(dst[:, 0, 0]) / pix.matrix.a)                        max_y = int(np.max(dst[:, 0, 1]) / pix.matrix.d)                        image_regions_to_redact.append((min_x, min_y, max_x, max_y))                for span_bbox in text_spans_to_redact:            page.add_redact_annot(fitz.Rect(span_bbox))        for region_bbox in image_regions_to_redact:            page.add_redact_annot(fitz.Rect(region_bbox))        page.apply_redactions()    doc.save(output_path)    doc.close()\n\n代码解析：\n\n文本特征识别： 沿用了之前 is_watermark_text 的概念，但你需要根据实际水印特性来完善这个逻辑。\n\n图像特征识别：\n\n将 PDF 页面渲染为图像，并转换为灰度图，以便进行特征检测。\n\n使用 SIFT 算法（或其他特征匹配算法如 ORB, SURF）来检测并匹配图像水印模板。\n\n通过 findHomography 计算水印在页面上的变换，从而确定水印的精确位置和边界框。\n\n注意： 图像处理库 (如 OpenCV) 通常在像素坐标系下操作，你需要将检测到的像素坐标转换回 PyMuPDF 使用的 PDF 坐标。\n\n综合处理： 将文本和图像识别的结果结合起来，对所有识别出的水印区域进行处理。\n\n\n难易度：★★★★☆\n优点： 识别精度高，适用于复杂水印环境（文本与图像混合），鲁棒性强。\n缺点： 实现复杂，需要水印模板，处理速度相对较慢，需要额外的图像处理库。\n方法六：基于 PDF 底层结构的终极方案&#xA;这种方法最为彻底，因为它直接操作 PDF 文件的底层结构。但它也要求你对 PDF 规范有深入的了解，操作不当可能会导致文件损坏。\nimport fitzdef deep_watermark_removal(doc_path, output_path):    print(&quot;警告：此方法在PyMuPDF中难以直接实现，推荐使用更安全的redaction方法&quot;)    doc = fitz.open(doc_path)    doc.save(output_path)    doc.close()\n\n代码解析：\n\n这个方法旨在直接操作 PDF 的 XObject (外部对象，可以是图像或 Form XObject) 和内容流。\n\n重要提示： PyMuPDF (Fitz) 并没有直接暴露修改或删除底层 PDF 对象的 API。 add_redact_annot 是 PyMuPDF 中最安全和推荐的方式来 “删除” 页面内容的。直接修改 PDF 的底层内容流非常危险，操作不当很可能导致 PDF 文件损坏且无法打开。\n\n因此，我调整了此方法的描述和代码示例，强调其复杂性和风险，并指出在 PyMuPDF 中，更推荐使用 add_redact_annot 来实现 “删除” 效果。如果你真的需要深入到 PDF 底层修改，可能需要更专业的 PDF 处理库或对 PDF 规范有极其深入的了解。\n\n\n难易度：★★★★★ (理论上)\n优点： 理论上可以彻底清除不留痕迹，适用于各种类型水印。\n缺点： 实现非常复杂，需要深入的 PDF 结构知识，且在 PyMuPDF 中直接实现此类操作难度极高且风险大。\n方法对比与选择建议\n\n\n\n方法&#xA;\n难易度&#xA;\n适用场景&#xA;\n关键优势&#xA;\n局限性&#xA;\n\n\n\n字体大小 + 旋转角度&#xA;\n★★★☆☆&#xA;\n水印有固定大小和倾斜角度&#xA;\n实现相对简单，识别准确率较高&#xA;\n需要精确的大小和角度参数&#xA;\n\n\n透明度 + 颜色&#xA;\n★★★★☆&#xA;\n水印有固定颜色（特别是浅色）&#xA;\n对浅色水印效果好&#xA;\n透明度提取是难点，可能需要深入解析 PDF 内部结构或借助图像处理库&#xA;\n\n\n多特征综合&#xA;\n★★★★★&#xA;\n水印特征明确且固定&#xA;\n识别准确性高，误判率极低&#xA;\n实现相对复杂，需要精确的水印特征参数&#xA;\n\n\n基于文本特征&#xA;\n★★☆☆☆&#xA;\n简单文本水印&#xA;\n实现简单，处理速度快&#xA;\n仅适用于文本水印，无法处理图像水印&#xA;\n\n\n混合特征识别&#xA;\n★★★★☆&#xA;\n复杂水印环境（文本与图像混合）&#xA;\n识别精度高&#xA;\n实现复杂，需要水印模板，处理速度慢&#xA;\n\n\n底层结构处理&#xA;\n★★★★★&#xA;\n各种类型水印&#xA;\n理论上最彻底&#xA;\n高风险，PyMuPDF 中难以直接实现，需要深厚知识&#xA;\n\n\n特征参数提取方法\n在实际应用中，我们首先需要获取水印的特征参数。可以通过以下方式初步提取：\nimport fitzimport mathfrom collections import Counterdef extract_watermark_features(pdf_path, page_num=0):    doc = fitz.open(pdf_path)    page = doc[page_num]    possible_font_sizes = []    possible_rotations = []    possible_colors = []        text_infos = page.get_text(&quot;dict&quot;)    for block in text_infos[&quot;blocks&quot;]:        if &quot;lines&quot; in block:            for line in block[&quot;lines&quot;]:                for span in line[&quot;spans&quot;]:                    possible_font_sizes.append(round(span[&quot;size&quot;], 1))                    matrix = fitz.Matrix(span[&quot;matrix&quot;])                    rotation = round(math.degrees(math.atan2(matrix.b, matrix.a)), 1)                    possible_rotations.append(rotation)                    color_int = span[&quot;color&quot;]                    r = (color_int &gt;&gt; 16) &amp; 0xFF                    g = (color_int &gt;&gt; 8) &amp; 0xFF                    b = color_int &amp; 0xFF                    possible_colors.append((r, g, b))        font_size = Counter(possible_font_sizes).most_common(1)[0][0] if possible_font_sizes else None    rotation_angle = Counter(possible_rotations).most_common(1)[0][0] if possible_rotations else None    if rotation_angle and rotation_angle &lt; 0:        rotation_angle += 360    color_rgb = Counter(possible_colors).most_common(1)[0][0] if possible_colors else None        doc.close()    return &#123;        &quot;font_size&quot;: font_size,        &quot;rotation_angle&quot;: rotation_angle,        &quot;color_rgb&quot;: color_rgb,        &quot;opacity&quot;: 0.5    &#125;\n\n代码解析：\n\n此函数会遍历指定页面的所有文本跨度，收集它们的字体大小、旋转角度和颜色。\n\n为了方便统计，对浮点数（大小和角度）进行了四舍五入。\n\n使用 collections.Counter 找出最常见的字体大小、旋转角度和颜色，作为可能的水印特征。\n\n注意： 提取透明度仍然是一个挑战，opacity 参数在此处仍作为占位符，需要通过其他方式（例如手动观察或更复杂的 PDF 内容流解析）来确定。\n\n\n总结与最佳实践\n基于特征的 PDF 水印处理方法能够实现更精确的水印识别和去除，但这要求你对水印的特征有充分了解。在实际应用中，我建议你遵循以下最佳实践：\n\n预处理分析： 首先使用 extract_watermark_features 函数分析水印特征，初步了解水印的字体大小、旋转角度、颜色等关键信息。必要时，手工观察水印，确认其透明度、具体文本内容或图像样式。\n\n从简到繁尝试： 从最简单的方法开始。如果水印是纯文本且特征明显，可以先尝试 基于文本特征的直接删除法。如果水印有固定的字体大小和倾斜角度，就用 基于字体大小和旋转角度的方法。只有当简单方法效果不佳时，再逐步增加特征维度，尝试 多特征综合识别。\n\n合理调整参数： 根据实际水印情况细致调整匹配容差值，在识别准确率和误判率之间取得最佳平衡。例如，对于字体大小，可以允许 1.0 到 2.0 的误差范围；对于旋转角度，可允许 3 到 5 度左右的误差。\n\n复杂场景组合： 对于包含多种类型水印的复杂 PDF，考虑结合多种方法进行处理。例如，对于既有文本又有图像的混合水印，可以结合 混合特征识别法。\n\n批量处理技巧： 如果你需要处理大量 PDF 文件，利用多线程或多进程可以显著提高处理效率。\n\n\nfrom concurrent.futures import ThreadPoolExecutorimport osdef batch_process_pdfs(file_list, output_dir, **watermark_params):    os.makedirs(output_dir, exist_ok=True)    with ThreadPoolExecutor(max_workers=os.cpu_count()) as executor:        futures = []        for file_path in file_list:            file_name = os.path.basename(file_path)            output_path = os.path.join(output_dir, file_name)            futures.append(executor.submit(                remove_watermark_by_multiple_features,                file_path, output_path, **watermark_params            ))        for future in futures:            try:                future.result()                print(f&quot;文件处理完成：&#123;file_path&#125;&quot;)            except Exception as exc:                print(f&quot;文件 &#123;file_path&#125; 处理时发生错误：&#123;exc&#125;&quot;)\n\n\n\n\n操作安全保障： 在处理任何重要文件之前，务必先备份原始文件！这能确保即使处理不当，你也不会丢失原始数据。同时，请始终遵守相关法律法规，仅处理你有权修改的文档，尊重知识产权和版权保护。\n\n通过合理选择和组合这些方法，你就能高效且精准地处理各种具有特定特征的 PDF 水印。\nPS:代码仅供参考，内容不一定正确，要根据实际情况处理喵\n","categories":["PDF 处理","Python","数据处理"],"tags":["Python","PyMuPDF","PDF","水印去除","特征识别","文本处理"]},{"title":"docker离线部署：穿越网络屏障的容器编排利器","url":"/2025/07/16/docker%E7%A6%BB%E7%BA%BF%E9%83%A8%E7%BD%B2%EF%BC%9A%E7%A9%BF%E8%B6%8A%E7%BD%91%E7%BB%9C%E5%B1%8F%E9%9A%9C%E7%9A%84%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E5%88%A9%E5%99%A8/","content":"一、Docker Compose 离线安装步骤\n在 GitHub 上找到对应的 docker-compose 网站，下载适合当前系统的离线安装包（如 docker-compose-linux-x86_64），并将其放置在 &#x2F;tmp 目录下。\n赋予执行权限并移动至系统路径&#xA;# 赋予可执行权限chmod +x /tmp/docker-compose-linux-x86_64# 移动到系统可执行目录sudo mv /tmp/docker-compose-linux-x86_64 /usr/local/bin/docker-compose\n\n验证安装结果&#xA;docker-compose --version# 输出示例：docker-compose version 2.20.3, build a8266d3\n\n二、常见问题与解决方法\n权限不足问题&#xA;问题&#xA;执行 mv 时提示权限错误。\n解决&#xA;使用 sudo 命令获取管理员权限：\nsudo mv /tmp/docker-compose-linux-x86_64 /usr/local/bin/docker-compose\n\n命令不存在问题&#xA;问题&#xA;输入 docker-compose 提示命令未找到。\n解决&#xA;检查系统路径是否包含 &#x2F;usr&#x2F;local&#x2F;bin：\necho $PATH  # 若不含 /usr/local/bin，添加至环境变量export PATH=$PATH:/usr/local/bin\n\n文件名空格问题&#xA;问题&#xA;脚本文件名含前导空格导致命令失败。\n解决&#xA;重命名文件去除空格：\nmv &#x27; replace_image_registry.sh&#x27; replace_image_registry.sh\n\n三、核心命令总结\n安装核心步骤&#xA;下载 → 赋权 → 移动 → 验证\n关键命令&#xA;chmod +x /tmp/docker-compose-linux-x86_64sudo mv /tmp/docker-compose-linux-x86_64 /usr/local/bin/docker-composedocker-compose --version\n\nPS:代码仅供参考，内容不一定正确，要根据实际情况处理喵\n","categories":["容器技术","部署实践"],"tags":["Docker Compose","离线安装","Linux"]},{"title":"揭秘xlsxwriter：富文本格式如何精准“染色”？","url":"/2025/07/16/xlsxwriter%EF%BC%9A%E5%AF%8C%E6%96%87%E6%9C%AC%E6%A0%BC%E5%BC%8F%E5%A6%82%E4%BD%95%E7%B2%BE%E5%87%86%E2%80%9C%E6%9F%93%E8%89%B2%E2%80%9D%EF%BC%9F/","content":"核心概念\nxlsxwriter 通过单元格格式和文本位置索引来精确控制文本区间样式，其判定逻辑基于以下关键内容：\n1. 文本区间定义方式&#xA;# 基本语法（非真实代码，仅示意逻辑）worksheet.write_rich_string(    row, col,    [format1, &quot;红色文本&quot;, format2, &quot;普通文本&quot;])\n\n位置判定：根据字符串在参数列表中的顺序确定位置\n\n格式继承：格式对象作用于紧随其后的文本段\n\n\n2. 关键判定规则&#xA;\n\n\n判定维度&#xA;\n说明&#xA;\n\n\n\n格式对象位置&#xA;\n格式总是应用于下一个字符串元素&#xA;\n\n\n文本分段&#xA;\n每个字符串元素被视为独立文本段&#xA;\n\n\n空格式处理&#xA;\nNone 或省略格式时继承单元格默认格式&#xA;\n\n\n特殊字符&#xA;\n换行符 (\\n) 会创建新文本段但不中断格式应用&#xA;\n\n\n3. 实际应用示例&#xA;案例 1：基础红黑文本&#xA;red = workbook.add_format(&#123;&#x27;color&#x27;: &#x27;red&#x27;&#125;)black = workbook.add_format(&#123;&#x27;color&#x27;: &#x27;black&#x27;&#125;)# &quot;答案&quot;红色，&quot;:&quot;黑色，&quot;42&quot;红色worksheet.write_rich_string(&#x27;A1&#x27;,    red, &#x27;答案&#x27;,    black, &#x27;:&#x27;,    red, &#x27;42&#x27;)\n\n内存中的区间映射：\n[0-2): 红色格式 (对应&quot;答案&quot;)[2-3): 黑色格式 (对应&quot;:&quot;) [3-5): 红色格式 (对应&quot;42&quot;)\n\n案例 2：带格式继承的文本&#xA;bold = workbook.add_format(&#123;&#x27;bold&#x27;: True&#125;)default = workbook.add_format()# &quot;注意&quot;加粗，后续文本默认格式worksheet.write_rich_string(&#x27;A2&#x27;,    bold, &#x27;注意&#x27;,    None, &#x27;：请检查数据&#x27;  # None继承单元格默认格式)\n\n4. 特殊场景处理&#xA;混合格式文本&#xA;# 同一单词中部分字母标红worksheet.write_rich_string(&#x27;A3&#x27;,    black, &#x27;Pri&#x27;,    red, &#x27;mar&#x27;,    black, &#x27;y&#x27;)\n效果：显示为 “Primary” 其中 “mar” 为红色\n动态文本构建&#xA;parts = [black, &quot;随机值：&quot;]if highlight:    parts.extend([red, str(value)])else:    parts.extend([black, str(value)])    worksheet.write_rich_string(&#x27;A4&#x27;, *parts)\n\n5. 底层实现原理&#xA;\nOpenXML 映射：最终生成类似以下 XML 结构\n\n&lt;r&gt;  &lt;rPr&gt;&lt;color rgb=&quot;FFFF0000&quot;/&gt;&lt;/rPr&gt;  &lt;t&gt;答案&lt;/t&gt;&lt;/r&gt;&lt;r&gt;  &lt;rPr&gt;&lt;color rgb=&quot;FF000000&quot;/&gt;&lt;/rPr&gt;  &lt;t&gt;:&lt;/t&gt;&lt;/r&gt;\n\n索引计算：库内部维护格式栈，根据参数顺序计算每个文本段的起止位置\n\n6. 使用限制与注意事项&#xA;\n不可变特性：一旦写入无法修改单个文本段格式\n\n性能影响：每个格式变化都会创建新的&lt;r&gt;元素，过多分段影响文件大小\n\n边界情况：\n\n空字符串仍会占用格式区间\n连续的相同格式不会自动合并\n\n\n\n7. 调试技巧&#xA;# 查看实际生成的XML（需要保存文件后解压查看）workbook.filename = &#x27;output.xlsx&#x27;workbook.close()# 解压后查看xl/worksheets/sheet1.xml\n\n最佳实践建议&#xA;\n批量合并相同格式的文本段\n\n对静态内容预先生成格式列表\n\n避免单个单元格内超过 20 个格式分段\n\n对动态内容使用辅助函数构建参数列表\n\n\ndef build_rich_text(text_parts):    result = []    for text, fmt in text_parts:        result.extend([fmt, text])    return result\n\n注：与 openpyxl 的 CellRichText 不同，xlsxwriter 采用更底层的格式绑定机制，对文本区间的判定完全基于参数序列顺序，不依赖任何文本标记符号。\n关键要点总结&#xA;\nxlsxwriter 的文本区间判定是顺序敏感的\n\n格式对象总是向前绑定到下一个文本元素\n\n实际渲染时会将文本区间映射为 OpenXML 的&lt;r&gt;元素\n\n处理富文本时需要特别注意参数列表的构建顺序\n\n\nPS:代码仅供参考，内容不一定正确，要根据实际情况处理喵\n","categories":["Python库应用"],"tags":["Excel","Python","xlsxwriter","格式化"]},{"title":"从零开始的爬虫生活（一）：环境搭建与基础库应用","url":"/2025/07/15/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84%E7%88%AC%E8%99%AB%E7%94%9F%E6%B4%BB%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E5%9F%BA%E7%A1%80%E5%BA%93%E5%BA%94%E7%94%A8/","content":"一、环境搭建\n在开始学习爬虫之前，我们需要先搭建好开发环境。以下是一些常用的工具和库：\n1. Python 环境&#xA;确保已经安装了 Python 3.x 版本。可以前往 Python 官网 下载安装。\n2. 常用库安装&#xA;使用 pip 命令安装以下库：\npip install seleniumpip install beautifulsoup4pip install pyquerypip install pymysqlpip install pymongopip install redis\n\n3. 浏览器驱动&#xA;\nChromeDriver：根据你使用的 Chrome 浏览器版本，下载对应的 ChromeDriver。\n\nPhantomJS（已弃用）：在 Selenium 4.x 中已移除，建议使用无头模式的 Chrome。\n\n\n配置 Chrome 无头模式示例：\nfrom selenium import webdriverfrom selenium.webdriver.chrome.options import Options# 配置 Chrome 为无头模式chrome_options = Options()chrome_options.add_argument(&quot;--headless&quot;)  # 无头模式，不显示浏览器窗口# 创建 Chrome 浏览器实例driver = webdriver.Chrome(options=chrome_options)driver.get(&quot;https://www.example.com&quot;)print(driver.title)driver.quit()\n\n二、基础库应用\n1. BeautifulSoup 库&#xA;BeautifulSoup 是一个用于解析 HTML 和 XML 文档的库。示例：\nfrom bs4 import BeautifulSouphtml_doc = &quot;&quot;&quot;&lt;html&gt;    &lt;head&gt;        &lt;title&gt;示例页面&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;h1&gt;标题&lt;/h1&gt;        &lt;p&gt;段落内容&lt;/p&gt;    &lt;/body&gt;&lt;/html&gt;&quot;&quot;&quot;soup = BeautifulSoup(html_doc, &#x27;html.parser&#x27;)print(soup.title.string)  # 输出标题内容&quot;&quot;&quot;soup = BeautifulSoup(html_doc, &#x27;html.parser&#x27;)print(soup.title.string)  # 输出标题内容\n\n2. PyQuery 库&#xA;PyQuery 是一个类 jQuery 的 Python 库，用于操作 HTML 文档。示例：\nfrom pyquery import PyQuery as pqhtml_doc = &quot;&quot;&quot;&lt;html&gt;    &lt;head&gt;        &lt;title&gt;示例页面&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;h1&gt;标题&lt;/h1&gt;        &lt;p&gt;段落内容&lt;/p&gt;    &lt;/body&gt;&lt;/html&gt;&quot;&quot;&quot;doc = pq(html_doc)print(doc(&#x27;title&#x27;).text())  # 输出标题内容\n\n3. Requests 库&#xA;Requests 是一个简单的 HTTP 库，用于发送网络请求。示例：\nimport requestsurl = &quot;https://www.example.com&quot;response = requests.get(url)print(response.text)  # 输出网页内容\n\n三、数据存储\n1. MySQL 数据库&#xA;使用 PyMySQL 连接和操作 MySQL 数据库：\nimport pymysqlconn = pymysql.connect(    host=&#x27;localhost&#x27;,    user=&#x27;root&#x27;,    password=&#x27;123456&#x27;,    port=3306,    db=&#x27;mysql&#x27;)cursor = conn.cursor()cursor.execute(&#x27;SELECT * FROM db&#x27;)print(cursor.fetchone())conn.close()\n\n2. MongoDB 数据库&#xA;使用 PyMongo 连接和操作 MongoDB 数据库：\nimport pymongoclient = pymongo.MongoClient(&#x27;localhost&#x27;)db = client[&#x27;newtestdb&#x27;]db[&#x27;table&#x27;].insert_one(&#123;&#x27;name&#x27;: &#x27;Bob&#x27;&#125;)result = db[&#x27;table&#x27;].find_one(&#123;&#x27;name&#x27;: &#x27;Bob&#x27;&#125;)print(result)\n\n3. Redis 数据库&#xA;使用 RedisPy 连接和操作 Redis 数据库：\nimport redisr = redis.Redis(&#x27;localhost&#x27;, 6379)r.set(&#x27;name&#x27;, &#x27;Bob&#x27;)result = r.get(&#x27;name&#x27;)print(result)\n\n四、爬虫基本流程\n爬虫的基本流程如下：\n\n发送请求：使用 Requests 库发送 HTTP 请求获取网页内容。\n\n解析响应：使用 BeautifulSoup 或 PyQuery 库解析网页内容，提取所需数据。\n\n保存数据：将提取的数据存储到数据库或文件中。\n\n\n示例：爬取猫眼电影 TOP100\nimport requestsimport reimport jsonfrom multiprocessing import Pooldef get_one_page(url):    headers = &#123;        &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/137.0.0.0 Safari/537.36 Edg/137.0.0.0&#x27;    &#125;    response = requests.get(url, headers=headers)    if response.status_code == 200:        return response.text    return Nonedef parse_one_page(html):    pattern = re.compile(&#x27;&lt;dd&gt;.*?board-index.*?&gt;(d+)&lt;/i&gt;.*?data-src=&quot;(.*?)&quot;.*?name&quot;&gt;&lt;a&#x27;                         + &#x27;.*?&gt;(.*?)&lt;/a&gt;.*?star&quot;&gt;(.*?)&lt;/p&gt;.*?releasetime&quot;&gt;(.*?)&lt;/p&gt;&#x27;                         + &#x27;.*?integer&quot;&gt;(.*?)&lt;/i&gt;.*?fraction&quot;&gt;(.*?)&lt;/i&gt;.*?&lt;/dd&gt;&#x27;, re.S)    items = re.findall(pattern, html)    for item in items:        yield &#123;            &#x27;index&#x27;: item[0],            &#x27;image&#x27;: item[1],            &#x27;title&#x27;: item[2],            &#x27;actor&#x27;: item[3].strip()[3:],            &#x27;time&#x27;: item[4].strip()[5:],            &#x27;score&#x27;: item[5] + item[6]        &#125;def write_to_file(content):    with open(&#x27;result.txt&#x27;, &#x27;a&#x27;, encoding=&#x27;utf-8&#x27;) as f:        f.write(json.dumps(content, ensure_ascii=False) + &#x27;n&#x27;)def main(offset):    url = &#x27;http://maoyan.com/board/4?offset=&#x27; + str(offset)    html = get_one_page(url)    for item in parse_one_page(html):        print(item)        write_to_file(item)if __name__ == &#x27;__main__&#x27;:    pool = Pool()    pool.map(main, [i * 10 for i in range(10)])\n\n五、动态网页处理\n对于动态加载的网页，可以使用 Selenium 模拟浏览器操作。示例：\nfrom selenium import webdriverfrom selenium.webdriver.common.by import Bydriver = webdriver.Chrome()driver.get(&#x27;https://www.taobao.com&#x27;)input = driver.find_element(By.ID, &#x27;q&#x27;)input.send_keys(&#x27;美食&#x27;)button = driver.find_element(By.CLASS_NAME, &#x27;btn-search&#x27;)button.click()driver.quit()\n\n六、爬虫框架\n1. Scrapy 框架&#xA;Scrapy 是一个强大的爬虫框架，可以简化爬虫开发过程。安装命令：\npip install scrapy\n\n未完待续……\nPS:代码仅供参考，内容不一定正确，要根据实际情况处理喵\n","categories":["爬虫教程"],"tags":["Python爬虫","数据抓取","Selenium","BeautifulSoup","数据存储"]},{"title":"《水印处理的成长日记：从0开始的PDF处理之路》","url":"/2025/07/16/%E3%80%8A%E6%B0%B4%E5%8D%B0%E5%A4%84%E7%90%86%E7%9A%84%E6%88%90%E9%95%BF%E6%97%A5%E8%AE%B0%EF%BC%9A%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84PDF%E5%A4%84%E7%90%86%E4%B9%8B%E8%B7%AF%E3%80%8B/","content":"在日常办公和学习中，我们经常会遇到带有水印的 PDF 文档，这些水印不仅影响阅读体验，还可能干扰文档的二次编辑和使用。本文将带你从零开始，一步步构建一个功能完善的 PDF 水印去除工具，实现从单文件处理到批量转换的完整解决方案。\n需求分析：为什么需要 PDF 水印去除工具\nPDF 水印通常分为可见水印和不可见水印两类。可见水印多以文字、Logo 等形式存在，虽然不影响内容的可读性，但在文档分发、打印等场景下会显得不够专业。特别是一些带有 “内部资料”、”草稿” 等字样的水印，在正式场合使用时需要去除。\n理想的 PDF 水印去除工具应具备以下功能：\n\n精准识别并去除各类可见水印\n\n保留原文档的文本格式和图片内容\n\n支持批量处理多个 PDF 文件\n\n提供直观易用的图形界面\n\n输出格式支持 Word，方便后续编辑\n\n\n基础版本：实现单文件水印去除功能\n我们先从基础版本开始，搭建一个能够处理单个 PDF 文件的水印去除工具。这个版本将实现水印识别、内容提取和格式转换的核心功能。\n核心技术选型&#xA;实现 PDF 水印去除需要用到以下关键库：\n\nfitz（PyMuPDF）：用于 PDF 文件的解析和内容提取\n\npython-docx：用于生成 Word 格式的输出文件\n\nPIL（Pillow）：用于处理 PDF 中的图片内容\n\nPyQt5：用于构建图形用户界面\n\n\n核心功能实现&#xA;基础版本的核心功能主要分为三个模块：PDF 信息提取、水印识别与去除、Word 文档生成。\nPDF 信息提取模块&#xA;extract_full_pdf_info函数负责从 PDF 中提取文本内容、图片和格式信息：\ndef extract_full_pdf_info(pdf_path: str) -&gt; List[Dict[str, Any]]:    if not os.path.exists(pdf_path):        raise FileNotFoundError(f&quot;PDF文件未找到: &#123;pdf_path&#125;&quot;)    doc = fitz.open(pdf_path)    full_info = []    temp_image_dir = os.path.abspath(&quot;temp_pdf_images&quot;)    os.makedirs(temp_image_dir, exist_ok=True)    for page_num in range(len(doc)):        page = doc[page_num]        page_data = &#123;            &quot;page_number&quot;: page_num + 1,            &quot;page_size&quot;: &#123;&quot;width&quot;: page.rect.width, &quot;height&quot;: page.rect.height&#125;,            &quot;rotation&quot;: page.rotation,            &quot;text_content&quot;: [],            &quot;images&quot;: []        &#125;        # 提取文本内容        text_blocks = page.get_text(&quot;dict&quot;)[&quot;blocks&quot;]        for block in text_blocks:            if block[&quot;type&quot;] == 0:  # 文本块                # 处理文本块、行和文字片段...        # 提取图片        images = page.get_images(full=True)        # 处理图片提取、软掩码合并和格式转换...        full_info.append(page_data)    doc.close()    return full_info\n水印识别与去除模块&#xA;remove_watermark_by_alpha函数通过分析文本的透明度、字体大小和颜色来识别并去除水印：\ndef remove_watermark_by_alpha(full_info: List[Dict[str, Any]]) -&gt; List[Dict[str, Any]]:    clean_full_info = []    watermark_removed_count = 0    ALPHA_THRESHOLD = 150  # 透明度阈值    TARGET_FONT_SIZE = 18  # 水印字体大小    FONT_SIZE_TOLERANCE = 1  # 字体大小容差    TARGET_COLOR_INT_VALUE = 13882323  # 水印颜色值    for page in full_info:        clean_text_blocks = []        for text_block in page[&quot;text_content&quot;]:            # 处理文本块，过滤水印内容...            watermark_removed_count += 1  # 统计去除的水印数量        clean_page = &#123;**page, &quot;text_content&quot;: clean_text_blocks, &quot;images&quot;: page[&quot;images&quot;]&#125;        clean_full_info.append(clean_page)    print(f&quot;水印移除完成。共移除 &#123;watermark_removed_count&#125; 处水印文本。&quot;)    return clean_full_info\nWord 文档生成模块&#xA;generate_word_from_data函数将清理后的内容转换为 Word 文档：\ndef generate_word_from_data(clean_info: List[Dict[str, Any]], output_word_path: str) -&gt; None:    doc = Document()    font_mapping = get_system_font_mapping()  # 字体映射表    # 收集并排序文本和图片元素...    # 生成Word内容，保留原格式...    try:        doc.save(output_word_path)        print(f&quot;Word文档已保存至：&#123;output_word_path&#125;&quot;)    except Exception as e:       print(f&quot;保存Word文档失败：&#123;e&#125;&quot;)\n基础版本界面设计&#xA;基础版本采用简洁的图形界面，主要包含文件选择、处理和状态显示功能：\nclass PdfWatermarkRemoverApp(QWidget):    def __init__(self):        super().__init__()        self.setWindowTitle(&quot;PDF水印移除工具&quot;)        self.setFixedSize(750, 400)        self.init_ui()        # 初始化其他属性...    def init_ui(self):        main_layout = QVBoxLayout()        # 设置布局、添加文件选择框、处理按钮和状态标签...    def browse_pdf_file(self):        # 打开文件对话框，选择PDF文件...    def start_processing(self):        # 开始处理PDF文件...\n优化版本：功能增强与体验提升\n在基础版本的基础上，我们进一步优化功能，增加批量处理能力，提升用户体验，打造一个更实用的工具。\n核心功能改进&#xA;优化版本主要在以下几个方面进行了改进：\n1. 增加文件夹批量处理功能&#xA;用户可以选择整个文件夹进行批量处理，工具会自动识别并处理文件夹中的所有 PDF 文件：\ndef browse_folder(self):    folder_path = QFileDialog.getExistingDirectory(self, &quot;选择包含 PDF 文件的文件夹&quot;)    if folder_path:        self.processing_queue = []        # 遍历文件夹，收集所有PDF文件...        self.total_files_to_process = len(self.processing_queue)        self.processing_mode = &quot;folder&quot;       # 更新界面显示...\n\n2. 改进的文件处理流程&#xA;引入处理队列和工作线程，支持连续处理多个文件，并显示实时进度：\ndef process_next_file(self):    if not self.processing_queue:        self.on_all_processing_finished()  # 所有文件处理完成        return    current_pdf_path = self.processing_queue.pop(0)    # 确定输出路径...    # 检查文件是否已存在，处理覆盖逻辑...    self.processed_count += 1   self.status_label.setText(f&quot;正在处理第 &#123;self.processed_count&#125; / &#123;self.total_files_to_process&#125; 个文件...&quot;)    # 启动工作线程处理当前文件...\n3. 增强的图片处理能力&#xA;优化图片提取和转换逻辑，更好地保留图片质量和透明度：\ndef convert_image_format(temp_path, target_format=&#x27;png&#x27;):    try:        with Image.open(temp_path) as img:            original_mode = img.mode            new_path = os.path.splitext(temp_path)[0] + f&#x27;.&#123;target_format&#125;&#x27;            if &#x27;A&#x27; in original_mode:  # 处理透明图片                if original_mode != &#x27;RGBA&#x27;:                    img = img.convert(&#x27;RGBA&#x27;)               img.save(new_path, format=target_format.upper())               # 输出转换信息...           else:               # 处理非透明图片...           return new_path   except Exception as e:       # 处理转换错误...\n\n4. 更智能的文本格式处理&#xA;优化文本排版逻辑，自动识别标题、段落，保持原文档的格式风格：\n# 分析最常见的字体大小作为正文字体if all_font_sizes:   from collections import Counter   most_common_size = Counter(all_font_sizes).most_common(1)[0][0]   print(f&quot;分析得出正文字体大小: &#123;most_common_size&#125;&quot;)   title_font_threshold = most_common_size * 1.2  # 标题字体阈值else:   # 使用默认值...\n\n界面与交互优化&#xA;优化版本的界面更加友好，交互更加流畅：\n1. 直观的文件选择界面&#xA;提供文件和文件夹两种选择方式，满足不同场景需求：\n# 选择文件按钮self.browse_files_button = QPushButton(&quot;选择文件...&quot;)self.browse_files_button.clicked.connect(self.browse_pdf_files)# 选择文件夹按钮self.browse_folder_button = QPushButton(&quot;选择文件夹...&quot;)self.browse_folder_button.clicked.connect(self.browse_folder)\n\n2. 实时进度显示&#xA;清晰展示当前处理进度和状态，让用户了解处理情况：\nself.status_label = QLabel(&quot;等待选择文件/文件夹...&quot;)self.current_file_status_label = QLabel(&quot;&quot;)  # 显示当前处理的文件名\n\n3. 文件覆盖策略选择&#xA;当输出文件已存在时，提供灵活的覆盖选项：\n# 覆盖所有文件复选框self.overwrite_all_checkbox = QCheckBox(&quot;对当前批次的所有冲突文件执行此操作&quot;)self.overwrite_all_checkbox.setVisible(False)  # 默认隐藏\n\n工具使用指南\n使用优化后的 PDF 水印去除工具非常简单，只需几个步骤即可完成水印去除：\n\n选择文件或文件夹：点击 “选择文件” 按钮处理单个 PDF，或点击 “选择文件夹” 按钮批量处理多个 PDF。\n\n开始处理：点击 “开始处理” 按钮，工具将自动去除水印并转换为 Word 格式。\n\n查看结果：处理完成后，工具会显示成功和失败的文件统计，结果文件将保存在源文件所在目录的 “_无水印” 子文件夹中。\n\n\n常见问题与解决方案\n在使用过程中，可能会遇到一些常见问题，以下是解决方案：\n\n水印去除不彻底：可能是水印特征发生变化，可以调整 remove_watermark_by_alpha 函数中的阈值参数。\n\n图片显示异常：部分特殊格式的图片可能转换失败，可以尝试更新 Pillow 库到最新版本。\n\n格式错乱：复杂排版的 PDF 转换后可能出现格式问题，可以手动调整 Word 文档的样式。\n\n处理速度慢：大型 PDF 文件处理需要较长时间，请耐心等待，工具正在后台工作。\n\n\n总结与展望\n通过本文介绍的方法，我们成功构建了一个功能完善的 PDF 水印去除工具，实现了从单文件处理到批量转换的完整解决方案。该工具能够精准去除水印，保留原文档的文本格式和图片内容，大大提高了文档处理效率。\n未来，我们可以从以下几个方面进一步优化这个工具：\n\n增加对更多水印类型的支持，如图片水印、倾斜文字水印等\n\n优化 OCR 功能，提高扫描版 PDF 的处理效果\n\n增加自定义水印规则的功能，允许用户手动标记水印特征\n\n支持更多输出格式，如 Markdown、HTML 等\n\n开发云同步功能，实现跨设备使用\n\n\n完整代码实现\n以下是完整的 PDF 水印去除工具代码，包含所有功能模块和界面实现：\nimport osimport sysimport tempfilefrom typing import List, Dict, Any, Tuple, Optionalfrom collections import Counterfrom PyQt5.QtWidgets import (QApplication, QWidget, QVBoxLayout, QHBoxLayout,                          QPushButton, QLabel, QFileDialog, QProgressBar,                          QMessageBox, QCheckBox, QFrame)from PyQt5.QtCore import Qt, QThread, pyqtSignalfrom PyQt5.QtGui import QFontimport fitz  # PyMuPDFfrom docx import Documentfrom docx.shared import Pt, Inchesfrom docx.oxml.ns import qnfrom docx.enum.text import WD_ALIGN_PARAGRAPHfrom PIL import Image# 全局临时目录，用于存储提取的图片GLOBAL_TEMP_DIR = os.path.join(tempfile.gettempdir(), &quot;pdf_watermark_remover&quot;)os.makedirs(GLOBAL_TEMP_DIR, exist_ok=True)class PDFProcessor:   &quot;&quot;&quot;PDF处理核心类，负责提取内容、去除水印和生成Word文档&quot;&quot;&quot;   @staticmethod   def extract_full_pdf_info(pdf_path: str) -&gt; List[Dict[str, Any]]:       &quot;&quot;&quot;提取PDF中的文本、图片和格式信息&quot;&quot;&quot;       if not os.path.exists(pdf_path):           raise FileNotFoundError(f&quot;PDF文件未找到: &#123;pdf_path&#125;&quot;)       doc = fitz.open(pdf_path)       full_info = []       temp_image_dir = os.path.join(GLOBAL_TEMP_DIR, os.path.basename(pdf_path).replace(&#x27;.pdf&#x27;, &#x27;&#x27;))       os.makedirs(temp_image_dir, exist_ok=True)       for page_num in range(len(doc)):           page = doc[page_num]           page_data = &#123;               &quot;page_number&quot;: page_num + 1,               &quot;page_size&quot;: &#123;&quot;width&quot;: page.rect.width, &quot;height&quot;: page.rect.height&#125;,               &quot;rotation&quot;: page.rotation,               &quot;text_content&quot;: [],               &quot;images&quot;: []           &#125;           # 提取文本内容           text_blocks = page.get_text(&quot;dict&quot;)[&quot;blocks&quot;]           for block in text_blocks:               if block[&quot;type&quot;] == 0:  # 文本块                   text_block_data = &#123;                       &quot;bbox&quot;: block[&quot;bbox&quot;],                       &quot;lines&quot;: []                   &#125;                   for line in block[&quot;lines&quot;]:                       line_data = &#123;                           &quot;spans&quot;: [],                           &quot;bbox&quot;: line[&quot;bbox&quot;]                       &#125;                       for span in line[&quot;spans&quot;]:                           span_data = &#123;                               &quot;text&quot;: span[&quot;text&quot;],                               &quot;font&quot;: span[&quot;font&quot;],                               &quot;size&quot;: span[&quot;size&quot;],                               &quot;color&quot;: span[&quot;color&quot;],                               &quot;flags&quot;: span[&quot;flags&quot;],                               &quot;bbox&quot;: span[&quot;bbox&quot;]                           &#125;                           line_data[&quot;spans&quot;].append(span_data)                       text_block_data[&quot;lines&quot;].append(line_data)                   page_data[&quot;text_content&quot;].append(text_block_data)           # 提取图片           images = page.get_images(full=True)           for img_index, img in enumerate(images):               xref = img[0]               base_image = doc.extract_image(xref)               image_bytes = base_image[&quot;image&quot;]               image_ext = base_image[&quot;ext&quot;]               image_width = base_image[&quot;width&quot;]               image_height = base_image[&quot;height&quot;]               # 构建图片路径               img_filename = f&quot;page_&#123;page_num+1&#125;_img_&#123;img_index&#125;.&#123;image_ext&#125;&quot;               img_path = os.path.join(temp_image_dir, img_filename)               # 保存图片               with open(img_path, &quot;wb&quot;) as f:                   f.write(image_bytes)               # 处理软掩码（透明度）               if base_image[&quot;smask&quot;]:                   smask_image = doc.extract_image(base_image[&quot;smask&quot;])                   smask_bytes = smask_image[&quot;image&quot;]                   smask_path = os.path.join(temp_image_dir, f&quot;page_&#123;page_num+1&#125;_img_&#123;img_index&#125;_mask.&#123;image_ext&#125;&quot;)                   with open(smask_path, &quot;wb&quot;) as f:                       f.write(smask_bytes)                   # 合并图片和掩码                   img_path = PDFProcessor.merge_image_with_mask(img_path, smask_path)                   os.remove(smask_path)  # 清理临时掩码文件               # 转换图片格式为PNG以确保兼容性               if image_ext.lower() != &#x27;png&#x27;:                   img_path = PDFProcessor.convert_image_format(img_path, &#x27;png&#x27;)               # 获取图片在页面中的位置               img_rect = page.get_image_rects(xref)[0]               page_data[&quot;images&quot;].append(&#123;                   &quot;path&quot;: img_path,                   &quot;ext&quot;: image_ext,                   &quot;width&quot;: image_width,                   &quot;height&quot;: image_height,                   &quot;rect&quot;: img_rect,                   &quot;index&quot;: img_index               &#125;)           full_info.append(page_data)       doc.close()       return full_info   @staticmethod   def merge_image_with_mask(image_path: str, mask_path: str) -&gt; str:       &quot;&quot;&quot;合并图片和掩码以保留透明度&quot;&quot;&quot;       try:           with Image.open(image_path) as img, Image.open(mask_path) as mask:               # 确保图片和掩码尺寸一致               if img.size != mask.size:                   mask = mask.resize(img.size)               # 合并图片和掩码               img.putalpha(mask)               new_path = os.path.splitext(image_path)[0] + &#x27;_merged.png&#x27;               img.save(new_path, &#x27;PNG&#x27;)               os.remove(image_path)  # 移除原始图片               return new_path       except Exception as e:           print(f&quot;合并图片和掩码失败: &#123;e&#125;&quot;)           return image_path  # 失败时返回原始图片路径   @staticmethod   def convert_image_format(temp_path: str, target_format: str = &#x27;png&#x27;) -&gt; str:       &quot;&quot;&quot;转换图片格式&quot;&quot;&quot;       try:           with Image.open(temp_path) as img:               original_mode = img.mode               new_path = os.path.splitext(temp_path)[0] + f&#x27;.&#123;target_format&#125;&#x27;               # 处理透明图片               if &#x27;A&#x27; in original_mode:                   if original_mode != &#x27;RGBA&#x27;:                       img = img.convert(&#x27;RGBA&#x27;)                   img.save(new_path, format=target_format.upper())               else:                   # 非透明图片直接转换                   img.save(new_path, format=target_format.upper())               os.remove(temp_path)  # 移除原始格式图片               return new_path       except Exception as e:           print(f&quot;转换图片格式失败: &#123;e&#125;&quot;)           return temp_path  # 失败时返回原始路径   @staticmethod   def remove_watermark_by_alpha(full_info: List[Dict[str, Any]]) -&gt; List[Dict[str, Any]]:       &quot;&quot;&quot;通过透明度、字体大小和颜色识别并去除水印&quot;&quot;&quot;       clean_full_info = []       watermark_removed_count = 0       # 水印特征参数       ALPHA_THRESHOLD = 150  # 透明度阈值       TARGET_FONT_SIZE = 18  # 水印字体大小       FONT_SIZE_TOLERANCE = 1  # 字体大小容差       TARGET_COLOR_INT_VALUE = 13882323  # 水印颜色值       for page in full_info:           clean_text_blocks = []           for text_block in page[&quot;text_content&quot;]:               clean_lines = []               for line in text_block[&quot;lines&quot;]:                   clean_spans = []                   for span in line[&quot;spans&quot;]:                       # 检查是否为水印文本                       is_watermark = False                       # 检查字体大小                       size_diff = abs(span[&quot;size&quot;] - TARGET_FONT_SIZE)                       if size_diff &lt;= FONT_SIZE_TOLERANCE:                           # 检查颜色                           if span[&quot;color&quot;] == TARGET_COLOR_INT_VALUE:                               # 检查透明度（通过flags判断）                               # flags的第3位表示透明度                               if (span[&quot;flags&quot;] &amp; 0b100) != 0:                                   is_watermark = True                       if not is_watermark:                           clean_spans.append(span)                       else:                           watermark_removed_count += 1                   if clean_spans:  # 只保留有内容的行                       clean_line = &#123;**line, &quot;spans&quot;: clean_spans&#125;                       clean_lines.append(clean_line)               if clean_lines:  # 只保留有内容的文本块                   clean_block = &#123;** text_block, &quot;lines&quot;: clean_lines&#125;                   clean_text_blocks.append(clean_block)           # 保留图片信息           clean_page = &#123;**page, &quot;text_content&quot;: clean_text_blocks, &quot;images&quot;: page[&quot;images&quot;]&#125;           clean_full_info.append(clean_page)       print(f&quot;水印移除完成。共移除 &#123;watermark_removed_count&#125; 处水印文本。&quot;)       return clean_full_info   @staticmethod   def get_system_font_mapping() -&gt; Dict[str, str]:       &quot;&quot;&quot;获取系统字体映射表，用于PDF到Word的字体转换&quot;&quot;&quot;       return &#123;           &quot;SimSun&quot;: &quot;宋体&quot;,           &quot;SimHei&quot;: &quot;黑体&quot;,           &quot;Microsoft YaHei&quot;: &quot;微软雅黑&quot;,           &quot;KaiTi&quot;: &quot;楷体&quot;,           &quot;FangSong&quot;: &quot;仿宋&quot;,           &quot;Arial&quot;: &quot;Arial&quot;,           &quot;Times New Roman&quot;: &quot;Times New Roman&quot;,           # 可以根据需要添加更多字体映射       &#125;   @staticmethod   def generate_word_from_data(clean_info: List[Dict[str, Any]], output_word_path: str) -&gt; None:       &quot;&quot;&quot;从清理后的PDF信息生成Word文档&quot;&quot;&quot;       doc = Document()       font_mapping = PDFProcessor.get_system_font_mapping()       # 收集所有字体大小用于分析       all_font_sizes = []       for page in clean_info:           for block in page[&quot;text_content&quot;]:               for line in block[&quot;lines&quot;]:                   for span in line[&quot;spans&quot;]:                       all_font_sizes.append(span[&quot;size&quot;])       # 分析最常见的字体大小作为正文字体       if all_font_sizes:           most_common_size = Counter(all_font_sizes).most_common(1)[0][0]           print(f&quot;分析得出正文字体大小: &#123;most_common_size&#125;&quot;)           title_font_threshold = most_common_size * 1.2  # 标题字体阈值       else:           most_common_size = 12  # 默认正文字体大小           title_font_threshold = 14  # 默认标题字体阈值       # 处理每一页内容       for page in clean_info:           # 为新页面添加分页符（第一页除外）           if page[&quot;page_number&quot;] &gt; 1:               doc.add_page_break()           # 添加页码           page_paragraph = doc.add_paragraph()           page_run = page_paragraph.add_run(f&quot;第 &#123;page[&#x27;page_number&#x27;]&#125; 页&quot;)           page_run.font.size = Pt(9)           page_paragraph.alignment = WD_ALIGN_PARAGRAPH.CENTER           # 收集页面上的所有元素（文本块和图片）并按位置排序           page_elements = []           # 添加文本块           for block in page[&quot;text_content&quot;]:               # 使用文本块的边界框顶部作为排序依据               block_top = block[&quot;bbox&quot;][1]               page_elements.append(&#123;                   &quot;type&quot;: &quot;text&quot;,                   &quot;top&quot;: block_top,                   &quot;data&quot;: block               &#125;)           # 添加图片           for img in page[&quot;images&quot;]:               # 使用图片的顶部位置作为排序依据               img_top = img[&quot;rect&quot;][1]               page_elements.append(&#123;                   &quot;type&quot;: &quot;image&quot;,                   &quot;top&quot;: img_top,                   &quot;data&quot;: img               &#125;)           # 按元素在页面中的垂直位置排序           page_elements.sort(key=lambda x: x[&quot;top&quot;])           # 处理排序后的元素           for element in page_elements:               if element[&quot;type&quot;] == &quot;text&quot;:                   PDFProcessor._add_text_block_to_doc(doc, element[&quot;data&quot;], font_mapping,                                                     title_font_threshold, most_common_size)               elif element[&quot;type&quot;] == &quot;image&quot;:                   PDFProcessor._add_image_to_doc(doc, element[&quot;data&quot;])       # 保存生成的Word文档       try:           # 确保输出目录存在           output_dir = os.path.dirname(output_word_path)           os.makedirs(output_dir, exist_ok=True)           doc.save(output_word_path)           print(f&quot;Word文档已保存至：&#123;output_word_path&#125;&quot;)       except Exception as e:           print(f&quot;保存Word文档失败：&#123;e&#125;&quot;)           raise   @staticmethod   def _add_text_block_to_doc(doc, text_block, font_mapping, title_threshold, normal_size):       &quot;&quot;&quot;将文本块添加到Word文档&quot;&quot;&quot;       for line in text_block[&quot;lines&quot;]:           paragraph = doc.add_paragraph()           for span in line[&quot;spans&quot;]:               run = paragraph.add_run(span[&quot;text&quot;])               # 设置字体               font_name = span[&quot;font&quot;]               # 映射到系统可用字体               mapped_font = font_mapping.get(font_name, font_name)               try:                   run.font.name = mapped_font                   # 设置中文字体                   run._element.rPr.rFonts.set(qn(&#x27;w:eastAsia&#x27;), mapped_font)               except Exception as e:                   print(f&quot;设置字体 &#123;mapped_font&#125; 失败: &#123;e&#125;&quot;)                   run.font.name = &quot;宋体&quot;                   run._element.rPr.rFonts.set(qn(&#x27;w:eastAsia&#x27;), &quot;宋体&quot;)               # 设置字体大小               try:                   run.font.size = Pt(span[&quot;size&quot;])               except:                   run.font.size = Pt(normal_size)               # 设置字体颜色（简化处理，仅使用黑白两色）               if span[&quot;color&quot;] in (0, 255):  # 黑色或白色                   run.font.color.rgb = None  # 使用默认颜色               else:                   # 转换PDF颜色值（整数）为RGB                   rgb = PDFProcessor._int_to_rgb(span[&quot;color&quot;])                   run.font.color.rgb = rgb           # 根据字体大小判断是否为标题           if line[&quot;spans&quot;]:               first_span_size = line[&quot;spans&quot;][0][&quot;size&quot;]               if first_span_size &gt;= title_threshold:                   paragraph.style = doc.styles[&quot;Heading 2&quot;]               else:                   paragraph.style = doc.styles[&quot;Normal&quot;]   @staticmethod   def _add_image_to_doc(doc, img_data):       &quot;&quot;&quot;将图片添加到Word文档&quot;&quot;&quot;       try:           if os.path.exists(img_data[&quot;path&quot;]):               # 计算图片在Word中的尺寸（英寸）               # 72像素 = 1英寸               width_in_inches = img_data[&quot;width&quot;] / 72               height_in_inches = img_data[&quot;height&quot;] / 72               # 限制最大宽度为6英寸，保持比例               if width_in_inches &gt; 6:                   ratio = 6 / width_in_inches                   width_in_inches = 6                   height_in_inches *= ratio               # 添加图片               paragraph = doc.add_paragraph()               run = paragraph.add_run()               run.add_picture(img_data[&quot;path&quot;], width=Inches(width_in_inches),                              height=Inches(height_in_inches))               paragraph.alignment = WD_ALIGN_PARAGRAPH.CENTER  # 图片居中对齐       except Exception as e:           print(f&quot;添加图片到文档失败: &#123;e&#125;&quot;)   @staticmethod   def _int_to_rgb(color_int: int) -&gt; Tuple[int, int, int]:       &quot;&quot;&quot;将整数颜色值转换为RGB tuple&quot;&quot;&quot;       blue = color_int &amp; 0xff       green = (color_int &gt;&gt; 8) &amp; 0xff       red = (color_int &gt;&gt; 16) &amp; 0xff       return (red, green, blue)class ProcessingThread(QThread):   &quot;&quot;&quot;处理PDF文件的工作线程&quot;&quot;&quot;   finished = pyqtSignal(bool, str, str)  # 处理完成信号 (成功, 原文件路径, 结果文件路径)   progress_updated = pyqtSignal(str)  # 进度更新信号   def __init__(self, pdf_path: str, output_path: str):       super().__init__()       self.pdf_path = pdf_path       self.output_path = output_path   def run(self):       try:           self.progress_updated.emit(f&quot;正在提取PDF内容: &#123;os.path.basename(self.pdf_path)&#125;&quot;)           # 提取PDF信息           pdf_info = PDFProcessor.extract_full_pdf_info(self.pdf_path)           self.progress_updated.emit(f&quot;正在去除水印: &#123;os.path.basename(self.pdf_path)&#125;&quot;)           # 去除水印           clean_info = PDFProcessor.remove_watermark_by_alpha(pdf_info)           self.progress_updated.emit(f&quot;正在生成Word文档: &#123;os.path.basename(self.output_path)&#125;&quot;)           # 生成Word文档           PDFProcessor.generate_word_from_data(clean_info, self.output_path)           self.finished.emit(True, self.pdf_path, self.output_path)       except Exception as e:           error_msg = f&quot;处理失败: &#123;str(e)&#125;&quot;           print(error_msg)           self.progress_updated.emit(error_msg)           self.finished.emit(False, self.pdf_path, str(e))class PdfWatermarkRemoverApp(QWidget):   &quot;&quot;&quot;PDF水印去除工具主界面&quot;&quot;&quot;   def __init__(self):       super().__init__()       self.processing_queue = []  # 待处理文件队列       self.processed_count = 0  # 已处理文件数       self.total_files_to_process = 0  # 总文件数       self.success_count = 0  # 处理成功数       self.failure_count = 0  # 处理失败数       self.failed_files = []  # 处理失败的文件列表       self.processing_mode = None  # &#x27;file&#x27; 或 &#x27;folder&#x27;       self.overwrite_all = None  # None:未设置, True:全部覆盖, False:全部跳过       self.init_ui()   def init_ui(self):       &quot;&quot;&quot;初始化用户界面&quot;&quot;&quot;       self.setWindowTitle(&quot;PDF水印去除工具&quot;)       self.setFixedSize(750, 400)       # 设置中文字体       font = QFont()       font.setFamily(&quot;SimHei&quot;)       self.setFont(font)       main_layout = QVBoxLayout()       main_layout.setSpacing(15)       main_layout.setContentsMargins(20, 20, 20, 20)       # 标题       title_label = QLabel(&quot;PDF水印去除与Word转换工具&quot;)       title_font = QFont()       title_font.setFamily(&quot;SimHei&quot;)       title_font.setPointSize(14)       title_font.setBold(True)       title_label.setFont(title_font)       title_label.setAlignment(Qt.AlignCenter)       main_layout.addWidget(title_label)       # 分隔线       line = QFrame()       line.setFrameShape(QFrame.HLine)       line.setFrameShadow(QFrame.Sunken)       main_layout.addWidget(line)       # 文件选择区域       file_selection_layout = QVBoxLayout()       # 选择文件按钮       self.browse_files_button = QPushButton(&quot;选择文件...&quot;)       self.browse_files_button.setFont(font)       self.browse_files_button.clicked.connect(self.browse_pdf_files)       file_selection_layout.addWidget(self.browse_files_button)       # 选择文件夹按钮       self.browse_folder_button = QPushButton(&quot;选择文件夹...&quot;)       self.browse_folder_button.setFont(font)       self.browse_folder_button.clicked.connect(self.browse_folder)       file_selection_layout.addWidget(self.browse_folder_button)       # 选中的文件/文件夹显示       self.selected_path_label = QLabel(&quot;未选择任何文件或文件夹&quot;)       self.selected_path_label.setFont(font)       self.selected_path_label.setWordWrap(True)       file_selection_layout.addWidget(self.selected_path_label)       main_layout.addLayout(file_selection_layout)       # 处理按钮       self.process_button = QPushButton(&quot;开始处理&quot;)       self.process_button.setFont(font)       self.process_button.setMinimumHeight(40)       self.process_button.clicked.connect(self.start_processing)       self.process_button.setEnabled(False)  # 初始禁用       main_layout.addWidget(self.process_button)       # 进度显示区域       progress_layout = QVBoxLayout()       self.status_label = QLabel(&quot;等待选择文件/文件夹...&quot;)       self.status_label.setFont(font)       progress_layout.addWidget(self.status_label)       self.current_file_status_label = QLabel(&quot;&quot;)       self.current_file_status_label.setFont(font)       self.current_file_status_label.setWordWrap(True)       progress_layout.addWidget(self.current_file_status_label)       self.progress_bar = QProgressBar()       self.progress_bar.setValue(0)       progress_layout.addWidget(self.progress_bar)       main_layout.addLayout(progress_layout)       # 覆盖选项（默认隐藏）       self.overwrite_layout = QHBoxLayout()       self.overwrite_label = QLabel(&quot;文件已存在，是否覆盖？&quot;)       self.overwrite_label.setFont(font)       self.overwrite_layout.addWidget(self.overwrite_label)       self.overwrite_button = QPushButton(&quot;覆盖&quot;)       self.overwrite_button.setFont(font)       self.overwrite_button.clicked.connect(lambda: self.handle_overwrite_choice(True))       self.overwrite_layout.addWidget(self.overwrite_button)       self.skip_button = QPushButton(&quot;跳过&quot;)       self.skip_button.setFont(font)       self.skip_button.clicked.connect(lambda: self.handle_overwrite_choice(False))       self.overwrite_layout.addWidget(self.skip_button)       self.overwrite_all_checkbox = QCheckBox(&quot;对当前批次的所有冲突文件执行此操作&quot;)       self.overwrite_all_checkbox.setFont(font)       self.overwrite_all_checkbox.setVisible(False)       self.overwrite_layout.addWidget(self.overwrite_all_checkbox)       main_layout.addLayout(self.overwrite_layout)       self.overwrite_layout.setVisible(False)  # 默认隐藏       # 状态统计区域       self.stats_label = QLabel(&quot;处理统计: 0 成功, 0 失败&quot;)       self.stats_label.setFont(font)       main_layout.addWidget(self.stats_label)       # 底部说明       note_label = QLabel(&quot;说明: 处理后的文件将保存至源文件所在目录的 &#x27;_无水印&#x27; 子文件夹中&quot;)       note_font = QFont()       note_font.setFamily(&quot;SimHei&quot;)       note_font.setPointSize(9)       note_label.setFont(note_font)       note_label.setAlignment(Qt.AlignRight)       main_layout.addWidget(note_label)       self.setLayout(main_layout)   def browse_pdf_files(self):       &quot;&quot;&quot;浏览并选择PDF文件&quot;&quot;&quot;       file_paths, _ = QFileDialog.getOpenFileNames(self, &quot;选择PDF文件&quot;, &quot;&quot;, &quot;PDF文件 (*.pdf)&quot;)       if file_paths:           self.processing_mode = &quot;file&quot;           self.processing_queue = list(file_paths)           self.total_files_to_process = len(self.processing_queue)           self.selected_path_label.setText(f&quot;已选择 &#123;self.total_files_to_process&#125; 个PDF文件&quot;)           self.process_button.setEnabled(True)           self.reset_processing_stats()   def browse_folder(self):       &quot;&quot;&quot;浏览并选择文件夹&quot;&quot;&quot;       folder_path = QFileDialog.getExistingDirectory(self, &quot;选择包含 PDF 文件的文件夹&quot;)       if folder_path:           self.processing_mode = &quot;folder&quot;           # 查找文件夹中的所有PDF文件           pdf_files = []           for root, _, files in os.walk(folder_path):               for file in files:                   if file.lower().endswith(&#x27;.pdf&#x27;):                       pdf_files.append(os.path.join(root, file))           self.processing_queue = pdf_files           self.total_files_to_process = len(self.processing_queue)           self.selected_path_label.setText(               f&quot;已选择文件夹: &#123;folder_path&#125;n包含 &#123;self.total_files_to_process&#125; 个PDF文件&quot;)           self.process_button.setEnabled(self.total_files_to_process &gt; 0)           self.reset_processing_stats()   def reset_processing_stats(self):       &quot;&quot;&quot;重置处理统计信息&quot;&quot;&quot;       self.processed_count = 0       self.success_count = 0       self.failure_count = 0       self.failed_files = []       self.progress_bar.setValue(0)       self.stats_label.setText(&quot;处理统计: 0 成功, 0 失败&quot;)       self.status_label.setText(&quot;就绪，点击开始处理&quot;)       self.current_file_status_label.setText(&quot;&quot;)       self.overwrite_all = None   def start_processing(self):       &quot;&quot;&quot;开始处理文件队列&quot;&quot;&quot;       if not self.processing_queue or self.total_files_to_process == 0:           QMessageBox.information(self, &quot;提示&quot;, &quot;没有可处理的文件&quot;)           return       self.process_button.setEnabled(False)       self.browse_files_button.setEnabled(False)       self.browse_folder_button.setEnabled(False)       self.process_next_file()   def process_next_file(self):       &quot;&quot;&quot;处理队列中的下一个文件&quot;&quot;&quot;       if not self.processing_queue:           self.on_all_processing_finished()           return       current_pdf_path = self.processing_queue.pop(0)       pdf_filename = os.path.basename(current_pdf_path)       pdf_dir = os.path.dirname(current_pdf_path)       # 创建输出目录       output_dir = os.path.join(pdf_dir, pdf_filename.replace(&#x27;.pdf&#x27;, &#x27;&#x27;) + &quot;_无水印&quot;)       os.makedirs(output_dir, exist_ok=True)       # 构建输出文件路径       output_filename = os.path.splitext(pdf_filename)[0] + &quot;_无水印.docx&quot;       output_word_path = os.path.join(output_dir, output_filename)       # 检查文件是否已存在       if os.path.exists(output_word_path):           # 如果已设置全局覆盖策略，则直接应用           if self.overwrite_all is not None:               if not self.overwrite_all:                   # 跳过此文件                   self.current_file_status_label.setText(f&quot;已跳过已存在文件: &#123;pdf_filename&#125;&quot;)                   self.processed_count += 1                   self.update_progress()                   QApplication.processEvents()  # 更新界面                   self.process_next_file()                   return           else:               # 显示覆盖选择对话框               self.current_file_path = current_pdf_path               self.current_output_path = output_word_path               self.status_label.setText(f&quot;文件已存在: &#123;pdf_filename&#125;&quot;)               self.current_file_status_label.setText(&quot;请选择处理方式&quot;)               self.overwrite_layout.setVisible(True)               self.overwrite_all_checkbox.setVisible(True)               return       # 启动处理线程       self.status_label.setText(f&quot;正在处理第 &#123;self.processed_count + 1&#125; / &#123;self.total_files_to_process&#125; 个文件...&quot;)       self.current_file_status_label.setText(f&quot;正在处理: &#123;pdf_filename&#125;&quot;)       self.processing_thread = ProcessingThread(current_pdf_path, output_word_path)       self.processing_thread.finished.connect(self.on_file_processed)       self.processing_thread.progress_updated.connect(self.current_file_status_label.setText)       self.processing_thread.start()   def handle_overwrite_choice(self, overwrite: bool):       &quot;&quot;&quot;处理文件覆盖选择&quot;&quot;&quot;       self.overwrite_layout.setVisible(False)       # 检查是否需要应用到所有文件       if self.overwrite_all_checkbox.isChecked():           self.overwrite_all = overwrite       if overwrite:           # 继续处理当前文件，覆盖已存在文件           self.processing_thread = ProcessingThread(self.current_file_path, self.current_output_path)           self.processing_thread.finished.connect(self.on_file_processed)           self.processing_thread.progress_updated.connect(self.current_file_status_label.setText)           self.processing_thread.start()       else:           # 跳过当前文件           self.current_file_status_label.setText(f&quot;已跳过已存在文件: &#123;os.path.basename(self.current_file_path)&#125;&quot;)           self.processed_count += 1           self.update_progress()           self.process_next_file()   def on_file_processed(self, success: bool, file_path: str, result: str):       &quot;&quot;&quot;文件处理完成回调&quot;&quot;&quot;       filename = os.path.basename(file_path)       if success:           self.success_count += 1           self.current_file_status_label.setText(f&quot;处理成功: &#123;filename&#125; -&gt; &#123;os.path.basename(result)&#125;&quot;)       else:           self.failure_count += 1           self.failed_files.append(f&quot;&#123;filename&#125;: &#123;result&#125;&quot;)           self.current_file_status_label.setText(f&quot;处理失败: &#123;filename&#125; - &#123;result&#125;&quot;)       self.processed_count += 1       self.update_progress()       self.process_next_file()   def update_progress(self):       &quot;&quot;&quot;更新进度显示&quot;&quot;&quot;       progress_percentage = int((self.processed_count / self.total_files_to_process) * 100)       self.progress_bar.setValue(progress_percentage)       self.stats_label.setText(f&quot;处理统计: &#123;self.success_count&#125; 成功, &#123;self.failure_count&#125; 失败&quot;)   def on_all_processing_finished(self):       &quot;&quot;&quot;所有文件处理完成&quot;&quot;&quot;       self.status_label.setText(&quot;所有文件处理完成!&quot;)       self.current_file_status_label.setText(&quot;&quot;)       # 显示处理结果摘要       result_msg = f&quot;处理完成！共处理 &#123;self.total_files_to_process&#125; 个文件n&quot;       result_msg += f&quot;成功: &#123;self.success_count&#125; 个n&quot;       result_msg += f&quot;失败: &#123;self.failure_count&#125; 个&quot;       if self.failed_files:           result_msg += &quot;nn处理失败的文件：n&quot; + &quot;n&quot;.join(self.failed_files)       QMessageBox.information(self, &quot;处理完成&quot;, result_msg)       # 重置界面状态       self.process_button.setEnabled(True)       self.browse_files_button.setEnabled(True)       self.browse_folder_button.setEnabled(False)       self.overwrite_all = None       self.overwrite_all_checkbox.setChecked(False)if __name__ == &quot;__main__&quot;:   # 确保中文正常显示   import matplotlib   matplotlib.rcParams[&quot;font.family&quot;] = [&quot;SimHei&quot;, &quot;WenQuanYi Micro Hei&quot;, &quot;Heiti TC&quot;]   app = QApplication(sys.argv)   window = PdfWatermarkRemoverApp()   window.show()   sys.exit(app.exec_())\n\n以上代码实现了一个功能完整的 PDF 水印去除工具，包含了从 PDF 内容提取、水印识别与去除到 Word 文档生成的全流程。工具支持单个文件处理和文件夹批量处理，提供了友好的图形界面和详细的处理状态反馈。你可以直接使用这段代码，也可以根据实际需求进行进一步的定制和优化。\nPS:代码仅供参考，内容不一定正确，要根据实际情况处理喵\n","categories":["-Python -PDF -Word"],"tags":["Python","PyMuPDF","水印去除","PDF处理","PyQt5","Word"]}]