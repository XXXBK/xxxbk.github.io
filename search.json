[{"title":"Dify镜像源替换与服务启动","url":"/2025/07/15/Dify-%E9%83%A8%E7%BD%B2%E6%B5%81%E7%A8%8B%EF%BC%9A%E9%95%9C%E5%83%8F%E6%BA%90%E6%9B%BF%E6%8D%A2%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%90%AF%E5%8A%A8/","content":"Dify 部署流程：镜像源替换与服务启动\n一、Dify 镜像源替换操作\n批量替换镜像前缀&#xA;在 docker-compose.yaml 所在目录执行全局替换，添加 docker.1ms.run&#x2F; 前缀：\nsed -i &#x27;s/image: /image: docker.1ms.run\\\\//g&#x27; docker-compose.yaml\n\n特殊镜像路径修正&#xA;问题路径&#xA;image: docker.1ms.run/docker.elastic.co/elasticsearch/elasticsearch:8.14.3\n\n修正命令&#xA;sed -i &#x27;s|docker.1ms.run/docker.elastic.co/|docker.1ms.run/elastic/|g&#x27; docker-compose.yaml\n\n正确路径&#xA;image: docker.1ms.run/elastic/elasticsearch:8.14.3\n\n基础镜像补充替换&#xA;sed -i &#x27;s|image: postgres:|image: docker.1ms.run/postgres:|g&#x27; docker-compose.yamlsed -i &#x27;s|image: redis:|image: docker.1ms.run/redis:|g&#x27; docker-compose.yamlsed -i &#x27;s|image: nginx:|image: docker.1ms.run/nginx:|g&#x27; docker-compose.yaml\n\n二、部署前准备工作\n赋予挂载目录权限：\nchmod -R 777 ./volumes ./elasticsearch\n\n三、启动与验证 Dify 服务\n后台启动服务&#xA;docker-compose up -d\n\n验证服务状态&#xA;docker-compose ps  # 检查容器运行状态docker-compose logs -f  # 查看实时日志\n\n访问 Dify 界面&#xA;浏览器输入 http:&#x2F;&#x2F; 服务器 IP:3000，默认账号 admin@example.com，密码 password。\n四、部署过程常见问题\n镜像路径嵌套错误&#xA;问题&#xA;镜像路径包含 docker.1ms.run&#x2F;docker.elastic.co&#x2F; 嵌套结构。\n解决&#xA;使用 sed 精准替换：\nsed -i &#x27;s|docker.1ms.run/docker.elastic.co/|docker.1ms.run/elastic/|g&#x27; docker-compose.yaml\n\n权限不足导致启动失败&#xA;问题&#xA;挂载目录无读写权限。\n解决&#xA;递归设置目录权限：\nchmod -R 777 ./volumes\n\n服务启动异常&#xA;解决&#xA;通过日志排查问题：&#x20;\ndocker-compose logs -f  # 查看所有服务日志docker-compose logs dify-api  # 查看指定服务日志\n\n五、核心操作总结\n镜像替换流程&#xA;全局前缀替换 → 特殊镜像路径修正 → 基础镜像补充替换\n启动验证流程&#xA;docker-compose up -d → docker-compose ps → 访问 Web 界面\n关键命令&#xA;sed -i &#x27;s/image: /image: docker.1ms.run\\\\//g&#x27; docker-compose.yamlchmod -R 777 ./volumesdocker-compose up -d","categories":["Dify"],"tags":["Dify","镜像源"]},{"title":"Portainer容器管理实战：从镜像加速到安全部署","url":"/2025/07/15/Portainer%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86%E5%AE%9E%E6%88%98%EF%BC%9A%E4%BB%8E%E9%95%9C%E5%83%8F%E5%8A%A0%E9%80%9F%E5%88%B0%E5%AE%89%E5%85%A8%E9%83%A8%E7%BD%B2/","content":"一、背景：为什么选择从第三方镜像源拉取 Portainer？\n近期在学习容器管理工具 Portainer 时，参考了一篇技术教程（知乎链接：https://zhuanlan.zhihu.com&#x2F;p&#x2F;27740131259），教程中推荐使用官方镜像源部署。但由于网络环境限制，尝试从第三方镜像源docker.1ms.run拉取 Portainer 镜像，意外发现该镜像源提供了更稳定的下载速度，因此记录下完整操作流程，供遇到类似问题的开发者参考。\n二、操作步骤：从镜像拉取到容器启动的全流程\n1. 拉取 Portainer 镜像&#xA;通常情况下，Portainer 官方镜像的拉取命令为：\ndocker pull portainer/portainer-ce:latest\n\n但本次尝试使用第三方镜像源：\ndocker pull docker.1ms.run/portainer/portainer-ce:latest\n\n执行结果：\nUsing default tag: latestlatest: Pulling from portainer/portainer-ce63c930229559: Pull complete&amp;#x20;d3b1c06ebf8c: Pull complete&amp;#x20;...（中间层拉取省略）Digest: sha256:224a378fbc5ae579dc9d570c5ca2e5e981a4a003c8d7c2c5b5e482af97c2f87cStatus: Downloaded newer image for docker.1ms.run/portainer/portainer-ce:latest\n\n注意事项：\n\n第三方镜像源可能存在安全风险，建议优先使用官方镜像（portainer/portainer-ce）。\n\n若拉取失败，可检查镜像源是否可用（如执行ping docker.1ms.run），或切换至国内加速源（如 Docker 中国镜像站）。\n\n\n2. 验证镜像是否成功拉取&#xA;通过docker images命令查看本地镜像列表：\ndocker images\n\n输出结果：\nREPOSITORY                              TAG       IMAGE ID       CREATED       SIZEdocker.1ms.run/portainer/portainer-ce   latest    71de3839351a   2 days ago    268MB\n\n3. 启动 Portainer 容器&#xA;使用以下命令启动容器，并配置挂载与端口映射：\ndocker run -d \\\\&amp;#x20; \\--name portainer \\\\&amp;#x20; -p 9000:9000 \\\\&amp;#x20; -v /var/run/docker.sock:/var/run/docker.sock \\\\&amp;#x20; -v portainer\\_data:/data \\\\&amp;#x20; \\--restart=always \\\\&amp;#x20; docker.1ms.run/portainer/portainer-ce:latest\n\n参数解析：\n\n-d：后台运行容器；\n\n-p 9000:9000：映射宿主机 9000 端口到容器 9000 端口，用于访问 Web 界面；\n\n-v /var/run/docker.sock:/var/run/docker.sock：挂载 Docker 套接字，允许 Portainer 管理宿主机 Docker 环境；\n\n-v portainer_data:/data：创建数据卷持久化存储 Portainer 配置；\n\n--restart=always：确保容器随系统重启自动运行。\n\n\n4. 访问 Portainer Web 界面&#xA;容器启动后，在浏览器中输入http://宿主机IP:9000，首次访问需设置管理员密码，随后进入 Portainer 管理界面。\n三、遇到的问题与解决方案\n1. 镜像拉取失败：manifest unknown&#xA;错误信息：\nError response from daemon: manifest for docker.1ms.run/portainer-ce:latest not found: manifest unknown\n\n原因：\n镜像源中无该镜像，或镜像名称拼写错误（如portainer-ce写成portainer）。\n解决方法：\n确认镜像名称正确性，或更换为官方镜像源拉取：\ndocker pull portainer/portainer-ce:latest\n\n2. Docker Hub 连接超时&#xA;错误信息：\nError response from daemon: Get &quot;https://registry-1.docker.io/v2/&quot;: context deadline exceeded\n\n解决方法：\n配置国内镜像加速源，编辑/etc/docker/daemon.json添加：\n&#123;&amp;#x20; &quot;registry-mirrors&quot;: \\[&quot;https://registry.docker-cn.com&quot;, &quot;https://docker.mirrors.ustc.edu.cn&quot;]&#125;\n\n重启 Docker 服务：sudo systemctl restart docker。\n四、使用第三方镜像源的风险与建议\n\n安全风险：第三方镜像源可能被篡改，建议优先使用官方镜像（portainer/portainer-ce）。\n\n版本兼容性：第三方镜像可能非最新版本，建议定期通过docker pull更新镜像。\n\n网络稳定性：若第三方源频繁失效，优先使用官方源或国内大厂加速源（如阿里云、腾讯云镜像站）。\n\n\n五、总结：Portainer 的价值与容器管理实践\n通过 Docker 部署 Portainer 后，可直观管理容器、镜像、网络及数据卷，尤其适合新手快速上手容器化部署。本次从第三方镜像源拉取的经历表明：技术实践中需在效率与安全性间权衡，建议在测试环境尝试非官方源，生产环境务必使用官方可信镜像。\n后续可进一步探索 Portainer 的 Kubernetes 管理、RBAC 权限控制等高级功能，提升容器化应用的部署与运维效率。\n","categories":["Docker实践"],"tags":["Docker","Portainer","镜像加速","容器管理"]},{"title":"Python 魔法：一键让 Excel 正确选项「脸红」","url":"/2025/07/15/Python-%E9%AD%94%E6%B3%95%EF%BC%9A%E4%B8%80%E9%94%AE%E8%AE%A9-Excel-%E6%AD%A3%E7%A1%AE%E9%80%89%E9%A1%B9%E3%80%8C%E8%84%B8%E7%BA%A2%E3%80%8D/","content":"在数据处理工作中，我们经常需要处理 Excel 文件中的试题数据，特别是需要对正确答案进行特殊标记。本文将分享我从最初实现到最终优化的完整改进过程。\n初始需求\n我们需要处理一个包含试题的 Excel 文件，具体要求：\n\n文件包含 “试题选项” 和 “试题答案” 两列\n\n试题选项用 “$$;$“ 分隔多个选项\n\n需要根据 “试题答案” 将正确答案标记为红色\n\n处理后的结果直接修改原文件\n\n\n第一版实现\n核心思路：&#xA;\n使用 pandas 读取 Excel 文件\n\n用 openpyxl 修改原文件样式\n\n在正确答案前后添加 “**“ 标记\n\n提示用户手动替换 “**“ 为红色格式\n\n\n\\# 主要处理逻辑marked\\_options = \\[]for i, option in enumerate(options):&amp;#x20;   if i in correct\\_indices:&amp;#x20;       marked\\_options.append(f&quot;\\*\\*&#123;option&#125;\\*\\*&quot;)  # 用\\*\\*标记正确答案&amp;#x20;   else:&amp;#x20;       marked\\_options.append(option)cell.value = &#x27;\\$;\\$&#x27;.join(marked\\_options)\n\n问题：\n不能自动设置红色，需要用户手动替换，** 的标记方式不够直观\n第二版改进\n改进点：&#xA;\n改用 xlsxwriter 引擎\n\n直接处理 ** 标记的内容并设置为红色\n\n保留 ** 标记\n\n\n\\# 使用正则匹配\\*\\*内容并设置格式for match in re.finditer(r&#x27;\\\\\\\\\\\\\\*\\\\\\\\\\\\\\*(.\\*?)\\\\\\\\\\\\\\*\\\\\\\\\\\\\\*&#x27;, cell\\_value):&amp;#x20;   parts.append(&#123;&amp;#x20;       &#x27;text&#x27;: f&quot;\\*\\*&#123;match.group(1)&#125;\\*\\*&quot;,&amp;#x20;       &#x27;format&#x27;: red\\_format&amp;#x20;   &#125;)\n\n问题：\n使用 ** 将正确答案括起来的话，xlsxwriter 无法非常准确地解析出来，因为答案可能是 A$;$B$;$C$;$D 这样子的，相同的符号会干扰它的判断，从而导致效果不好\n最终版改进\n改进思路：&#xA;\n改回使用 openpyxl\n\n正确答案用 [] 标记\n\n非正确答案不做标记\n\n\nmarked\\_options = \\[]for i, option in enumerate(options):&amp;#x20;   if i in correct\\_indices:&amp;#x20;       marked\\_options.append(f&quot;\\[&#123;option&#125;]&quot;) # 正确答案标记&amp;#x20;   else:&amp;#x20;       marked\\_options.append(option)\n\n然后再进行标红处理：\n\n使用富文本 (CellRichText) 直接设置红色\n\n自动移除 [] 标记\n\n添加异常处理，失败时回退到普通文本\n\n更友好的提示信息\n\n\n\\# 富文本处理核心代码rich\\_text = CellRichText()for i, option in enumerate(options):&amp;#x20;   if i &gt; 0:&amp;#x20;       rich\\_text.append(&#x27;\\$;\\$&#x27;)&amp;#x20;   clean\\_option = option.replace(&#x27;\\[&#x27;, &#x27;&#x27;).replace(&#x27;]&#x27;, &#x27;&#x27;)&amp;#x20;   if i in correct\\_indices:&amp;#x20;       rich\\_text.append(TextBlock(inline\\_red\\_font, clean\\_option))&amp;#x20;   else:&amp;#x20;       rich\\_text.append(clean\\_option)cell.value = rich\\_text\n\n关键改进点：&#xA;\n富文本支持：使用 CellRichText 和 TextBlock 实现对单个字符的样式设置\n\n自动清理：移除选项中的 [] 标记\n\n\n拓展功能：标记检查与统一分隔符\n在最终版的基础上，我进一步完善了代码，增加了两项重要的功能：统一处理非标准分隔符和全面的标记检查报告。这使得整个流程更加健壮和智能化。\n1. 统一分隔符&#xA;很多时候，Excel 中的选项分隔符可能不统一，除了标准的$;$，还可能出现$;、$$等，甚至单空格加 $ 等多种形式。为了确保选项能够被正确解析，我加入了强大的正则表达式来识别并统一这些非标准分隔符为 $;$。\n实现方式：使用 re.compile 定义了一个详细的正则表达式 separator_pattern，涵盖了多种常见的非标准分隔符。\n效果：在处理每个选项字符串时，首先使用 separator_pattern.sub (‘$;$’, options_str) 将所有识别到的非标准分隔符统一替换为 $;$ 。这大大提高了数据处理的鲁棒性，减少了因格式不一致导致的问题。\n\\# 正则表达式定义（部分）separator\\_pattern = re.compile(r&#x27;&#x27;&#x27;&amp;#x20;   \\$;\\$|       # 标准 \\$;\\$ \\[cite: 3]&amp;#x20;   \\$:：\\$|   # \\$:\\$ 或 \\$：\\$ \\[cite: 4]&amp;#x20;   ;\\$|         # ;\\$ \\[cite: 5]&amp;#x20;   \\$；|        # \\$； \\[cite: 6]&amp;#x20;   \\[；:：]\\$|   # ；\\$ 或 ：\\$ \\[cite: 7]&amp;#x20;   $\\[;；:：]|  # \\$; 或 \\$；或 \\$: 或 \\$： \\[cite: 8]&amp;#x20;   \\$\\$|        # \\$\\$ \\[cite: 9]&amp;#x20;   \\s&#123;2,&#125;|      # 两个或更多空格 \\[cite: 10]&amp;#x20;   \\$\\s|\\s\\$|   # \\$ 后或前有单个空格 \\[cite: 11]&amp;#x20;   ;           # 单独的分号 \\[cite: 12]&#x27;&#x27;&#x27;, re.VERBOSE)\\# 在处理选项字符串时进行替换modified\\_str = separator\\_pattern.sub(&#x27;\\$;\\$&#x27;, options\\_str)\n\n2. 标记检查报告&#xA;仅仅对正确答案进行标记是不够的，我们还需要验证标记是否正确、是否有遗漏。此功能可以生成详细的报告，指出 “正确答案未被标记” 和 “错误答案被标记” 的情况。\n核心逻辑优化：&#xA;\n未标记检查：传统的检查方法是看 “标记索引” 中是否包含正确答案的索引。但如果正确答案完全没有被标记（即选项中根本没有 []），这种方法就无法识别。新的逻辑直接检查正确答案的选项内容是否被 [] 包裹 。只要正确答案未被 [] 包裹，无论是否有其他标记动作，都会被识别为 “未标记” 。\n\n错误标记检查：检查所有被 [] 包裹的选项，如果其索引不在正确答案的索引列表中，则视为错误标记 。\n\n\n输出报告：&#xA;生成清晰的报告，包含：\n\n检查的总行数 。\n\n“未标记正确答案的行” 数量及具体详情（Excel 行号、应标记的字母、未被包裹的实际内容） 。\n\n“错误标记的行” 数量及具体详情（Excel 行号、错误标记的内容、正确的答案） 。\n\n\n\\# 未标记行检查的核心代码has\\_unmarked = Falsefor i in correct\\_indices:&amp;#x20;   opt = options\\[i]&amp;#x20;   \\# 直接检查正确答案是否被\\[]包裹&amp;#x20;&amp;#x20;   if not (opt.strip().startswith(&#x27;\\[&#x27;) and opt.strip().endswith(&#x27;]&#x27;)):&amp;#x20;       has\\_unmarked = True&amp;#x20;       breakif has\\_unmarked: # \\[cite: 16]&amp;#x20;   unmarked\\_rows.append(&#123;&amp;#x20;       &#x27;row&#x27;: row\\_num,&amp;#x20;       &#x27;expected&#x27;: \\[chr(65 + i) for i in correct\\_indices],&amp;#x20;       &#x27;actual&#x27;: \\[options\\[i].strip() for i in correct\\_indices]&amp;#x20;   &#125;)\\# 错误标记行检查的核心代码marked\\_indices = \\[]for i, opt in enumerate(options):&amp;#x20;   if opt.strip().startswith(&#x27;\\[&#x27;) and opt.strip().endswith(&#x27;]&#x27;):&amp;#x20;       marked\\_indices.append(i)  # 记录被标记的索引for i in marked\\_indices: #&amp;#x20;&amp;#x20;   if i not in correct\\_indices:&amp;#x20;       wrong\\_marking.append(&#123;&amp;#x20;           &#x27;row&#x27;: row\\_num,&amp;#x20;           &#x27;wrong\\_marked&#x27;: options\\[i].strip(),&amp;#x20;           &#x27;correct&#x27;: \\[chr(65 + i) for i in correct\\_indices] #&amp;#x20;&amp;#x20;       &#125;)&amp;#x20;       break # 只要有一个错误标记就记录\n\n验证示例：&#xA;如果一个 Excel 行的正确答案是 D，但选项 D 没有被 [] 包裹，运行代码后会输出：\n\\=== 标记检查报告 ===共检查 1000 行数据1\\. 未标记正确答案的行: 1 行&amp;#x20; 行X: 应标记\\[&#x27;D&#x27;]（内容：D、财务收支审批人员的奖惩办法）未被\\[]包裹2\\. 错误标记的行: 0 行\n\n这使得我们能够精准识别 “应该标记但完全没标记” 的情况 。\n\n（注：文档部分内容可能由 AI 生成）\n\n","categories":["Excel技巧","Python","数据处理"],"tags":["Excel处理","Pandas","Python","Openpyxl","Xlsxwriter","正则表达式"]},{"title":"从零开始的爬虫生活（一）：环境搭建与基础库应用","url":"/2025/07/15/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84%E7%88%AC%E8%99%AB%E7%94%9F%E6%B4%BB%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E5%9F%BA%E7%A1%80%E5%BA%93%E5%BA%94%E7%94%A8/","content":"从零开始的爬虫生活（一）：环境搭建与基础库应用\n一、环境搭建\n在开始学习爬虫之前，我们需要先搭建好开发环境。以下是一些常用的工具和库：\n1. Python 环境&#xA;确保已经安装了 Python 3.x 版本。可以前往 Python 官网 下载安装。\n2. 常用库安装&#xA;使用 pip 命令安装以下库：\npip install seleniumpip install beautifulsoup4pip install pyquerypip install pymysqlpip install pymongopip install redis\n\n3. 浏览器驱动&#xA;\nChromeDriver：根据你使用的 Chrome 浏览器版本，下载对应的 ChromeDriver。\n\nPhantomJS（已弃用）：在 Selenium 4.x 中已移除，建议使用无头模式的 Chrome。\n\n\n配置 Chrome 无头模式示例：\nfrom selenium import webdriverfrom selenium.webdriver.chrome.options import Options\\# 配置 Chrome 为无头模式chrome\\_options = Options()chrome\\_options.add\\_argument(&quot;--headless&quot;)  # 无头模式，不显示浏览器窗口\\# 创建 Chrome 浏览器实例driver = webdriver.Chrome(options=chrome\\_options)driver.get(&quot;https://www.example.com&quot;)print(driver.title)driver.quit()\n\n二、基础库应用\n1. BeautifulSoup 库&#xA;BeautifulSoup 是一个用于解析 HTML 和 XML 文档的库。示例：\nfrom bs4 import BeautifulSouphtml\\_doc = &quot;&quot;&quot;\\&lt;html&gt;&amp;#x20;   \\&lt;head&gt;&amp;#x20;       \\&lt;title&gt;示例页面\\&lt;/title&gt;&amp;#x20;   \\&lt;/head&gt;&amp;#x20;   \\&lt;body&gt;&amp;#x20;       \\&lt;h1&gt;标题\\&lt;/h1&gt;&amp;#x20;       \\&lt;p&gt;段落内容\\&lt;/p&gt;&amp;#x20;   \\&lt;/body&gt;\\&lt;/html&gt;&quot;&quot;&quot;soup = BeautifulSoup(html\\_doc, &#x27;html.parser&#x27;)print(soup.title.string)  # 输出标题内容\n\n2. PyQuery 库&#xA;PyQuery 是一个类 jQuery 的 Python 库，用于操作 HTML 文档。示例：\nfrom pyquery import PyQuery as pqhtml\\_doc = &quot;&quot;&quot;\\&lt;html&gt;&amp;#x20;   \\&lt;head&gt;&amp;#x20;       \\&lt;title&gt;示例页面\\&lt;/title&gt;&amp;#x20;   \\&lt;/head&gt;&amp;#x20;   \\&lt;body&gt;&amp;#x20;       \\&lt;h1&gt;标题\\&lt;/h1&gt;&amp;#x20;       \\&lt;p&gt;段落内容\\&lt;/p&gt;&amp;#x20;   \\&lt;/body&gt;\\&lt;/html&gt;&quot;&quot;&quot;doc = pq(html\\_doc)print(doc(&#x27;title&#x27;).text())  # 输出标题内容\n\n3. Requests 库&#xA;Requests 是一个简单的 HTTP 库，用于发送网络请求。示例：\nimport requestsurl = &quot;https://www.example.com&quot;response = requests.get(url)print(response.text)  # 输出网页内容\n\n三、数据存储\n1. MySQL 数据库&#xA;使用 PyMySQL 连接和操作 MySQL 数据库：\nimport pymysqlconn = pymysql.connect(&amp;#x20;   host=&#x27;localhost&#x27;,&amp;#x20;   user=&#x27;root&#x27;,&amp;#x20;   password=&#x27;123456&#x27;,&amp;#x20;   port=3306,&amp;#x20;   db=&#x27;mysql&#x27;)cursor = conn.cursor()cursor.execute(&#x27;SELECT \\* FROM db&#x27;)print(cursor.fetchone())conn.close()\n\n2. MongoDB 数据库&#xA;使用 PyMongo 连接和操作 MongoDB 数据库：\nimport pymongoclient = pymongo.MongoClient(&#x27;localhost&#x27;)db = client\\[&#x27;newtestdb&#x27;]db\\[&#x27;table&#x27;].insert\\_one(&#123;&#x27;name&#x27;: &#x27;Bob&#x27;&#125;)result = db\\[&#x27;table&#x27;].find\\_one(&#123;&#x27;name&#x27;: &#x27;Bob&#x27;&#125;)print(result)\n\n3. Redis 数据库&#xA;使用 RedisPy 连接和操作 Redis 数据库：\nimport redisr = redis.Redis(&#x27;localhost&#x27;, 6379)r.set(&#x27;name&#x27;, &#x27;Bob&#x27;)result = r.get(&#x27;name&#x27;)print(result)\n\n四、爬虫基本流程\n爬虫的基本流程如下：\n\n发送请求：使用 Requests 库发送 HTTP 请求获取网页内容。\n\n解析响应：使用 BeautifulSoup 或 PyQuery 库解析网页内容，提取所需数据。\n\n保存数据：将提取的数据存储到数据库或文件中。\n\n\n示例：爬取猫眼电影 TOP100\nimport requestsimport reimport jsonfrom multiprocessing import Pooldef get\\_one\\_page(url):&amp;#x20;   headers = &#123;&amp;#x20;       &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/137.0.0.0 Safari/537.36 Edg/137.0.0.0&#x27;&amp;#x20;   &#125;&amp;#x20;   response = requests.get(url, headers=headers)&amp;#x20;   if response.status\\_code == 200:&amp;#x20;       return response.text&amp;#x20;   return Nonedef parse\\_one\\_page(html):&amp;#x20;   pattern = re.compile(&#x27;\\&lt;dd&gt;.\\*?board-index.\\*?&gt;(\\d+)\\&lt;/i&gt;.\\*?data-src=&quot;(.\\*?)&quot;.\\*?name&quot;&gt;\\&lt;a&#x27;&amp;#x20;                        \\+ &#x27;.\\*?&gt;(.\\*?)\\&lt;/a&gt;.\\*?star&quot;&gt;(.\\*?)\\&lt;/p&gt;.\\*?releasetime&quot;&gt;(.\\*?)\\&lt;/p&gt;&#x27;&amp;#x20;                        \\+ &#x27;.\\*?integer&quot;&gt;(.\\*?)\\&lt;/i&gt;.\\*?fraction&quot;&gt;(.\\*?)\\&lt;/i&gt;.\\*?\\&lt;/dd&gt;&#x27;, re.S)&amp;#x20;   items = re.findall(pattern, html)&amp;#x20;   for item in items:&amp;#x20;       yield &#123;&amp;#x20;           &#x27;index&#x27;: item\\[0],&amp;#x20;           &#x27;image&#x27;: item\\[1],&amp;#x20;           &#x27;title&#x27;: item\\[2],&amp;#x20;           &#x27;actor&#x27;: item\\[3].strip()\\[3:],&amp;#x20;           &#x27;time&#x27;: item\\[4].strip()\\[5:],&amp;#x20;           &#x27;score&#x27;: item\\[5] + item\\[6]&amp;#x20;       &#125;def write\\_to\\_file(content):&amp;#x20;   with open(&#x27;result.txt&#x27;, &#x27;a&#x27;, encoding=&#x27;utf-8&#x27;) as f:&amp;#x20;       f.write(json.dumps(content, ensure\\_ascii=False) + &#x27;\\n&#x27;)def main(offset):&amp;#x20;   url = &#x27;http://maoyan.com/board/4?offset=&#x27; + str(offset)&amp;#x20;   html = get\\_one\\_page(url)&amp;#x20;   for item in parse\\_one\\_page(html):&amp;#x20;       print(item)&amp;#x20;       write\\_to\\_file(item)if \\_\\_name\\_\\_ == &#x27;\\_\\_main\\_\\_&#x27;:&amp;#x20;   pool = Pool()&amp;#x20;   pool.map(main, \\[i \\* 10 for i in range(10)])\n\n五、动态网页处理\n对于动态加载的网页，可以使用 Selenium 模拟浏览器操作。示例：\nfrom selenium import webdriverfrom selenium.webdriver.common.by import Bydriver = webdriver.Chrome()driver.get(&#x27;https://www.taobao.com&#x27;)input = driver.find\\_element(By.ID, &#x27;q&#x27;)input.send\\_keys(&#x27;美食&#x27;)button = driver.find\\_element(By.CLASS\\_NAME, &#x27;btn-search&#x27;)button.click()driver.quit()\n\n六、爬虫框架\n1. Scrapy 框架&#xA;Scrapy 是一个强大的爬虫框架，可以简化爬虫开发过程。安装命令：\npip install scrapy\n","categories":["爬虫教程"],"tags":["Python爬虫","数据抓取","Selenium","BeautifulSoup","数据存储"]}]