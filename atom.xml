<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2025-07-17T07:21:58.663Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>XXXBK</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《水印处理的成长日记：从0开始的PDF处理之路》</title>
    <link href="http://example.com/2025/07/16/%E3%80%8A%E6%B0%B4%E5%8D%B0%E5%A4%84%E7%90%86%E7%9A%84%E6%88%90%E9%95%BF%E6%97%A5%E8%AE%B0%EF%BC%9A%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84PDF%E5%A4%84%E7%90%86%E4%B9%8B%E8%B7%AF%E3%80%8B/"/>
    <id>http://example.com/2025/07/16/%E3%80%8A%E6%B0%B4%E5%8D%B0%E5%A4%84%E7%90%86%E7%9A%84%E6%88%90%E9%95%BF%E6%97%A5%E8%AE%B0%EF%BC%9A%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84PDF%E5%A4%84%E7%90%86%E4%B9%8B%E8%B7%AF%E3%80%8B/</id>
    <published>2025-07-16T10:02:16.000Z</published>
    <updated>2025-07-17T07:21:58.663Z</updated>
    
    <content type="html"><![CDATA[<p>在日常办公和学习中，我们经常会遇到带有水印的 PDF 文档，这些水印不仅影响阅读体验，还可能干扰文档的二次编辑和使用。本文将带你从零开始，一步步构建一个功能完善的 PDF 水印去除工具，实现从单文件处理到批量转换的完整解决方案。</p><p>需求分析：为什么需要 PDF 水印去除工具</p><p>PDF 水印通常分为可见水印和不可见水印两类。可见水印多以文字、Logo 等形式存在，虽然不影响内容的可读性，但在文档分发、打印等场景下会显得不够专业。特别是一些带有 “内部资料”、”草稿” 等字样的水印，在正式场合使用时需要去除。</p><p>理想的 PDF 水印去除工具应具备以下功能：</p><ul><li><p>精准识别并去除各类可见水印</p></li><li><p>保留原文档的文本格式和图片内容</p></li><li><p>支持批量处理多个 PDF 文件</p></li><li><p>提供直观易用的图形界面</p></li><li><p>输出格式支持 Word，方便后续编辑</p></li></ul><p>基础版本：实现单文件水印去除功能</p><p>我们先从基础版本开始，搭建一个能够处理单个 PDF 文件的水印去除工具。这个版本将实现水印识别、内容提取和格式转换的核心功能。</p><h3 id="核心技术选型-xA"><a href="#核心技术选型-xA" class="headerlink" title="核心技术选型&#xA;"></a>核心技术选型&#xA;</h3><p>实现 PDF 水印去除需要用到以下关键库：</p><ul><li><p><code>fitz</code>（PyMuPDF）：用于 PDF 文件的解析和内容提取</p></li><li><p><code>python-docx</code>：用于生成 Word 格式的输出文件</p></li><li><p><code>PIL</code>（Pillow）：用于处理 PDF 中的图片内容</p></li><li><p><code>PyQt5</code>：用于构建图形用户界面</p></li></ul><h3 id="核心功能实现-xA"><a href="#核心功能实现-xA" class="headerlink" title="核心功能实现&#xA;"></a>核心功能实现&#xA;</h3><p>基础版本的核心功能主要分为三个模块：PDF 信息提取、水印识别与去除、Word 文档生成。</p><h4 id="PDF-信息提取模块-xA"><a href="#PDF-信息提取模块-xA" class="headerlink" title="PDF 信息提取模块&#xA;"></a>PDF 信息提取模块&#xA;</h4><p><code>extract_full_pdf_info</code>函数负责从 PDF 中提取文本内容、图片和格式信息：</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">def extract_full_pdf_info(pdf_path: str) -&gt; List[Dict[str, Any]]:</span><br><span class="line">    if not os.path.exists(pdf_path):</span><br><span class="line">        raise FileNotFoundError(f&quot;PDF文件未找到: &#123;pdf_path&#125;&quot;)</span><br><span class="line">    doc = fitz.open(pdf_path)</span><br><span class="line">    full_info = []</span><br><span class="line">    temp_image_dir = os.path.abspath(&quot;temp_pdf_images&quot;)</span><br><span class="line">    os.makedirs(temp_image_dir, exist_ok=True)</span><br><span class="line">    for page_num in range(len(doc)):</span><br><span class="line">        page = doc[page_num]</span><br><span class="line">        page_data = &#123;</span><br><span class="line">            &quot;page_number&quot;: page_num + 1,</span><br><span class="line">            &quot;page_size&quot;: &#123;&quot;width&quot;: page.rect.width, &quot;height&quot;: page.rect.height&#125;,</span><br><span class="line">            &quot;rotation&quot;: page.rotation,</span><br><span class="line">            &quot;text_content&quot;: [],</span><br><span class="line">            &quot;images&quot;: []</span><br><span class="line">        &#125;</span><br><span class="line">        # 提取文本内容</span><br><span class="line">        text_blocks = page.get_text(&quot;dict&quot;)[&quot;blocks&quot;]</span><br><span class="line">        for block in text_blocks:</span><br><span class="line">            if block[&quot;type&quot;] == 0:  # 文本块</span><br><span class="line">                # 处理文本块、行和文字片段...</span><br><span class="line">        # 提取图片</span><br><span class="line">        images = page.get_images(full=True)</span><br><span class="line">        # 处理图片提取、软掩码合并和格式转换...</span><br><span class="line">        full_info.append(page_data)</span><br><span class="line">    doc.close()</span><br><span class="line">    return full_info</span><br></pre></td></tr></table></figure></div><h4 id="水印识别与去除模块-xA"><a href="#水印识别与去除模块-xA" class="headerlink" title="水印识别与去除模块&#xA;"></a>水印识别与去除模块&#xA;</h4><p><code>remove_watermark_by_alpha</code>函数通过分析文本的透明度、字体大小和颜色来识别并去除水印：</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">def remove_watermark_by_alpha(full_info: List[Dict[str, Any]]) -&gt; List[Dict[str, Any]]:</span><br><span class="line">    clean_full_info = []</span><br><span class="line">    watermark_removed_count = 0</span><br><span class="line">    ALPHA_THRESHOLD = 150  # 透明度阈值</span><br><span class="line">    TARGET_FONT_SIZE = 18  # 水印字体大小</span><br><span class="line">    FONT_SIZE_TOLERANCE = 1  # 字体大小容差</span><br><span class="line">    TARGET_COLOR_INT_VALUE = 13882323  # 水印颜色值</span><br><span class="line">    for page in full_info:</span><br><span class="line">        clean_text_blocks = []</span><br><span class="line">        for text_block in page[&quot;text_content&quot;]:</span><br><span class="line">            # 处理文本块，过滤水印内容...</span><br><span class="line">            watermark_removed_count += 1  # 统计去除的水印数量</span><br><span class="line">        clean_page = &#123;**page, &quot;text_content&quot;: clean_text_blocks, &quot;images&quot;: page[&quot;images&quot;]&#125;</span><br><span class="line">        clean_full_info.append(clean_page)</span><br><span class="line">    print(f&quot;水印移除完成。共移除 &#123;watermark_removed_count&#125; 处水印文本。&quot;)</span><br><span class="line">    return clean_full_info</span><br></pre></td></tr></table></figure></div><h4 id="Word-文档生成模块-xA"><a href="#Word-文档生成模块-xA" class="headerlink" title="Word 文档生成模块&#xA;"></a>Word 文档生成模块&#xA;</h4><p><code>generate_word_from_data</code>函数将清理后的内容转换为 Word 文档：</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def generate_word_from_data(clean_info: List[Dict[str, Any]], output_word_path: str) -&gt; None:</span><br><span class="line">    doc = Document()</span><br><span class="line">    font_mapping = get_system_font_mapping()  # 字体映射表</span><br><span class="line">    # 收集并排序文本和图片元素...</span><br><span class="line">    # 生成Word内容，保留原格式...</span><br><span class="line">    try:</span><br><span class="line">        doc.save(output_word_path)</span><br><span class="line">        print(f&quot;Word文档已保存至：&#123;output_word_path&#125;&quot;)</span><br><span class="line">    except Exception as e:</span><br><span class="line">       print(f&quot;保存Word文档失败：&#123;e&#125;&quot;)</span><br></pre></td></tr></table></figure></div><h3 id="基础版本界面设计-xA"><a href="#基础版本界面设计-xA" class="headerlink" title="基础版本界面设计&#xA;"></a>基础版本界面设计&#xA;</h3><p>基础版本采用简洁的图形界面，主要包含文件选择、处理和状态显示功能：</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class PdfWatermarkRemoverApp(QWidget):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        super().__init__()</span><br><span class="line">        self.setWindowTitle(&quot;PDF水印移除工具&quot;)</span><br><span class="line">        self.setFixedSize(750, 400)</span><br><span class="line">        self.init_ui()</span><br><span class="line">        # 初始化其他属性...</span><br><span class="line">    def init_ui(self):</span><br><span class="line">        main_layout = QVBoxLayout()</span><br><span class="line">        # 设置布局、添加文件选择框、处理按钮和状态标签...</span><br><span class="line">    def browse_pdf_file(self):</span><br><span class="line">        # 打开文件对话框，选择PDF文件...</span><br><span class="line">    def start_processing(self):</span><br><span class="line">        # 开始处理PDF文件...</span><br></pre></td></tr></table></figure></div><p>优化版本：功能增强与体验提升</p><p>在基础版本的基础上，我们进一步优化功能，增加批量处理能力，提升用户体验，打造一个更实用的工具。</p><h3 id="核心功能改进-xA"><a href="#核心功能改进-xA" class="headerlink" title="核心功能改进&#xA;"></a>核心功能改进&#xA;</h3><p>优化版本主要在以下几个方面进行了改进：</p><h4 id="1-增加文件夹批量处理功能-xA"><a href="#1-增加文件夹批量处理功能-xA" class="headerlink" title="1. 增加文件夹批量处理功能&#xA;"></a>1. 增加文件夹批量处理功能&#xA;</h4><p>用户可以选择整个文件夹进行批量处理，工具会自动识别并处理文件夹中的所有 PDF 文件：</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def browse_folder(self):</span><br><span class="line">    folder_path = QFileDialog.getExistingDirectory(self, &quot;选择包含 PDF 文件的文件夹&quot;)</span><br><span class="line">    if folder_path:</span><br><span class="line">        self.processing_queue = []</span><br><span class="line">        # 遍历文件夹，收集所有PDF文件...</span><br><span class="line">        self.total_files_to_process = len(self.processing_queue)</span><br><span class="line">        self.processing_mode = &quot;folder&quot;</span><br><span class="line">       # 更新界面显示...</span><br></pre></td></tr></table></figure></div><h4 id="2-改进的文件处理流程-xA"><a href="#2-改进的文件处理流程-xA" class="headerlink" title="2. 改进的文件处理流程&#xA;"></a>2. 改进的文件处理流程&#xA;</h4><p>引入处理队列和工作线程，支持连续处理多个文件，并显示实时进度：</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def process_next_file(self):</span><br><span class="line">    if not self.processing_queue:</span><br><span class="line">        self.on_all_processing_finished()  # 所有文件处理完成</span><br><span class="line">        return</span><br><span class="line">    current_pdf_path = self.processing_queue.pop(0)</span><br><span class="line">    # 确定输出路径...</span><br><span class="line">    # 检查文件是否已存在，处理覆盖逻辑...</span><br><span class="line">    self.processed_count += 1</span><br><span class="line">   self.status_label.setText(f&quot;正在处理第 &#123;self.processed_count&#125; / &#123;self.total_files_to_process&#125; 个文件...&quot;)</span><br><span class="line">    # 启动工作线程处理当前文件...</span><br></pre></td></tr></table></figure></div><h4 id="3-增强的图片处理能力-xA"><a href="#3-增强的图片处理能力-xA" class="headerlink" title="3. 增强的图片处理能力&#xA;"></a>3. 增强的图片处理能力&#xA;</h4><p>优化图片提取和转换逻辑，更好地保留图片质量和透明度：</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">def convert_image_format(temp_path, target_format=&#x27;png&#x27;):</span><br><span class="line">    try:</span><br><span class="line">        with Image.open(temp_path) as img:</span><br><span class="line">            original_mode = img.mode</span><br><span class="line">            new_path = os.path.splitext(temp_path)[0] + f&#x27;.&#123;target_format&#125;&#x27;</span><br><span class="line">            if &#x27;A&#x27; in original_mode:  # 处理透明图片</span><br><span class="line">                if original_mode != &#x27;RGBA&#x27;:</span><br><span class="line">                    img = img.convert(&#x27;RGBA&#x27;)</span><br><span class="line"></span><br><span class="line">               img.save(new_path, format=target_format.upper())</span><br><span class="line">               # 输出转换信息...</span><br><span class="line">           else:</span><br><span class="line">               # 处理非透明图片...</span><br><span class="line">           return new_path</span><br><span class="line">   except Exception as e:</span><br><span class="line">       # 处理转换错误...</span><br></pre></td></tr></table></figure></div><h4 id="4-更智能的文本格式处理-xA"><a href="#4-更智能的文本格式处理-xA" class="headerlink" title="4. 更智能的文本格式处理&#xA;"></a>4. 更智能的文本格式处理&#xA;</h4><p>优化文本排版逻辑，自动识别标题、段落，保持原文档的格式风格：</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 分析最常见的字体大小作为正文字体</span><br><span class="line">if all_font_sizes:</span><br><span class="line">   from collections import Counter</span><br><span class="line">   most_common_size = Counter(all_font_sizes).most_common(1)[0][0]</span><br><span class="line">   print(f&quot;分析得出正文字体大小: &#123;most_common_size&#125;&quot;)</span><br><span class="line">   title_font_threshold = most_common_size * 1.2  # 标题字体阈值</span><br><span class="line">else:</span><br><span class="line">   # 使用默认值...</span><br></pre></td></tr></table></figure></div><h3 id="界面与交互优化-xA"><a href="#界面与交互优化-xA" class="headerlink" title="界面与交互优化&#xA;"></a>界面与交互优化&#xA;</h3><p>优化版本的界面更加友好，交互更加流畅：</p><h4 id="1-直观的文件选择界面-xA"><a href="#1-直观的文件选择界面-xA" class="headerlink" title="1. 直观的文件选择界面&#xA;"></a>1. 直观的文件选择界面&#xA;</h4><p>提供文件和文件夹两种选择方式，满足不同场景需求：</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 选择文件按钮</span><br><span class="line">self.browse_files_button = QPushButton(&quot;选择文件...&quot;)</span><br><span class="line">self.browse_files_button.clicked.connect(self.browse_pdf_files)</span><br><span class="line"></span><br><span class="line"># 选择文件夹按钮</span><br><span class="line">self.browse_folder_button = QPushButton(&quot;选择文件夹...&quot;)</span><br><span class="line">self.browse_folder_button.clicked.connect(self.browse_folder)</span><br></pre></td></tr></table></figure></div><h4 id="2-实时进度显示-xA"><a href="#2-实时进度显示-xA" class="headerlink" title="2. 实时进度显示&#xA;"></a>2. 实时进度显示&#xA;</h4><p>清晰展示当前处理进度和状态，让用户了解处理情况：</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">self.status_label = QLabel(&quot;等待选择文件/文件夹...&quot;)</span><br><span class="line">self.current_file_status_label = QLabel(&quot;&quot;)  # 显示当前处理的文件名</span><br></pre></td></tr></table></figure></div><h4 id="3-文件覆盖策略选择-xA"><a href="#3-文件覆盖策略选择-xA" class="headerlink" title="3. 文件覆盖策略选择&#xA;"></a>3. 文件覆盖策略选择&#xA;</h4><p>当输出文件已存在时，提供灵活的覆盖选项：</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 覆盖所有文件复选框</span><br><span class="line">self.overwrite_all_checkbox = QCheckBox(&quot;对当前批次的所有冲突文件执行此操作&quot;)</span><br><span class="line">self.overwrite_all_checkbox.setVisible(False)  # 默认隐藏</span><br></pre></td></tr></table></figure></div><p>工具使用指南</p><p>使用优化后的 PDF 水印去除工具非常简单，只需几个步骤即可完成水印去除：</p><ol><li><p><strong>选择文件或文件夹</strong>：点击 “选择文件” 按钮处理单个 PDF，或点击 “选择文件夹” 按钮批量处理多个 PDF。</p></li><li><p><strong>开始处理</strong>：点击 “开始处理” 按钮，工具将自动去除水印并转换为 Word 格式。</p></li><li><p><strong>查看结果</strong>：处理完成后，工具会显示成功和失败的文件统计，结果文件将保存在源文件所在目录的 “_无水印” 子文件夹中。</p></li></ol><p>常见问题与解决方案</p><p>在使用过程中，可能会遇到一些常见问题，以下是解决方案：</p><ol><li><p><strong>水印去除不彻底</strong>：可能是水印特征发生变化，可以调整 <code>remove_watermark_by_alpha</code> 函数中的阈值参数。</p></li><li><p><strong>图片显示异常</strong>：部分特殊格式的图片可能转换失败，可以尝试更新 Pillow 库到最新版本。</p></li><li><p><strong>格式错乱</strong>：复杂排版的 PDF 转换后可能出现格式问题，可以手动调整 Word 文档的样式。</p></li><li><p><strong>处理速度慢</strong>：大型 PDF 文件处理需要较长时间，请耐心等待，工具正在后台工作。</p></li></ol><p>总结与展望</p><p>通过本文介绍的方法，我们成功构建了一个功能完善的 PDF 水印去除工具，实现了从单文件处理到批量转换的完整解决方案。该工具能够精准去除水印，保留原文档的文本格式和图片内容，大大提高了文档处理效率。</p><p>未来，我们可以从以下几个方面进一步优化这个工具：</p><ul><li><p>增加对更多水印类型的支持，如图片水印、倾斜文字水印等</p></li><li><p>优化 OCR 功能，提高扫描版 PDF 的处理效果</p></li><li><p>增加自定义水印规则的功能，允许用户手动标记水印特征</p></li><li><p>支持更多输出格式，如 Markdown、HTML 等</p></li><li><p>开发云同步功能，实现跨设备使用</p></li></ul><p>完整代码实现</p><p>以下是完整的 PDF 水印去除工具代码，包含所有功能模块和界面实现：</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line">import sys</span><br><span class="line">import tempfile</span><br><span class="line">from typing import List, Dict, Any, Tuple, Optional</span><br><span class="line">from collections import Counter</span><br><span class="line">from PyQt5.QtWidgets import (QApplication, QWidget, QVBoxLayout, QHBoxLayout,</span><br><span class="line">                          QPushButton, QLabel, QFileDialog, QProgressBar,</span><br><span class="line">                          QMessageBox, QCheckBox, QFrame)</span><br><span class="line">from PyQt5.QtCore import Qt, QThread, pyqtSignal</span><br><span class="line">from PyQt5.QtGui import QFont</span><br><span class="line">import fitz  # PyMuPDF</span><br><span class="line">from docx import Document</span><br><span class="line">from docx.shared import Pt, Inches</span><br><span class="line">from docx.oxml.ns import qn</span><br><span class="line">from docx.enum.text import WD_ALIGN_PARAGRAPH</span><br><span class="line">from PIL import Image</span><br><span class="line"></span><br><span class="line"># 全局临时目录，用于存储提取的图片</span><br><span class="line">GLOBAL_TEMP_DIR = os.path.join(tempfile.gettempdir(), &quot;pdf_watermark_remover&quot;)</span><br><span class="line">os.makedirs(GLOBAL_TEMP_DIR, exist_ok=True)</span><br><span class="line"></span><br><span class="line">class PDFProcessor:</span><br><span class="line">   &quot;&quot;&quot;PDF处理核心类，负责提取内容、去除水印和生成Word文档&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">   @staticmethod</span><br><span class="line">   def extract_full_pdf_info(pdf_path: str) -&gt; List[Dict[str, Any]]:</span><br><span class="line">       &quot;&quot;&quot;提取PDF中的文本、图片和格式信息&quot;&quot;&quot;</span><br><span class="line">       if not os.path.exists(pdf_path):</span><br><span class="line">           raise FileNotFoundError(f&quot;PDF文件未找到: &#123;pdf_path&#125;&quot;)</span><br><span class="line"></span><br><span class="line">       doc = fitz.open(pdf_path)</span><br><span class="line">       full_info = []</span><br><span class="line">       temp_image_dir = os.path.join(GLOBAL_TEMP_DIR, os.path.basename(pdf_path).replace(&#x27;.pdf&#x27;, &#x27;&#x27;))</span><br><span class="line">       os.makedirs(temp_image_dir, exist_ok=True)</span><br><span class="line"></span><br><span class="line">       for page_num in range(len(doc)):</span><br><span class="line">           page = doc[page_num]</span><br><span class="line">           page_data = &#123;</span><br><span class="line">               &quot;page_number&quot;: page_num + 1,</span><br><span class="line">               &quot;page_size&quot;: &#123;&quot;width&quot;: page.rect.width, &quot;height&quot;: page.rect.height&#125;,</span><br><span class="line">               &quot;rotation&quot;: page.rotation,</span><br><span class="line">               &quot;text_content&quot;: [],</span><br><span class="line">               &quot;images&quot;: []</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           # 提取文本内容</span><br><span class="line">           text_blocks = page.get_text(&quot;dict&quot;)[&quot;blocks&quot;]</span><br><span class="line">           for block in text_blocks:</span><br><span class="line">               if block[&quot;type&quot;] == 0:  # 文本块</span><br><span class="line">                   text_block_data = &#123;</span><br><span class="line">                       &quot;bbox&quot;: block[&quot;bbox&quot;],</span><br><span class="line">                       &quot;lines&quot;: []</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   for line in block[&quot;lines&quot;]:</span><br><span class="line">                       line_data = &#123;</span><br><span class="line">                           &quot;spans&quot;: [],</span><br><span class="line">                           &quot;bbox&quot;: line[&quot;bbox&quot;]</span><br><span class="line">                       &#125;</span><br><span class="line"></span><br><span class="line">                       for span in line[&quot;spans&quot;]:</span><br><span class="line">                           span_data = &#123;</span><br><span class="line">                               &quot;text&quot;: span[&quot;text&quot;],</span><br><span class="line">                               &quot;font&quot;: span[&quot;font&quot;],</span><br><span class="line">                               &quot;size&quot;: span[&quot;size&quot;],</span><br><span class="line">                               &quot;color&quot;: span[&quot;color&quot;],</span><br><span class="line">                               &quot;flags&quot;: span[&quot;flags&quot;],</span><br><span class="line">                               &quot;bbox&quot;: span[&quot;bbox&quot;]</span><br><span class="line">                           &#125;</span><br><span class="line">                           line_data[&quot;spans&quot;].append(span_data)</span><br><span class="line"></span><br><span class="line">                       text_block_data[&quot;lines&quot;].append(line_data)</span><br><span class="line"></span><br><span class="line">                   page_data[&quot;text_content&quot;].append(text_block_data)</span><br><span class="line"></span><br><span class="line">           # 提取图片</span><br><span class="line">           images = page.get_images(full=True)</span><br><span class="line">           for img_index, img in enumerate(images):</span><br><span class="line">               xref = img[0]</span><br><span class="line">               base_image = doc.extract_image(xref)</span><br><span class="line">               image_bytes = base_image[&quot;image&quot;]</span><br><span class="line">               image_ext = base_image[&quot;ext&quot;]</span><br><span class="line">               image_width = base_image[&quot;width&quot;]</span><br><span class="line">               image_height = base_image[&quot;height&quot;]</span><br><span class="line"></span><br><span class="line">               # 构建图片路径</span><br><span class="line">               img_filename = f&quot;page_&#123;page_num+1&#125;_img_&#123;img_index&#125;.&#123;image_ext&#125;&quot;</span><br><span class="line">               img_path = os.path.join(temp_image_dir, img_filename)</span><br><span class="line"></span><br><span class="line">               # 保存图片</span><br><span class="line">               with open(img_path, &quot;wb&quot;) as f:</span><br><span class="line">                   f.write(image_bytes)</span><br><span class="line"></span><br><span class="line">               # 处理软掩码（透明度）</span><br><span class="line">               if base_image[&quot;smask&quot;]:</span><br><span class="line">                   smask_image = doc.extract_image(base_image[&quot;smask&quot;])</span><br><span class="line">                   smask_bytes = smask_image[&quot;image&quot;]</span><br><span class="line">                   smask_path = os.path.join(temp_image_dir, f&quot;page_&#123;page_num+1&#125;_img_&#123;img_index&#125;_mask.&#123;image_ext&#125;&quot;)</span><br><span class="line"></span><br><span class="line">                   with open(smask_path, &quot;wb&quot;) as f:</span><br><span class="line">                       f.write(smask_bytes)</span><br><span class="line"></span><br><span class="line">                   # 合并图片和掩码</span><br><span class="line">                   img_path = PDFProcessor.merge_image_with_mask(img_path, smask_path)</span><br><span class="line">                   os.remove(smask_path)  # 清理临时掩码文件</span><br><span class="line"></span><br><span class="line">               # 转换图片格式为PNG以确保兼容性</span><br><span class="line">               if image_ext.lower() != &#x27;png&#x27;:</span><br><span class="line">                   img_path = PDFProcessor.convert_image_format(img_path, &#x27;png&#x27;)</span><br><span class="line"></span><br><span class="line">               # 获取图片在页面中的位置</span><br><span class="line">               img_rect = page.get_image_rects(xref)[0]</span><br><span class="line"></span><br><span class="line">               page_data[&quot;images&quot;].append(&#123;</span><br><span class="line">                   &quot;path&quot;: img_path,</span><br><span class="line">                   &quot;ext&quot;: image_ext,</span><br><span class="line">                   &quot;width&quot;: image_width,</span><br><span class="line">                   &quot;height&quot;: image_height,</span><br><span class="line">                   &quot;rect&quot;: img_rect,</span><br><span class="line">                   &quot;index&quot;: img_index</span><br><span class="line">               &#125;)</span><br><span class="line"></span><br><span class="line">           full_info.append(page_data)</span><br><span class="line"></span><br><span class="line">       doc.close()</span><br><span class="line">       return full_info</span><br><span class="line"></span><br><span class="line">   @staticmethod</span><br><span class="line">   def merge_image_with_mask(image_path: str, mask_path: str) -&gt; str:</span><br><span class="line">       &quot;&quot;&quot;合并图片和掩码以保留透明度&quot;&quot;&quot;</span><br><span class="line">       try:</span><br><span class="line">           with Image.open(image_path) as img, Image.open(mask_path) as mask:</span><br><span class="line">               # 确保图片和掩码尺寸一致</span><br><span class="line">               if img.size != mask.size:</span><br><span class="line">                   mask = mask.resize(img.size)</span><br><span class="line"></span><br><span class="line">               # 合并图片和掩码</span><br><span class="line">               img.putalpha(mask)</span><br><span class="line">               new_path = os.path.splitext(image_path)[0] + &#x27;_merged.png&#x27;</span><br><span class="line">               img.save(new_path, &#x27;PNG&#x27;)</span><br><span class="line">               os.remove(image_path)  # 移除原始图片</span><br><span class="line">               return new_path</span><br><span class="line">       except Exception as e:</span><br><span class="line">           print(f&quot;合并图片和掩码失败: &#123;e&#125;&quot;)</span><br><span class="line">           return image_path  # 失败时返回原始图片路径</span><br><span class="line"></span><br><span class="line">   @staticmethod</span><br><span class="line">   def convert_image_format(temp_path: str, target_format: str = &#x27;png&#x27;) -&gt; str:</span><br><span class="line">       &quot;&quot;&quot;转换图片格式&quot;&quot;&quot;</span><br><span class="line">       try:</span><br><span class="line">           with Image.open(temp_path) as img:</span><br><span class="line">               original_mode = img.mode</span><br><span class="line">               new_path = os.path.splitext(temp_path)[0] + f&#x27;.&#123;target_format&#125;&#x27;</span><br><span class="line"></span><br><span class="line">               # 处理透明图片</span><br><span class="line">               if &#x27;A&#x27; in original_mode:</span><br><span class="line">                   if original_mode != &#x27;RGBA&#x27;:</span><br><span class="line">                       img = img.convert(&#x27;RGBA&#x27;)</span><br><span class="line">                   img.save(new_path, format=target_format.upper())</span><br><span class="line">               else:</span><br><span class="line">                   # 非透明图片直接转换</span><br><span class="line">                   img.save(new_path, format=target_format.upper())</span><br><span class="line"></span><br><span class="line">               os.remove(temp_path)  # 移除原始格式图片</span><br><span class="line">               return new_path</span><br><span class="line">       except Exception as e:</span><br><span class="line">           print(f&quot;转换图片格式失败: &#123;e&#125;&quot;)</span><br><span class="line">           return temp_path  # 失败时返回原始路径</span><br><span class="line"></span><br><span class="line">   @staticmethod</span><br><span class="line">   def remove_watermark_by_alpha(full_info: List[Dict[str, Any]]) -&gt; List[Dict[str, Any]]:</span><br><span class="line">       &quot;&quot;&quot;通过透明度、字体大小和颜色识别并去除水印&quot;&quot;&quot;</span><br><span class="line">       clean_full_info = []</span><br><span class="line">       watermark_removed_count = 0</span><br><span class="line"></span><br><span class="line">       # 水印特征参数</span><br><span class="line">       ALPHA_THRESHOLD = 150  # 透明度阈值</span><br><span class="line">       TARGET_FONT_SIZE = 18  # 水印字体大小</span><br><span class="line">       FONT_SIZE_TOLERANCE = 1  # 字体大小容差</span><br><span class="line">       TARGET_COLOR_INT_VALUE = 13882323  # 水印颜色值</span><br><span class="line"></span><br><span class="line">       for page in full_info:</span><br><span class="line">           clean_text_blocks = []</span><br><span class="line"></span><br><span class="line">           for text_block in page[&quot;text_content&quot;]:</span><br><span class="line">               clean_lines = []</span><br><span class="line"></span><br><span class="line">               for line in text_block[&quot;lines&quot;]:</span><br><span class="line">                   clean_spans = []</span><br><span class="line"></span><br><span class="line">                   for span in line[&quot;spans&quot;]:</span><br><span class="line">                       # 检查是否为水印文本</span><br><span class="line">                       is_watermark = False</span><br><span class="line"></span><br><span class="line">                       # 检查字体大小</span><br><span class="line">                       size_diff = abs(span[&quot;size&quot;] - TARGET_FONT_SIZE)</span><br><span class="line">                       if size_diff &lt;= FONT_SIZE_TOLERANCE:</span><br><span class="line">                           # 检查颜色</span><br><span class="line">                           if span[&quot;color&quot;] == TARGET_COLOR_INT_VALUE:</span><br><span class="line">                               # 检查透明度（通过flags判断）</span><br><span class="line">                               # flags的第3位表示透明度</span><br><span class="line">                               if (span[&quot;flags&quot;] &amp; 0b100) != 0:</span><br><span class="line">                                   is_watermark = True</span><br><span class="line"></span><br><span class="line">                       if not is_watermark:</span><br><span class="line">                           clean_spans.append(span)</span><br><span class="line">                       else:</span><br><span class="line">                           watermark_removed_count += 1</span><br><span class="line"></span><br><span class="line">                   if clean_spans:  # 只保留有内容的行</span><br><span class="line">                       clean_line = &#123;**line, &quot;spans&quot;: clean_spans&#125;</span><br><span class="line">                       clean_lines.append(clean_line)</span><br><span class="line"></span><br><span class="line">               if clean_lines:  # 只保留有内容的文本块</span><br><span class="line">                   clean_block = &#123;** text_block, &quot;lines&quot;: clean_lines&#125;</span><br><span class="line">                   clean_text_blocks.append(clean_block)</span><br><span class="line"></span><br><span class="line">           # 保留图片信息</span><br><span class="line">           clean_page = &#123;**page, &quot;text_content&quot;: clean_text_blocks, &quot;images&quot;: page[&quot;images&quot;]&#125;</span><br><span class="line">           clean_full_info.append(clean_page)</span><br><span class="line"></span><br><span class="line">       print(f&quot;水印移除完成。共移除 &#123;watermark_removed_count&#125; 处水印文本。&quot;)</span><br><span class="line">       return clean_full_info</span><br><span class="line"></span><br><span class="line">   @staticmethod</span><br><span class="line">   def get_system_font_mapping() -&gt; Dict[str, str]:</span><br><span class="line">       &quot;&quot;&quot;获取系统字体映射表，用于PDF到Word的字体转换&quot;&quot;&quot;</span><br><span class="line">       return &#123;</span><br><span class="line">           &quot;SimSun&quot;: &quot;宋体&quot;,</span><br><span class="line">           &quot;SimHei&quot;: &quot;黑体&quot;,</span><br><span class="line">           &quot;Microsoft YaHei&quot;: &quot;微软雅黑&quot;,</span><br><span class="line">           &quot;KaiTi&quot;: &quot;楷体&quot;,</span><br><span class="line">           &quot;FangSong&quot;: &quot;仿宋&quot;,</span><br><span class="line">           &quot;Arial&quot;: &quot;Arial&quot;,</span><br><span class="line">           &quot;Times New Roman&quot;: &quot;Times New Roman&quot;,</span><br><span class="line">           # 可以根据需要添加更多字体映射</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   @staticmethod</span><br><span class="line">   def generate_word_from_data(clean_info: List[Dict[str, Any]], output_word_path: str) -&gt; None:</span><br><span class="line">       &quot;&quot;&quot;从清理后的PDF信息生成Word文档&quot;&quot;&quot;</span><br><span class="line">       doc = Document()</span><br><span class="line">       font_mapping = PDFProcessor.get_system_font_mapping()</span><br><span class="line"></span><br><span class="line">       # 收集所有字体大小用于分析</span><br><span class="line">       all_font_sizes = []</span><br><span class="line">       for page in clean_info:</span><br><span class="line">           for block in page[&quot;text_content&quot;]:</span><br><span class="line">               for line in block[&quot;lines&quot;]:</span><br><span class="line">                   for span in line[&quot;spans&quot;]:</span><br><span class="line">                       all_font_sizes.append(span[&quot;size&quot;])</span><br><span class="line"></span><br><span class="line">       # 分析最常见的字体大小作为正文字体</span><br><span class="line">       if all_font_sizes:</span><br><span class="line">           most_common_size = Counter(all_font_sizes).most_common(1)[0][0]</span><br><span class="line">           print(f&quot;分析得出正文字体大小: &#123;most_common_size&#125;&quot;)</span><br><span class="line">           title_font_threshold = most_common_size * 1.2  # 标题字体阈值</span><br><span class="line">       else:</span><br><span class="line">           most_common_size = 12  # 默认正文字体大小</span><br><span class="line">           title_font_threshold = 14  # 默认标题字体阈值</span><br><span class="line"></span><br><span class="line">       # 处理每一页内容</span><br><span class="line">       for page in clean_info:</span><br><span class="line">           # 为新页面添加分页符（第一页除外）</span><br><span class="line">           if page[&quot;page_number&quot;] &gt; 1:</span><br><span class="line">               doc.add_page_break()</span><br><span class="line"></span><br><span class="line">           # 添加页码</span><br><span class="line">           page_paragraph = doc.add_paragraph()</span><br><span class="line">           page_run = page_paragraph.add_run(f&quot;第 &#123;page[&#x27;page_number&#x27;]&#125; 页&quot;)</span><br><span class="line">           page_run.font.size = Pt(9)</span><br><span class="line">           page_paragraph.alignment = WD_ALIGN_PARAGRAPH.CENTER</span><br><span class="line"></span><br><span class="line">           # 收集页面上的所有元素（文本块和图片）并按位置排序</span><br><span class="line">           page_elements = []</span><br><span class="line"></span><br><span class="line">           # 添加文本块</span><br><span class="line">           for block in page[&quot;text_content&quot;]:</span><br><span class="line">               # 使用文本块的边界框顶部作为排序依据</span><br><span class="line">               block_top = block[&quot;bbox&quot;][1]</span><br><span class="line">               page_elements.append(&#123;</span><br><span class="line">                   &quot;type&quot;: &quot;text&quot;,</span><br><span class="line">                   &quot;top&quot;: block_top,</span><br><span class="line">                   &quot;data&quot;: block</span><br><span class="line">               &#125;)</span><br><span class="line"></span><br><span class="line">           # 添加图片</span><br><span class="line">           for img in page[&quot;images&quot;]:</span><br><span class="line">               # 使用图片的顶部位置作为排序依据</span><br><span class="line">               img_top = img[&quot;rect&quot;][1]</span><br><span class="line">               page_elements.append(&#123;</span><br><span class="line">                   &quot;type&quot;: &quot;image&quot;,</span><br><span class="line">                   &quot;top&quot;: img_top,</span><br><span class="line">                   &quot;data&quot;: img</span><br><span class="line">               &#125;)</span><br><span class="line"></span><br><span class="line">           # 按元素在页面中的垂直位置排序</span><br><span class="line">           page_elements.sort(key=lambda x: x[&quot;top&quot;])</span><br><span class="line"></span><br><span class="line">           # 处理排序后的元素</span><br><span class="line">           for element in page_elements:</span><br><span class="line">               if element[&quot;type&quot;] == &quot;text&quot;:</span><br><span class="line">                   PDFProcessor._add_text_block_to_doc(doc, element[&quot;data&quot;], font_mapping,</span><br><span class="line">                                                     title_font_threshold, most_common_size)</span><br><span class="line">               elif element[&quot;type&quot;] == &quot;image&quot;:</span><br><span class="line">                   PDFProcessor._add_image_to_doc(doc, element[&quot;data&quot;])</span><br><span class="line"></span><br><span class="line">       # 保存生成的Word文档</span><br><span class="line">       try:</span><br><span class="line">           # 确保输出目录存在</span><br><span class="line">           output_dir = os.path.dirname(output_word_path)</span><br><span class="line">           os.makedirs(output_dir, exist_ok=True)</span><br><span class="line"></span><br><span class="line">           doc.save(output_word_path)</span><br><span class="line">           print(f&quot;Word文档已保存至：&#123;output_word_path&#125;&quot;)</span><br><span class="line">       except Exception as e:</span><br><span class="line">           print(f&quot;保存Word文档失败：&#123;e&#125;&quot;)</span><br><span class="line">           raise</span><br><span class="line"></span><br><span class="line">   @staticmethod</span><br><span class="line">   def _add_text_block_to_doc(doc, text_block, font_mapping, title_threshold, normal_size):</span><br><span class="line">       &quot;&quot;&quot;将文本块添加到Word文档&quot;&quot;&quot;</span><br><span class="line">       for line in text_block[&quot;lines&quot;]:</span><br><span class="line">           paragraph = doc.add_paragraph()</span><br><span class="line"></span><br><span class="line">           for span in line[&quot;spans&quot;]:</span><br><span class="line">               run = paragraph.add_run(span[&quot;text&quot;])</span><br><span class="line"></span><br><span class="line">               # 设置字体</span><br><span class="line">               font_name = span[&quot;font&quot;]</span><br><span class="line">               # 映射到系统可用字体</span><br><span class="line">               mapped_font = font_mapping.get(font_name, font_name)</span><br><span class="line">               try:</span><br><span class="line">                   run.font.name = mapped_font</span><br><span class="line">                   # 设置中文字体</span><br><span class="line">                   run._element.rPr.rFonts.set(qn(&#x27;w:eastAsia&#x27;), mapped_font)</span><br><span class="line">               except Exception as e:</span><br><span class="line">                   print(f&quot;设置字体 &#123;mapped_font&#125; 失败: &#123;e&#125;&quot;)</span><br><span class="line">                   run.font.name = &quot;宋体&quot;</span><br><span class="line">                   run._element.rPr.rFonts.set(qn(&#x27;w:eastAsia&#x27;), &quot;宋体&quot;)</span><br><span class="line"></span><br><span class="line">               # 设置字体大小</span><br><span class="line">               try:</span><br><span class="line">                   run.font.size = Pt(span[&quot;size&quot;])</span><br><span class="line">               except:</span><br><span class="line">                   run.font.size = Pt(normal_size)</span><br><span class="line"></span><br><span class="line">               # 设置字体颜色（简化处理，仅使用黑白两色）</span><br><span class="line">               if span[&quot;color&quot;] in (0, 255):  # 黑色或白色</span><br><span class="line">                   run.font.color.rgb = None  # 使用默认颜色</span><br><span class="line">               else:</span><br><span class="line">                   # 转换PDF颜色值（整数）为RGB</span><br><span class="line">                   rgb = PDFProcessor._int_to_rgb(span[&quot;color&quot;])</span><br><span class="line">                   run.font.color.rgb = rgb</span><br><span class="line"></span><br><span class="line">           # 根据字体大小判断是否为标题</span><br><span class="line">           if line[&quot;spans&quot;]:</span><br><span class="line">               first_span_size = line[&quot;spans&quot;][0][&quot;size&quot;]</span><br><span class="line">               if first_span_size &gt;= title_threshold:</span><br><span class="line">                   paragraph.style = doc.styles[&quot;Heading 2&quot;]</span><br><span class="line">               else:</span><br><span class="line">                   paragraph.style = doc.styles[&quot;Normal&quot;]</span><br><span class="line"></span><br><span class="line">   @staticmethod</span><br><span class="line">   def _add_image_to_doc(doc, img_data):</span><br><span class="line">       &quot;&quot;&quot;将图片添加到Word文档&quot;&quot;&quot;</span><br><span class="line">       try:</span><br><span class="line">           if os.path.exists(img_data[&quot;path&quot;]):</span><br><span class="line">               # 计算图片在Word中的尺寸（英寸）</span><br><span class="line">               # 72像素 = 1英寸</span><br><span class="line">               width_in_inches = img_data[&quot;width&quot;] / 72</span><br><span class="line">               height_in_inches = img_data[&quot;height&quot;] / 72</span><br><span class="line"></span><br><span class="line">               # 限制最大宽度为6英寸，保持比例</span><br><span class="line">               if width_in_inches &gt; 6:</span><br><span class="line">                   ratio = 6 / width_in_inches</span><br><span class="line">                   width_in_inches = 6</span><br><span class="line">                   height_in_inches *= ratio</span><br><span class="line"></span><br><span class="line">               # 添加图片</span><br><span class="line">               paragraph = doc.add_paragraph()</span><br><span class="line">               run = paragraph.add_run()</span><br><span class="line">               run.add_picture(img_data[&quot;path&quot;], width=Inches(width_in_inches),</span><br><span class="line">                              height=Inches(height_in_inches))</span><br><span class="line">               paragraph.alignment = WD_ALIGN_PARAGRAPH.CENTER  # 图片居中对齐</span><br><span class="line">       except Exception as e:</span><br><span class="line">           print(f&quot;添加图片到文档失败: &#123;e&#125;&quot;)</span><br><span class="line"></span><br><span class="line">   @staticmethod</span><br><span class="line">   def _int_to_rgb(color_int: int) -&gt; Tuple[int, int, int]:</span><br><span class="line">       &quot;&quot;&quot;将整数颜色值转换为RGB tuple&quot;&quot;&quot;</span><br><span class="line">       blue = color_int &amp; 0xff</span><br><span class="line">       green = (color_int &gt;&gt; 8) &amp; 0xff</span><br><span class="line">       red = (color_int &gt;&gt; 16) &amp; 0xff</span><br><span class="line">       return (red, green, blue)</span><br><span class="line"></span><br><span class="line">class ProcessingThread(QThread):</span><br><span class="line">   &quot;&quot;&quot;处理PDF文件的工作线程&quot;&quot;&quot;</span><br><span class="line">   finished = pyqtSignal(bool, str, str)  # 处理完成信号 (成功, 原文件路径, 结果文件路径)</span><br><span class="line">   progress_updated = pyqtSignal(str)  # 进度更新信号</span><br><span class="line"></span><br><span class="line">   def __init__(self, pdf_path: str, output_path: str):</span><br><span class="line">       super().__init__()</span><br><span class="line">       self.pdf_path = pdf_path</span><br><span class="line">       self.output_path = output_path</span><br><span class="line"></span><br><span class="line">   def run(self):</span><br><span class="line">       try:</span><br><span class="line">           self.progress_updated.emit(f&quot;正在提取PDF内容: &#123;os.path.basename(self.pdf_path)&#125;&quot;)</span><br><span class="line"></span><br><span class="line">           # 提取PDF信息</span><br><span class="line">           pdf_info = PDFProcessor.extract_full_pdf_info(self.pdf_path)</span><br><span class="line"></span><br><span class="line">           self.progress_updated.emit(f&quot;正在去除水印: &#123;os.path.basename(self.pdf_path)&#125;&quot;)</span><br><span class="line"></span><br><span class="line">           # 去除水印</span><br><span class="line">           clean_info = PDFProcessor.remove_watermark_by_alpha(pdf_info)</span><br><span class="line"></span><br><span class="line">           self.progress_updated.emit(f&quot;正在生成Word文档: &#123;os.path.basename(self.output_path)&#125;&quot;)</span><br><span class="line"></span><br><span class="line">           # 生成Word文档</span><br><span class="line">           PDFProcessor.generate_word_from_data(clean_info, self.output_path)</span><br><span class="line"></span><br><span class="line">           self.finished.emit(True, self.pdf_path, self.output_path)</span><br><span class="line">       except Exception as e:</span><br><span class="line">           error_msg = f&quot;处理失败: &#123;str(e)&#125;&quot;</span><br><span class="line">           print(error_msg)</span><br><span class="line">           self.progress_updated.emit(error_msg)</span><br><span class="line">           self.finished.emit(False, self.pdf_path, str(e))</span><br><span class="line"></span><br><span class="line">class PdfWatermarkRemoverApp(QWidget):</span><br><span class="line">   &quot;&quot;&quot;PDF水印去除工具主界面&quot;&quot;&quot;</span><br><span class="line">   def __init__(self):</span><br><span class="line">       super().__init__()</span><br><span class="line">       self.processing_queue = []  # 待处理文件队列</span><br><span class="line">       self.processed_count = 0  # 已处理文件数</span><br><span class="line">       self.total_files_to_process = 0  # 总文件数</span><br><span class="line">       self.success_count = 0  # 处理成功数</span><br><span class="line">       self.failure_count = 0  # 处理失败数</span><br><span class="line">       self.failed_files = []  # 处理失败的文件列表</span><br><span class="line">       self.processing_mode = None  # &#x27;file&#x27; 或 &#x27;folder&#x27;</span><br><span class="line">       self.overwrite_all = None  # None:未设置, True:全部覆盖, False:全部跳过</span><br><span class="line">       self.init_ui()</span><br><span class="line"></span><br><span class="line">   def init_ui(self):</span><br><span class="line">       &quot;&quot;&quot;初始化用户界面&quot;&quot;&quot;</span><br><span class="line">       self.setWindowTitle(&quot;PDF水印去除工具&quot;)</span><br><span class="line">       self.setFixedSize(750, 400)</span><br><span class="line"></span><br><span class="line">       # 设置中文字体</span><br><span class="line">       font = QFont()</span><br><span class="line">       font.setFamily(&quot;SimHei&quot;)</span><br><span class="line">       self.setFont(font)</span><br><span class="line"></span><br><span class="line">       main_layout = QVBoxLayout()</span><br><span class="line">       main_layout.setSpacing(15)</span><br><span class="line">       main_layout.setContentsMargins(20, 20, 20, 20)</span><br><span class="line"></span><br><span class="line">       # 标题</span><br><span class="line">       title_label = QLabel(&quot;PDF水印去除与Word转换工具&quot;)</span><br><span class="line">       title_font = QFont()</span><br><span class="line">       title_font.setFamily(&quot;SimHei&quot;)</span><br><span class="line">       title_font.setPointSize(14)</span><br><span class="line">       title_font.setBold(True)</span><br><span class="line">       title_label.setFont(title_font)</span><br><span class="line">       title_label.setAlignment(Qt.AlignCenter)</span><br><span class="line">       main_layout.addWidget(title_label)</span><br><span class="line"></span><br><span class="line">       # 分隔线</span><br><span class="line">       line = QFrame()</span><br><span class="line">       line.setFrameShape(QFrame.HLine)</span><br><span class="line">       line.setFrameShadow(QFrame.Sunken)</span><br><span class="line">       main_layout.addWidget(line)</span><br><span class="line"></span><br><span class="line">       # 文件选择区域</span><br><span class="line">       file_selection_layout = QVBoxLayout()</span><br><span class="line"></span><br><span class="line">       # 选择文件按钮</span><br><span class="line">       self.browse_files_button = QPushButton(&quot;选择文件...&quot;)</span><br><span class="line">       self.browse_files_button.setFont(font)</span><br><span class="line">       self.browse_files_button.clicked.connect(self.browse_pdf_files)</span><br><span class="line">       file_selection_layout.addWidget(self.browse_files_button)</span><br><span class="line"></span><br><span class="line">       # 选择文件夹按钮</span><br><span class="line">       self.browse_folder_button = QPushButton(&quot;选择文件夹...&quot;)</span><br><span class="line">       self.browse_folder_button.setFont(font)</span><br><span class="line">       self.browse_folder_button.clicked.connect(self.browse_folder)</span><br><span class="line">       file_selection_layout.addWidget(self.browse_folder_button)</span><br><span class="line"></span><br><span class="line">       # 选中的文件/文件夹显示</span><br><span class="line">       self.selected_path_label = QLabel(&quot;未选择任何文件或文件夹&quot;)</span><br><span class="line">       self.selected_path_label.setFont(font)</span><br><span class="line">       self.selected_path_label.setWordWrap(True)</span><br><span class="line">       file_selection_layout.addWidget(self.selected_path_label)</span><br><span class="line"></span><br><span class="line">       main_layout.addLayout(file_selection_layout)</span><br><span class="line"></span><br><span class="line">       # 处理按钮</span><br><span class="line">       self.process_button = QPushButton(&quot;开始处理&quot;)</span><br><span class="line">       self.process_button.setFont(font)</span><br><span class="line">       self.process_button.setMinimumHeight(40)</span><br><span class="line">       self.process_button.clicked.connect(self.start_processing)</span><br><span class="line">       self.process_button.setEnabled(False)  # 初始禁用</span><br><span class="line">       main_layout.addWidget(self.process_button)</span><br><span class="line"></span><br><span class="line">       # 进度显示区域</span><br><span class="line">       progress_layout = QVBoxLayout()</span><br><span class="line"></span><br><span class="line">       self.status_label = QLabel(&quot;等待选择文件/文件夹...&quot;)</span><br><span class="line">       self.status_label.setFont(font)</span><br><span class="line">       progress_layout.addWidget(self.status_label)</span><br><span class="line"></span><br><span class="line">       self.current_file_status_label = QLabel(&quot;&quot;)</span><br><span class="line">       self.current_file_status_label.setFont(font)</span><br><span class="line">       self.current_file_status_label.setWordWrap(True)</span><br><span class="line">       progress_layout.addWidget(self.current_file_status_label)</span><br><span class="line"></span><br><span class="line">       self.progress_bar = QProgressBar()</span><br><span class="line">       self.progress_bar.setValue(0)</span><br><span class="line">       progress_layout.addWidget(self.progress_bar)</span><br><span class="line"></span><br><span class="line">       main_layout.addLayout(progress_layout)</span><br><span class="line"></span><br><span class="line">       # 覆盖选项（默认隐藏）</span><br><span class="line">       self.overwrite_layout = QHBoxLayout()</span><br><span class="line"></span><br><span class="line">       self.overwrite_label = QLabel(&quot;文件已存在，是否覆盖？&quot;)</span><br><span class="line">       self.overwrite_label.setFont(font)</span><br><span class="line">       self.overwrite_layout.addWidget(self.overwrite_label)</span><br><span class="line"></span><br><span class="line">       self.overwrite_button = QPushButton(&quot;覆盖&quot;)</span><br><span class="line">       self.overwrite_button.setFont(font)</span><br><span class="line">       self.overwrite_button.clicked.connect(lambda: self.handle_overwrite_choice(True))</span><br><span class="line">       self.overwrite_layout.addWidget(self.overwrite_button)</span><br><span class="line"></span><br><span class="line">       self.skip_button = QPushButton(&quot;跳过&quot;)</span><br><span class="line">       self.skip_button.setFont(font)</span><br><span class="line">       self.skip_button.clicked.connect(lambda: self.handle_overwrite_choice(False))</span><br><span class="line">       self.overwrite_layout.addWidget(self.skip_button)</span><br><span class="line"></span><br><span class="line">       self.overwrite_all_checkbox = QCheckBox(&quot;对当前批次的所有冲突文件执行此操作&quot;)</span><br><span class="line">       self.overwrite_all_checkbox.setFont(font)</span><br><span class="line">       self.overwrite_all_checkbox.setVisible(False)</span><br><span class="line">       self.overwrite_layout.addWidget(self.overwrite_all_checkbox)</span><br><span class="line"></span><br><span class="line">       main_layout.addLayout(self.overwrite_layout)</span><br><span class="line">       self.overwrite_layout.setVisible(False)  # 默认隐藏</span><br><span class="line"></span><br><span class="line">       # 状态统计区域</span><br><span class="line">       self.stats_label = QLabel(&quot;处理统计: 0 成功, 0 失败&quot;)</span><br><span class="line">       self.stats_label.setFont(font)</span><br><span class="line">       main_layout.addWidget(self.stats_label)</span><br><span class="line"></span><br><span class="line">       # 底部说明</span><br><span class="line">       note_label = QLabel(&quot;说明: 处理后的文件将保存至源文件所在目录的 &#x27;_无水印&#x27; 子文件夹中&quot;)</span><br><span class="line">       note_font = QFont()</span><br><span class="line">       note_font.setFamily(&quot;SimHei&quot;)</span><br><span class="line">       note_font.setPointSize(9)</span><br><span class="line">       note_label.setFont(note_font)</span><br><span class="line">       note_label.setAlignment(Qt.AlignRight)</span><br><span class="line">       main_layout.addWidget(note_label)</span><br><span class="line"></span><br><span class="line">       self.setLayout(main_layout)</span><br><span class="line"></span><br><span class="line">   def browse_pdf_files(self):</span><br><span class="line">       &quot;&quot;&quot;浏览并选择PDF文件&quot;&quot;&quot;</span><br><span class="line">       file_paths, _ = QFileDialog.getOpenFileNames(self, &quot;选择PDF文件&quot;, &quot;&quot;, &quot;PDF文件 (*.pdf)&quot;)</span><br><span class="line">       if file_paths:</span><br><span class="line">           self.processing_mode = &quot;file&quot;</span><br><span class="line">           self.processing_queue = list(file_paths)</span><br><span class="line">           self.total_files_to_process = len(self.processing_queue)</span><br><span class="line">           self.selected_path_label.setText(f&quot;已选择 &#123;self.total_files_to_process&#125; 个PDF文件&quot;)</span><br><span class="line">           self.process_button.setEnabled(True)</span><br><span class="line">           self.reset_processing_stats()</span><br><span class="line"></span><br><span class="line">   def browse_folder(self):</span><br><span class="line">       &quot;&quot;&quot;浏览并选择文件夹&quot;&quot;&quot;</span><br><span class="line">       folder_path = QFileDialog.getExistingDirectory(self, &quot;选择包含 PDF 文件的文件夹&quot;)</span><br><span class="line">       if folder_path:</span><br><span class="line">           self.processing_mode = &quot;folder&quot;</span><br><span class="line">           # 查找文件夹中的所有PDF文件</span><br><span class="line">           pdf_files = []</span><br><span class="line">           for root, _, files in os.walk(folder_path):</span><br><span class="line">               for file in files:</span><br><span class="line">                   if file.lower().endswith(&#x27;.pdf&#x27;):</span><br><span class="line">                       pdf_files.append(os.path.join(root, file))</span><br><span class="line"></span><br><span class="line">           self.processing_queue = pdf_files</span><br><span class="line">           self.total_files_to_process = len(self.processing_queue)</span><br><span class="line">           self.selected_path_label.setText(</span><br><span class="line">               f&quot;已选择文件夹: &#123;folder_path&#125;n包含 &#123;self.total_files_to_process&#125; 个PDF文件&quot;)</span><br><span class="line">           self.process_button.setEnabled(self.total_files_to_process &gt; 0)</span><br><span class="line">           self.reset_processing_stats()</span><br><span class="line"></span><br><span class="line">   def reset_processing_stats(self):</span><br><span class="line">       &quot;&quot;&quot;重置处理统计信息&quot;&quot;&quot;</span><br><span class="line">       self.processed_count = 0</span><br><span class="line">       self.success_count = 0</span><br><span class="line">       self.failure_count = 0</span><br><span class="line">       self.failed_files = []</span><br><span class="line">       self.progress_bar.setValue(0)</span><br><span class="line">       self.stats_label.setText(&quot;处理统计: 0 成功, 0 失败&quot;)</span><br><span class="line">       self.status_label.setText(&quot;就绪，点击开始处理&quot;)</span><br><span class="line">       self.current_file_status_label.setText(&quot;&quot;)</span><br><span class="line">       self.overwrite_all = None</span><br><span class="line"></span><br><span class="line">   def start_processing(self):</span><br><span class="line">       &quot;&quot;&quot;开始处理文件队列&quot;&quot;&quot;</span><br><span class="line">       if not self.processing_queue or self.total_files_to_process == 0:</span><br><span class="line">           QMessageBox.information(self, &quot;提示&quot;, &quot;没有可处理的文件&quot;)</span><br><span class="line">           return</span><br><span class="line"></span><br><span class="line">       self.process_button.setEnabled(False)</span><br><span class="line">       self.browse_files_button.setEnabled(False)</span><br><span class="line">       self.browse_folder_button.setEnabled(False)</span><br><span class="line">       self.process_next_file()</span><br><span class="line"></span><br><span class="line">   def process_next_file(self):</span><br><span class="line">       &quot;&quot;&quot;处理队列中的下一个文件&quot;&quot;&quot;</span><br><span class="line">       if not self.processing_queue:</span><br><span class="line">           self.on_all_processing_finished()</span><br><span class="line">           return</span><br><span class="line"></span><br><span class="line">       current_pdf_path = self.processing_queue.pop(0)</span><br><span class="line">       pdf_filename = os.path.basename(current_pdf_path)</span><br><span class="line">       pdf_dir = os.path.dirname(current_pdf_path)</span><br><span class="line"></span><br><span class="line">       # 创建输出目录</span><br><span class="line">       output_dir = os.path.join(pdf_dir, pdf_filename.replace(&#x27;.pdf&#x27;, &#x27;&#x27;) + &quot;_无水印&quot;)</span><br><span class="line">       os.makedirs(output_dir, exist_ok=True)</span><br><span class="line"></span><br><span class="line">       # 构建输出文件路径</span><br><span class="line">       output_filename = os.path.splitext(pdf_filename)[0] + &quot;_无水印.docx&quot;</span><br><span class="line">       output_word_path = os.path.join(output_dir, output_filename)</span><br><span class="line"></span><br><span class="line">       # 检查文件是否已存在</span><br><span class="line">       if os.path.exists(output_word_path):</span><br><span class="line">           # 如果已设置全局覆盖策略，则直接应用</span><br><span class="line">           if self.overwrite_all is not None:</span><br><span class="line">               if not self.overwrite_all:</span><br><span class="line">                   # 跳过此文件</span><br><span class="line">                   self.current_file_status_label.setText(f&quot;已跳过已存在文件: &#123;pdf_filename&#125;&quot;)</span><br><span class="line">                   self.processed_count += 1</span><br><span class="line">                   self.update_progress()</span><br><span class="line">                   QApplication.processEvents()  # 更新界面</span><br><span class="line">                   self.process_next_file()</span><br><span class="line">                   return</span><br><span class="line">           else:</span><br><span class="line">               # 显示覆盖选择对话框</span><br><span class="line">               self.current_file_path = current_pdf_path</span><br><span class="line">               self.current_output_path = output_word_path</span><br><span class="line">               self.status_label.setText(f&quot;文件已存在: &#123;pdf_filename&#125;&quot;)</span><br><span class="line">               self.current_file_status_label.setText(&quot;请选择处理方式&quot;)</span><br><span class="line">               self.overwrite_layout.setVisible(True)</span><br><span class="line">               self.overwrite_all_checkbox.setVisible(True)</span><br><span class="line">               return</span><br><span class="line"></span><br><span class="line">       # 启动处理线程</span><br><span class="line">       self.status_label.setText(f&quot;正在处理第 &#123;self.processed_count + 1&#125; / &#123;self.total_files_to_process&#125; 个文件...&quot;)</span><br><span class="line">       self.current_file_status_label.setText(f&quot;正在处理: &#123;pdf_filename&#125;&quot;)</span><br><span class="line"></span><br><span class="line">       self.processing_thread = ProcessingThread(current_pdf_path, output_word_path)</span><br><span class="line">       self.processing_thread.finished.connect(self.on_file_processed)</span><br><span class="line">       self.processing_thread.progress_updated.connect(self.current_file_status_label.setText)</span><br><span class="line">       self.processing_thread.start()</span><br><span class="line"></span><br><span class="line">   def handle_overwrite_choice(self, overwrite: bool):</span><br><span class="line">       &quot;&quot;&quot;处理文件覆盖选择&quot;&quot;&quot;</span><br><span class="line">       self.overwrite_layout.setVisible(False)</span><br><span class="line"></span><br><span class="line">       # 检查是否需要应用到所有文件</span><br><span class="line">       if self.overwrite_all_checkbox.isChecked():</span><br><span class="line">           self.overwrite_all = overwrite</span><br><span class="line"></span><br><span class="line">       if overwrite:</span><br><span class="line">           # 继续处理当前文件，覆盖已存在文件</span><br><span class="line">           self.processing_thread = ProcessingThread(self.current_file_path, self.current_output_path)</span><br><span class="line">           self.processing_thread.finished.connect(self.on_file_processed)</span><br><span class="line">           self.processing_thread.progress_updated.connect(self.current_file_status_label.setText)</span><br><span class="line">           self.processing_thread.start()</span><br><span class="line">       else:</span><br><span class="line">           # 跳过当前文件</span><br><span class="line">           self.current_file_status_label.setText(f&quot;已跳过已存在文件: &#123;os.path.basename(self.current_file_path)&#125;&quot;)</span><br><span class="line">           self.processed_count += 1</span><br><span class="line">           self.update_progress()</span><br><span class="line">           self.process_next_file()</span><br><span class="line"></span><br><span class="line">   def on_file_processed(self, success: bool, file_path: str, result: str):</span><br><span class="line">       &quot;&quot;&quot;文件处理完成回调&quot;&quot;&quot;</span><br><span class="line">       filename = os.path.basename(file_path)</span><br><span class="line"></span><br><span class="line">       if success:</span><br><span class="line">           self.success_count += 1</span><br><span class="line">           self.current_file_status_label.setText(f&quot;处理成功: &#123;filename&#125; -&gt; &#123;os.path.basename(result)&#125;&quot;)</span><br><span class="line">       else:</span><br><span class="line">           self.failure_count += 1</span><br><span class="line">           self.failed_files.append(f&quot;&#123;filename&#125;: &#123;result&#125;&quot;)</span><br><span class="line">           self.current_file_status_label.setText(f&quot;处理失败: &#123;filename&#125; - &#123;result&#125;&quot;)</span><br><span class="line"></span><br><span class="line">       self.processed_count += 1</span><br><span class="line">       self.update_progress()</span><br><span class="line">       self.process_next_file()</span><br><span class="line"></span><br><span class="line">   def update_progress(self):</span><br><span class="line">       &quot;&quot;&quot;更新进度显示&quot;&quot;&quot;</span><br><span class="line">       progress_percentage = int((self.processed_count / self.total_files_to_process) * 100)</span><br><span class="line">       self.progress_bar.setValue(progress_percentage)</span><br><span class="line">       self.stats_label.setText(f&quot;处理统计: &#123;self.success_count&#125; 成功, &#123;self.failure_count&#125; 失败&quot;)</span><br><span class="line"></span><br><span class="line">   def on_all_processing_finished(self):</span><br><span class="line">       &quot;&quot;&quot;所有文件处理完成&quot;&quot;&quot;</span><br><span class="line">       self.status_label.setText(&quot;所有文件处理完成!&quot;)</span><br><span class="line">       self.current_file_status_label.setText(&quot;&quot;)</span><br><span class="line"></span><br><span class="line">       # 显示处理结果摘要</span><br><span class="line">       result_msg = f&quot;处理完成！共处理 &#123;self.total_files_to_process&#125; 个文件n&quot;</span><br><span class="line">       result_msg += f&quot;成功: &#123;self.success_count&#125; 个n&quot;</span><br><span class="line">       result_msg += f&quot;失败: &#123;self.failure_count&#125; 个&quot;</span><br><span class="line"></span><br><span class="line">       if self.failed_files:</span><br><span class="line">           result_msg += &quot;nn处理失败的文件：n&quot; + &quot;n&quot;.join(self.failed_files)</span><br><span class="line"></span><br><span class="line">       QMessageBox.information(self, &quot;处理完成&quot;, result_msg)</span><br><span class="line"></span><br><span class="line">       # 重置界面状态</span><br><span class="line">       self.process_button.setEnabled(True)</span><br><span class="line">       self.browse_files_button.setEnabled(True)</span><br><span class="line">       self.browse_folder_button.setEnabled(False)</span><br><span class="line">       self.overwrite_all = None</span><br><span class="line">       self.overwrite_all_checkbox.setChecked(False)</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">   # 确保中文正常显示</span><br><span class="line">   import matplotlib</span><br><span class="line">   matplotlib.rcParams[&quot;font.family&quot;] = [&quot;SimHei&quot;, &quot;WenQuanYi Micro Hei&quot;, &quot;Heiti TC&quot;]</span><br><span class="line"></span><br><span class="line">   app = QApplication(sys.argv)</span><br><span class="line">   window = PdfWatermarkRemoverApp()</span><br><span class="line">   window.show()</span><br><span class="line">   sys.exit(app.exec_())</span><br></pre></td></tr></table></figure></div><p>以上代码实现了一个功能完整的 PDF 水印去除工具，包含了从 PDF 内容提取、水印识别与去除到 Word 文档生成的全流程。工具支持单个文件处理和文件夹批量处理，提供了友好的图形界面和详细的处理状态反馈。你可以直接使用这段代码，也可以根据实际需求进行进一步的定制和优化。</p><p>PS:代码仅供参考，内容不一定正确，要根据实际情况处理喵</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在日常办公和学习中，我们经常会遇到带有水印的 PDF 文档，这些水印不仅影响阅读体验，还可能干扰文档的二次编辑和使用。本文将带你从零开始，一步步构建一个功能完善的 PDF 水印去除工具，实现从单文件处理到批量转换的完整解决方案。&lt;/p&gt;
&lt;p&gt;需求分析：为什么需要 PDF </summary>
      
    
    
    
    <category term="-Python -PDF -Word" scheme="http://example.com/categories/Python-PDF-Word/"/>
    
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
    <category term="PyMuPDF" scheme="http://example.com/tags/PyMuPDF/"/>
    
    <category term="水印去除" scheme="http://example.com/tags/%E6%B0%B4%E5%8D%B0%E5%8E%BB%E9%99%A4/"/>
    
    <category term="PDF处理" scheme="http://example.com/tags/PDF%E5%A4%84%E7%90%86/"/>
    
    <category term="PyQt5" scheme="http://example.com/tags/PyQt5/"/>
    
    <category term="Word" scheme="http://example.com/tags/Word/"/>
    
  </entry>
  
  <entry>
    <title>揭秘xlsxwriter：富文本格式如何精准“染色”？</title>
    <link href="http://example.com/2025/07/16/xlsxwriter%EF%BC%9A%E5%AF%8C%E6%96%87%E6%9C%AC%E6%A0%BC%E5%BC%8F%E5%A6%82%E4%BD%95%E7%B2%BE%E5%87%86%E2%80%9C%E6%9F%93%E8%89%B2%E2%80%9D%EF%BC%9F/"/>
    <id>http://example.com/2025/07/16/xlsxwriter%EF%BC%9A%E5%AF%8C%E6%96%87%E6%9C%AC%E6%A0%BC%E5%BC%8F%E5%A6%82%E4%BD%95%E7%B2%BE%E5%87%86%E2%80%9C%E6%9F%93%E8%89%B2%E2%80%9D%EF%BC%9F/</id>
    <published>2025-07-16T02:48:10.000Z</published>
    <updated>2025-07-17T07:21:29.971Z</updated>
    
    <content type="html"><![CDATA[<p>核心概念</p><p>xlsxwriter 通过<strong>单元格格式</strong>和<strong>文本位置索引</strong>来精确控制文本区间样式，其判定逻辑基于以下关键内容：</p><h3 id="1-文本区间定义方式-xA"><a href="#1-文本区间定义方式-xA" class="headerlink" title="1. 文本区间定义方式&#xA;"></a>1. 文本区间定义方式&#xA;</h3><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 基本语法（非真实代码，仅示意逻辑）</span><br><span class="line">worksheet.write_rich_string(</span><br><span class="line">    row, col,</span><br><span class="line">    [format1, &quot;红色文本&quot;, format2, &quot;普通文本&quot;]</span><br><span class="line">)</span><br></pre></td></tr></table></figure></div><ul><li><p><strong>位置判定</strong>：根据字符串在参数列表中的顺序确定位置</p></li><li><p><strong>格式继承</strong>：格式对象作用于紧随其后的文本段</p></li></ul><h3 id="2-关键判定规则-xA"><a href="#2-关键判定规则-xA" class="headerlink" title="2. 关键判定规则&#xA;"></a>2. 关键判定规则&#xA;</h3><table><thead><tr><th>判定维度&#xA;</th><th>说明&#xA;</th></tr></thead><tbody><tr><td>格式对象位置&#xA;</td><td>格式总是应用于下一个字符串元素&#xA;</td></tr><tr><td>文本分段&#xA;</td><td>每个字符串元素被视为独立文本段&#xA;</td></tr><tr><td>空格式处理&#xA;</td><td>None 或省略格式时继承单元格默认格式&#xA;</td></tr><tr><td>特殊字符&#xA;</td><td>换行符 (\n) 会创建新文本段但不中断格式应用&#xA;</td></tr></tbody></table><h3 id="3-实际应用示例-xA"><a href="#3-实际应用示例-xA" class="headerlink" title="3. 实际应用示例&#xA;"></a>3. 实际应用示例&#xA;</h3><h4 id="案例-1：基础红黑文本-xA"><a href="#案例-1：基础红黑文本-xA" class="headerlink" title="案例 1：基础红黑文本&#xA;"></a>案例 1：基础红黑文本&#xA;</h4><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">red = workbook.add_format(&#123;&#x27;color&#x27;: &#x27;red&#x27;&#125;)</span><br><span class="line">black = workbook.add_format(&#123;&#x27;color&#x27;: &#x27;black&#x27;&#125;)</span><br><span class="line"></span><br><span class="line"># &quot;答案&quot;红色，&quot;:&quot;黑色，&quot;42&quot;红色</span><br><span class="line">worksheet.write_rich_string(&#x27;A1&#x27;,</span><br><span class="line">    red, &#x27;答案&#x27;,</span><br><span class="line">    black, &#x27;:&#x27;,</span><br><span class="line">    red, &#x27;42&#x27;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></div><p>内存中的区间映射：</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[0-2): 红色格式 (对应&quot;答案&quot;)</span><br><span class="line">[2-3): 黑色格式 (对应&quot;:&quot;) </span><br><span class="line">[3-5): 红色格式 (对应&quot;42&quot;)</span><br></pre></td></tr></table></figure></div><h4 id="案例-2：带格式继承的文本-xA"><a href="#案例-2：带格式继承的文本-xA" class="headerlink" title="案例 2：带格式继承的文本&#xA;"></a>案例 2：带格式继承的文本&#xA;</h4><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">bold = workbook.add_format(&#123;&#x27;bold&#x27;: True&#125;)</span><br><span class="line">default = workbook.add_format()</span><br><span class="line"></span><br><span class="line"># &quot;注意&quot;加粗，后续文本默认格式</span><br><span class="line">worksheet.write_rich_string(&#x27;A2&#x27;,</span><br><span class="line">    bold, &#x27;注意&#x27;,</span><br><span class="line">    None, &#x27;：请检查数据&#x27;  # None继承单元格默认格式</span><br><span class="line">)</span><br></pre></td></tr></table></figure></div><h3 id="4-特殊场景处理-xA"><a href="#4-特殊场景处理-xA" class="headerlink" title="4. 特殊场景处理&#xA;"></a>4. 特殊场景处理&#xA;</h3><h4 id="混合格式文本-xA"><a href="#混合格式文本-xA" class="headerlink" title="混合格式文本&#xA;"></a>混合格式文本&#xA;</h4><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 同一单词中部分字母标红</span><br><span class="line">worksheet.write_rich_string(&#x27;A3&#x27;,</span><br><span class="line">    black, &#x27;Pri&#x27;,</span><br><span class="line">    red, &#x27;mar&#x27;,</span><br><span class="line">    black, &#x27;y&#x27;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></div><p>效果：显示为 “Primary” 其中 “mar” 为红色</p><h4 id="动态文本构建-xA"><a href="#动态文本构建-xA" class="headerlink" title="动态文本构建&#xA;"></a>动态文本构建&#xA;</h4><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">parts = [black, &quot;随机值：&quot;]</span><br><span class="line">if highlight:</span><br><span class="line">    parts.extend([red, str(value)])</span><br><span class="line">else:</span><br><span class="line">    parts.extend([black, str(value)])</span><br><span class="line">    </span><br><span class="line">worksheet.write_rich_string(&#x27;A4&#x27;, *parts)</span><br></pre></td></tr></table></figure></div><h3 id="5-底层实现原理-xA"><a href="#5-底层实现原理-xA" class="headerlink" title="5. 底层实现原理&#xA;"></a>5. 底层实现原理&#xA;</h3><ul><li><strong>OpenXML 映射</strong>：最终生成类似以下 XML 结构</li></ul><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;r&gt;</span><br><span class="line">  &lt;rPr&gt;&lt;color rgb=&quot;FFFF0000&quot;/&gt;&lt;/rPr&gt;</span><br><span class="line">  &lt;t&gt;答案&lt;/t&gt;</span><br><span class="line">&lt;/r&gt;</span><br><span class="line">&lt;r&gt;</span><br><span class="line">  &lt;rPr&gt;&lt;color rgb=&quot;FF000000&quot;/&gt;&lt;/rPr&gt;</span><br><span class="line">  &lt;t&gt;:&lt;/t&gt;</span><br><span class="line">&lt;/r&gt;</span><br></pre></td></tr></table></figure></div><ul><li><strong>索引计算</strong>：库内部维护格式栈，根据参数顺序计算每个文本段的起止位置</li></ul><h3 id="6-使用限制与注意事项-xA"><a href="#6-使用限制与注意事项-xA" class="headerlink" title="6. 使用限制与注意事项&#xA;"></a>6. 使用限制与注意事项&#xA;</h3><ul><li><p><strong>不可变特性</strong>：一旦写入无法修改单个文本段格式</p></li><li><p><strong>性能影响</strong>：每个格式变化都会创建新的<code>&lt;r&gt;</code>元素，过多分段影响文件大小</p></li><li><p><strong>边界情况</strong>：</p><ul><li>空字符串仍会占用格式区间</li><li>连续的相同格式不会自动合并</li></ul></li></ul><h3 id="7-调试技巧-xA"><a href="#7-调试技巧-xA" class="headerlink" title="7. 调试技巧&#xA;"></a>7. 调试技巧&#xA;</h3><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 查看实际生成的XML（需要保存文件后解压查看）</span><br><span class="line">workbook.filename = &#x27;output.xlsx&#x27;</span><br><span class="line">workbook.close()</span><br><span class="line"># 解压后查看xl/worksheets/sheet1.xml</span><br></pre></td></tr></table></figure></div><h3 id="最佳实践建议-xA"><a href="#最佳实践建议-xA" class="headerlink" title="最佳实践建议&#xA;"></a>最佳实践建议&#xA;</h3><ul><li><p>批量合并相同格式的文本段</p></li><li><p>对静态内容预先生成格式列表</p></li><li><p>避免单个单元格内超过 20 个格式分段</p></li><li><p>对动态内容使用辅助函数构建参数列表</p></li></ul><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def build_rich_text(text_parts):</span><br><span class="line">    result = []</span><br><span class="line">    for text, fmt in text_parts:</span><br><span class="line">        result.extend([fmt, text])</span><br><span class="line">    return result</span><br></pre></td></tr></table></figure></div><p><strong>注</strong>：与 openpyxl 的 CellRichText 不同，xlsxwriter 采用更底层的格式绑定机制，对文本区间的判定完全基于参数序列顺序，不依赖任何文本标记符号。</p><h3 id="关键要点总结-xA"><a href="#关键要点总结-xA" class="headerlink" title="关键要点总结&#xA;"></a>关键要点总结&#xA;</h3><ol><li><p>xlsxwriter 的文本区间判定是<strong>顺序敏感</strong>的</p></li><li><p>格式对象总是<strong>向前绑定</strong>到下一个文本元素</p></li><li><p>实际渲染时会将文本区间映射为 OpenXML 的<code>&lt;r&gt;</code>元素</p></li><li><p>处理富文本时需要特别注意参数列表的构建顺序</p></li></ol><p>PS:代码仅供参考，内容不一定正确，要根据实际情况处理喵</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;核心概念&lt;/p&gt;
&lt;p&gt;xlsxwriter 通过&lt;strong&gt;单元格格式&lt;/strong&gt;和&lt;strong&gt;文本位置索引&lt;/strong&gt;来精确控制文本区间样式，其判定逻辑基于以下关键内容：&lt;/p&gt;
&lt;h3 id=&quot;1-文本区间定义方式-xA&quot;&gt;&lt;a href=&quot;#1-</summary>
      
    
    
    
    <category term="Python库应用" scheme="http://example.com/categories/Python%E5%BA%93%E5%BA%94%E7%94%A8/"/>
    
    
    <category term="Excel" scheme="http://example.com/tags/Excel/"/>
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
    <category term="xlsxwriter" scheme="http://example.com/tags/xlsxwriter/"/>
    
    <category term="格式化" scheme="http://example.com/tags/%E6%A0%BC%E5%BC%8F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>docker离线部署：穿越网络屏障的容器编排利器</title>
    <link href="http://example.com/2025/07/16/docker%E7%A6%BB%E7%BA%BF%E9%83%A8%E7%BD%B2%EF%BC%9A%E7%A9%BF%E8%B6%8A%E7%BD%91%E7%BB%9C%E5%B1%8F%E9%9A%9C%E7%9A%84%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E5%88%A9%E5%99%A8/"/>
    <id>http://example.com/2025/07/16/docker%E7%A6%BB%E7%BA%BF%E9%83%A8%E7%BD%B2%EF%BC%9A%E7%A9%BF%E8%B6%8A%E7%BD%91%E7%BB%9C%E5%B1%8F%E9%9A%9C%E7%9A%84%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E5%88%A9%E5%99%A8/</id>
    <published>2025-07-16T01:52:06.000Z</published>
    <updated>2025-07-17T07:21:51.249Z</updated>
    
    <content type="html"><![CDATA[<p>一、Docker Compose 离线安装步骤</p><p>在 GitHub 上找到对应的 docker-compose 网站，下载适合当前系统的离线安装包（如 docker-compose-linux-x86_64），并将其放置在 &#x2F;tmp 目录下。</p><h3 id="赋予执行权限并移动至系统路径-xA"><a href="#赋予执行权限并移动至系统路径-xA" class="headerlink" title="赋予执行权限并移动至系统路径&#xA;"></a>赋予执行权限并移动至系统路径&#xA;</h3><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 赋予可执行权限</span><br><span class="line">chmod +x /tmp/docker-compose-linux-x86_64</span><br><span class="line"></span><br><span class="line"># 移动到系统可执行目录</span><br><span class="line">sudo mv /tmp/docker-compose-linux-x86_64 /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure></div><h3 id="验证安装结果-xA"><a href="#验证安装结果-xA" class="headerlink" title="验证安装结果&#xA;"></a>验证安装结果&#xA;</h3><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker-compose --version</span><br><span class="line"># 输出示例：docker-compose version 2.20.3, build a8266d3</span><br></pre></td></tr></table></figure></div><p>二、常见问题与解决方法</p><h3 id="权限不足问题-xA"><a href="#权限不足问题-xA" class="headerlink" title="权限不足问题&#xA;"></a>权限不足问题&#xA;</h3><h4 id="问题-xA"><a href="#问题-xA" class="headerlink" title="问题&#xA;"></a>问题&#xA;</h4><p>执行 mv 时提示权限错误。</p><h4 id="解决-xA"><a href="#解决-xA" class="headerlink" title="解决&#xA;"></a>解决&#xA;</h4><p>使用 sudo 命令获取管理员权限：</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mv /tmp/docker-compose-linux-x86_64 /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure></div><h3 id="命令不存在问题-xA"><a href="#命令不存在问题-xA" class="headerlink" title="命令不存在问题&#xA;"></a>命令不存在问题&#xA;</h3><h4 id="问题-xA-1"><a href="#问题-xA-1" class="headerlink" title="问题&#xA;"></a>问题&#xA;</h4><p>输入 docker-compose 提示命令未找到。</p><h4 id="解决-xA-1"><a href="#解决-xA-1" class="headerlink" title="解决&#xA;"></a>解决&#xA;</h4><p>检查系统路径是否包含 &#x2F;usr&#x2F;local&#x2F;bin：</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo $PATH  # 若不含 /usr/local/bin，添加至环境变量</span><br><span class="line">export PATH=$PATH:/usr/local/bin</span><br></pre></td></tr></table></figure></div><h3 id="文件名空格问题-xA"><a href="#文件名空格问题-xA" class="headerlink" title="文件名空格问题&#xA;"></a>文件名空格问题&#xA;</h3><h4 id="问题-xA-2"><a href="#问题-xA-2" class="headerlink" title="问题&#xA;"></a>问题&#xA;</h4><p>脚本文件名含前导空格导致命令失败。</p><h4 id="解决-xA-2"><a href="#解决-xA-2" class="headerlink" title="解决&#xA;"></a>解决&#xA;</h4><p>重命名文件去除空格：</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv &#x27; replace_image_registry.sh&#x27; replace_image_registry.sh</span><br></pre></td></tr></table></figure></div><p>三、核心命令总结</p><h3 id="安装核心步骤-xA"><a href="#安装核心步骤-xA" class="headerlink" title="安装核心步骤&#xA;"></a>安装核心步骤&#xA;</h3><p>下载 → 赋权 → 移动 → 验证</p><h3 id="关键命令-xA"><a href="#关键命令-xA" class="headerlink" title="关键命令&#xA;"></a>关键命令&#xA;</h3><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chmod +x /tmp/docker-compose-linux-x86_64</span><br><span class="line">sudo mv /tmp/docker-compose-linux-x86_64 /usr/local/bin/docker-compose</span><br><span class="line">docker-compose --version</span><br></pre></td></tr></table></figure></div><p>PS:代码仅供参考，内容不一定正确，要根据实际情况处理喵</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;一、Docker Compose 离线安装步骤&lt;/p&gt;
&lt;p&gt;在 GitHub 上找到对应的 docker-compose 网站，下载适合当前系统的离线安装包（如 docker-compose-linux-x86_64），并将其放置在 &amp;#x2F;tmp 目录下。&lt;/p&gt;
</summary>
      
    
    
    
    <category term="容器技术" scheme="http://example.com/categories/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/"/>
    
    <category term="部署实践" scheme="http://example.com/categories/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/%E9%83%A8%E7%BD%B2%E5%AE%9E%E8%B7%B5/"/>
    
    
    <category term="Docker Compose" scheme="http://example.com/tags/Docker-Compose/"/>
    
    <category term="离线安装" scheme="http://example.com/tags/%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85/"/>
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Portainer容器管理实战：从镜像加速到安全部署</title>
    <link href="http://example.com/2025/07/15/Portainer%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86%E5%AE%9E%E6%88%98%EF%BC%9A%E4%BB%8E%E9%95%9C%E5%83%8F%E5%8A%A0%E9%80%9F%E5%88%B0%E5%AE%89%E5%85%A8%E9%83%A8%E7%BD%B2/"/>
    <id>http://example.com/2025/07/15/Portainer%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86%E5%AE%9E%E6%88%98%EF%BC%9A%E4%BB%8E%E9%95%9C%E5%83%8F%E5%8A%A0%E9%80%9F%E5%88%B0%E5%AE%89%E5%85%A8%E9%83%A8%E7%BD%B2/</id>
    <published>2025-07-15T09:50:31.000Z</published>
    <updated>2025-07-17T07:21:47.120Z</updated>
    
    <content type="html"><![CDATA[<p>一、背景：为什么选择从第三方镜像源拉取 Portainer？</p><p>近期在学习容器管理工具 Portainer 时，参考了一篇技术教程（知乎链接：<a class="link"   href="https://zhuanlan.zhihu.com/p/27740131259" >https://zhuanlan.zhi<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><a class="link"   href="https://zhuanlan.zhihu.com/p/27740131259" >hu<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><a class="link"   href="https://zhuanlan.zhihu.com/p/27740131259" >.com&#x2F;<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><a class="link"   href="https://zhuanlan.zhihu.com/p/27740131259" >p&#x2F;2<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><a class="link"   href="https://zhuanlan.zhihu.com/p/27740131259" >7740<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><a class="link"   href="https://zhuanlan.zhihu.com/p/27740131259" >1312<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><a class="link"   href="https://zhuanlan.zhihu.com/p/27740131259" >59<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>），教程中推荐使用官方镜像源部署。但由于网络环境限制，尝试从第三方镜像源<code>docker.1ms.run</code>拉取 Portainer 镜像，意外发现该镜像源提供了更稳定的下载速度，因此记录下完整操作流程，供遇到类似问题的开发者参考。</p><p>二、操作步骤：从镜像拉取到容器启动的全流程</p><h3 id="1-拉取-Portainer-镜像-xA"><a href="#1-拉取-Portainer-镜像-xA" class="headerlink" title="1. 拉取 Portainer 镜像&#xA;"></a>1. 拉取 Portainer 镜像&#xA;</h3><p>通常情况下，Portainer 官方镜像的拉取命令为：</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull portainer/portainer-ce:latest</span><br></pre></td></tr></table></figure></div><p>但本次尝试使用第三方镜像源：</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull docker.1ms.run/portainer/portainer-ce:latest</span><br></pre></td></tr></table></figure></div><p><strong>注意事项：</strong></p><ul><li>第三方镜像源可能存在安全风险，建议优先使用官方镜像（<code>portainer/portainer-ce</code>）。</li><li>若拉取失败，可检查镜像源是否可用（如执行<code>ping docker.1ms.run</code>），或切换至国内加速源（如 Docker 中国镜像站）。</li></ul><h3 id="2-验证镜像是否成功拉取-xA"><a href="#2-验证镜像是否成功拉取-xA" class="headerlink" title="2. 验证镜像是否成功拉取&#xA;"></a>2. 验证镜像是否成功拉取&#xA;</h3><p>通过<code>docker images</code>命令查看本地镜像列表：</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure></div><h3 id="3-启动-Portainer-容器-xA"><a href="#3-启动-Portainer-容器-xA" class="headerlink" title="3. 启动 Portainer 容器&#xA;"></a>3. 启动 Portainer 容器&#xA;</h3><p>使用以下命令启动容器，并配置挂载与端口映射：</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">  --name portainer \</span><br><span class="line">  -p 9000:9000 \</span><br><span class="line">  -v /var/run/docker.sock:/var/run/docker.sock \</span><br><span class="line">  -v portainer_data:/data \</span><br><span class="line">  --restart=always \</span><br><span class="line">  docker.1ms.run/portainer/portainer-ce:latest</span><br></pre></td></tr></table></figure></div><p><strong>参数解析：</strong></p><ul><li><p><code>-d</code>：后台运行容器；</p></li><li><p><code>-p 9000:9000</code>：映射宿主机 9000 端口到容器 9000 端口，用于访问 Web 界面；</p></li><li><p><code>-v /var/run/docker.sock:/var/run/docker.sock</code>：挂载 Docker 套接字，允许 Portainer 管理宿主机 Docker 环境；</p></li><li><p><code>-v portainer_data:/data</code>：创建数据卷持久化存储 Portainer 配置；</p></li><li><p><code>--restart=always</code>：确保容器随系统重启自动运行。</p></li></ul><h3 id="4-访问-Portainer-Web-界面-xA"><a href="#4-访问-Portainer-Web-界面-xA" class="headerlink" title="4. 访问 Portainer Web 界面&#xA;"></a>4. 访问 Portainer Web 界面&#xA;</h3><p>容器启动后，在浏览器中输入<code>http://宿主机IP:9000</code>，首次访问需设置管理员密码，随后进入 Portainer 管理界面。</p><p>三、遇到的问题与解决方案</p><h3 id="1-镜像拉取失败：manifest-unknown-xA"><a href="#1-镜像拉取失败：manifest-unknown-xA" class="headerlink" title="1. 镜像拉取失败：manifest unknown&#xA;"></a>1. 镜像拉取失败：manifest unknown&#xA;</h3><p><strong>错误信息：</strong></p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error response from daemon: manifest for docker.1ms.run/portainer-ce:latest not found: manifest unknown</span><br></pre></td></tr></table></figure></div><p><strong>原因：</strong></p><p>镜像源中无该镜像，或镜像名称拼写错误（如<code>portainer-ce</code>写成<code>portainer</code>）。</p><p><strong>解决方法：</strong></p><p>确认镜像名称正确性，或更换为官方镜像源拉取：</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull portainer/portainer-ce:latest</span><br></pre></td></tr></table></figure></div><h3 id="2-Docker-Hub-连接超时-xA"><a href="#2-Docker-Hub-连接超时-xA" class="headerlink" title="2. Docker Hub 连接超时&#xA;"></a>2. Docker Hub 连接超时&#xA;</h3><p><strong>错误信息：</strong></p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error response from daemon: Get &quot;https://registry-1.docker.io/v2/&quot;: context deadline exceeded</span><br></pre></td></tr></table></figure></div><p><strong>解决方法：</strong></p><p>配置国内镜像加速源，编辑<code>/etc/docker/daemon.json</code>添加：</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://registry.docker-cn.com&quot;, &quot;https://docker.mirrors.ustc.edu.cn&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>重启 Docker 服务：<code>sudo systemctl restart docker</code>。</p><p>四、使用第三方镜像源的风险与建议</p><ul><li><p><strong>安全风险</strong>：第三方镜像源可能被篡改，建议优先使用官方镜像（<code>portainer/portainer-ce</code>）。</p></li><li><p><strong>版本兼容性</strong>：第三方镜像可能非最新版本，建议定期通过<code>docker pull</code>更新镜像。</p></li><li><p><strong>网络稳定性</strong>：若第三方源频繁失效，优先使用官方源或国内大厂加速源（如阿里云、腾讯云镜像站）。</p></li></ul><p>五、总结：Portainer 的价值与容器管理实践</p><p>通过 Docker 部署 Portainer 后，可直观管理容器、镜像、网络及数据卷，尤其适合新手快速上手容器化部署。本次从第三方镜像源拉取的经历表明：技术实践中需在效率与安全性间权衡，建议在测试环境尝试非官方源，生产环境务必使用官方可信镜像。</p><p>后续可进一步探索 Portainer 的 Kubernetes 管理、RBAC 权限控制等高级功能，提升容器化应用的部署与运维效率。</p><p>PS:代码仅供参考，内容不一定正确，要根据实际情况处理喵</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;一、背景：为什么选择从第三方镜像源拉取 Portainer？&lt;/p&gt;
&lt;p&gt;近期在学习容器管理工具 Portainer 时，参考了一篇技术教程（知乎链接：&lt;a class=&quot;link&quot;   href=&quot;https://zhuanlan.zhihu.com/p/2774013</summary>
      
    
    
    
    <category term="Docker实践" scheme="http://example.com/categories/Docker%E5%AE%9E%E8%B7%B5/"/>
    
    
    <category term="Docker" scheme="http://example.com/tags/Docker/"/>
    
    <category term="Portainer" scheme="http://example.com/tags/Portainer/"/>
    
    <category term="镜像加速" scheme="http://example.com/tags/%E9%95%9C%E5%83%8F%E5%8A%A0%E9%80%9F/"/>
    
    <category term="容器管理" scheme="http://example.com/tags/%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Python 魔法：一键让 Excel 正确选项「脸红」</title>
    <link href="http://example.com/2025/07/15/Python-%E9%AD%94%E6%B3%95%EF%BC%9A%E4%B8%80%E9%94%AE%E8%AE%A9-Excel-%E6%AD%A3%E7%A1%AE%E9%80%89%E9%A1%B9%E3%80%8C%E8%84%B8%E7%BA%A2%E3%80%8D/"/>
    <id>http://example.com/2025/07/15/Python-%E9%AD%94%E6%B3%95%EF%BC%9A%E4%B8%80%E9%94%AE%E8%AE%A9-Excel-%E6%AD%A3%E7%A1%AE%E9%80%89%E9%A1%B9%E3%80%8C%E8%84%B8%E7%BA%A2%E3%80%8D/</id>
    <published>2025-07-15T09:21:07.000Z</published>
    <updated>2025-07-17T07:21:43.592Z</updated>
    
    <content type="html"><![CDATA[<p>在数据处理工作中，我们经常需要处理 Excel 文件中的试题数据，特别是需要对正确答案进行特殊标记。本文将分享我从最初实现到最终优化的完整改进过程。</p><p>初始需求</p><p>我们需要处理一个包含试题的 Excel 文件，具体要求：</p><ul><li><p>文件包含 “试题选项” 和 “试题答案” 两列</p></li><li><p>试题选项用 “$;$” 分隔多个选项</p></li><li><p>需要根据 “试题答案” 将正确答案标记为红色</p></li><li><p>处理后的结果直接修改原文件</p></li></ul><p>第一版实现</p><h3 id="核心思路：-xA"><a href="#核心思路：-xA" class="headerlink" title="核心思路：&#xA;"></a>核心思路：&#xA;</h3><ul><li><p>使用 pandas 读取 Excel 文件</p></li><li><p>用 openpyxl 修改原文件样式</p></li><li><p>在正确答案前后添加 “**” 标记</p></li><li><p>提示用户手动替换 “**” 为红色格式</p></li></ul><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 主要处理逻辑</span><br><span class="line">marked_options = []</span><br><span class="line">for i, option in enumerate(options):</span><br><span class="line">    if i in correct_indices:</span><br><span class="line">        marked_options.append(f&quot;**&#123;option&#125;**&quot;)  # 用**标记正确答案</span><br><span class="line">    else:</span><br><span class="line">        marked_options.append(option)</span><br><span class="line">cell.value = &#x27;$;$&#x27;.join(marked_options)</span><br></pre></td></tr></table></figure></div><p><strong>问题：</strong></p><p>不能自动设置红色，需要用户手动替换，** 的标记方式不够直观</p><p>第二版改进</p><h3 id="改进点：-xA"><a href="#改进点：-xA" class="headerlink" title="改进点：&#xA;"></a>改进点：&#xA;</h3><ul><li><p>改用 xlsxwriter 引擎</p></li><li><p>直接处理 ** 标记的内容并设置为红色</p></li><li><p>保留 ** 标记</p></li></ul><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 使用正则匹配**内容并设置格式</span><br><span class="line">for match in re.finditer(r&#x27;\*\*(.*?)\*\*&#x27;, cell_value):</span><br><span class="line">    parts.append(&#123;</span><br><span class="line">        &#x27;text&#x27;: f&quot;**&#123;match.group(1)&#125;**&quot;,</span><br><span class="line">        &#x27;format&#x27;: red_format</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure></div><p><strong>问题：</strong></p><p>使用 ** 将正确答案括起来的话，xlsxwriter 无法非常准确地解析出来，因为答案可能是 <strong>A</strong>$;$B$;$C$;$<strong>D</strong> 这样子的，相同的符号会干扰它的判断，从而导致效果不好</p><p>最终版改进</p><h3 id="改进思路：-xA"><a href="#改进思路：-xA" class="headerlink" title="改进思路：&#xA;"></a>改进思路：&#xA;</h3><ul><li><p>改回使用 openpyxl</p></li><li><p>正确答案用 [] 标记</p></li><li><p>非正确答案不做标记</p></li></ul><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">marked_options = []</span><br><span class="line">for i, option in enumerate(options):</span><br><span class="line">    if i in correct_indices:</span><br><span class="line">        marked_options.append(f&quot;[&#123;option&#125;]&quot;)  # 正确答案标记</span><br><span class="line">    else:</span><br><span class="line">        marked_options.append(option)</span><br></pre></td></tr></table></figure></div><p>然后再进行标红处理：</p><ul><li><p>使用富文本 (CellRichText) 直接设置红色</p></li><li><p>自动移除 [] 标记</p></li><li><p>添加异常处理，失败时回退到普通文本</p></li><li><p>更友好的提示信息</p></li></ul><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">rich_text = CellRichText()</span><br><span class="line">for i, option in enumerate(options):</span><br><span class="line">    if i &gt; 0:</span><br><span class="line">        rich_text.append(&#x27;$;$&#x27;)</span><br><span class="line">    clean_option = option.replace(&#x27;[&#x27;, &#x27;&#x27;).replace(&#x27;]&#x27;, &#x27;&#x27;)</span><br><span class="line">    if i in correct_indices:</span><br><span class="line">        rich_text.append(TextBlock(inline_red_font, clean_option))</span><br><span class="line">    else:</span><br><span class="line">        rich_text.append(clean_option)</span><br><span class="line">cell.value = rich_text</span><br></pre></td></tr></table></figure></div><h3 id="关键改进点：-xA"><a href="#关键改进点：-xA" class="headerlink" title="关键改进点：&#xA;"></a>关键改进点：&#xA;</h3><ul><li><p><strong>富文本支持</strong>：使用 CellRichText 和 TextBlock 实现对单个字符的样式设置</p></li><li><p><strong>自动清理</strong>：移除选项中的 [] 标记</p></li></ul><p>拓展功能：标记检查与统一分隔符</p><p>在最终版的基础上，我进一步完善了代码，增加了两项重要的功能：统一处理非标准分隔符和全面的标记检查报告。这使得整个流程更加健壮和智能化。</p><h3 id="1-统一分隔符-xA"><a href="#1-统一分隔符-xA" class="headerlink" title="1. 统一分隔符&#xA;"></a>1. 统一分隔符&#xA;</h3><p>很多时候，Excel 中的选项分隔符可能不统一，除了标准的$;$，还可能出现$;、$$等，甚至单空格加 $ 等多种形式。为了确保选项能够被正确解析，我加入了强大的正则表达式来识别并统一这些非标准分隔符为 $;$。</p><p>实现方式：使用 re.compile 定义了一个详细的正则表达式 separator_pattern，涵盖了多种常见的非标准分隔符。</p><p>效果：在处理每个选项字符串时，首先使用 separator_pattern.sub (‘$;$’, options_str) 将所有识别到的非标准分隔符统一替换为 $;$ 。这大大提高了数据处理的鲁棒性，减少了因格式不一致导致的问题。</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 正则表达式定义</span><br><span class="line">separator_pattern = re.compile(r&#x27;&#x27;&#x27;</span><br><span class="line">    \$;\$|       # 标准 $;$</span><br><span class="line">    \$[:：]\$|   # $:$ 或 $：$</span><br><span class="line">    ;\$|         # ;$</span><br><span class="line">    \$；|        # $；</span><br><span class="line">    [；:：]\$|   # ；$ 或 ：$</span><br><span class="line">    \$[;；:：]|  # $; 或 $；或 $: 或 $：</span><br><span class="line">    \$\$|        # $$</span><br><span class="line">    \s&#123;2,&#125;|      # 两个或更多空格</span><br><span class="line">    \$\s|\s\$|   # $ 后或前有单个空格</span><br><span class="line">    ;           # 单独的分号</span><br><span class="line">&#x27;&#x27;&#x27;, re.VERBOSE)</span><br><span class="line"></span><br><span class="line"># 替换处理</span><br><span class="line">modified_str = separator_pattern.sub(&#x27;$;$&#x27;, options_str)</span><br></pre></td></tr></table></figure></div><h3 id="2-标记检查报告-xA"><a href="#2-标记检查报告-xA" class="headerlink" title="2. 标记检查报告&#xA;"></a>2. 标记检查报告&#xA;</h3><p>仅仅对正确答案进行标记是不够的，我们还需要验证标记是否正确、是否有遗漏。此功能可以生成详细的报告，指出 “正确答案未被标记” 和 “错误答案被标记” 的情况。</p><h4 id="核心逻辑优化：-xA"><a href="#核心逻辑优化：-xA" class="headerlink" title="核心逻辑优化：&#xA;"></a>核心逻辑优化：&#xA;</h4><ul><li><p><strong>未标记检查</strong>：传统的检查方法是看 “标记索引” 中是否包含正确答案的索引。但如果正确答案完全没有被标记（即选项中根本没有 []），这种方法就无法识别。新的逻辑直接检查正确答案的选项内容是否被 [] 包裹 。只要正确答案未被 [] 包裹，无论是否有其他标记动作，都会被识别为 “未标记” 。</p></li><li><p><strong>错误标记检查</strong>：检查所有被 [] 包裹的选项，如果其索引不在正确答案的索引列表中，则视为错误标记 。</p></li></ul><h4 id="输出报告：-xA"><a href="#输出报告：-xA" class="headerlink" title="输出报告：&#xA;"></a>输出报告：&#xA;</h4><p>生成清晰的报告，包含：</p><ul><li><p>检查的总行数 。</p></li><li><p>“未标记正确答案的行” 数量及具体详情（Excel 行号、应标记的字母、未被包裹的实际内容） 。</p></li><li><p>“错误标记的行” 数量及具体详情（Excel 行号、错误标记的内容、正确的答案） 。</p></li></ul><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#未标记检查代码：</span><br><span class="line">has_unmarked = False</span><br><span class="line">for i in correct_indices:</span><br><span class="line">    opt = options[i]</span><br><span class="line">    if not (opt.strip().startswith(&#x27;[&#x27;) and opt.strip().endswith(&#x27;]&#x27;)):</span><br><span class="line">        has_unmarked = True</span><br><span class="line">        break</span><br><span class="line">if has_unmarked:</span><br><span class="line">    unmarked_rows.append(&#123;</span><br><span class="line">        &#x27;row&#x27;: row_num,</span><br><span class="line">        &#x27;expected&#x27;: [chr(65 + i) for i in correct_indices],</span><br><span class="line">        &#x27;actual&#x27;: [options[i].strip() for i in correct_indices]</span><br><span class="line">    &#125;)</span><br><span class="line">#错误标记检查代码：</span><br><span class="line">marked_indices = []</span><br><span class="line">for i, opt in enumerate(options):</span><br><span class="line">    if opt.strip().startswith(&#x27;[&#x27;) and opt.strip().endswith(&#x27;]&#x27;):</span><br><span class="line">        marked_indices.append(i)</span><br><span class="line"></span><br><span class="line">for i in marked_indices:</span><br><span class="line">    if i not in correct_indices:</span><br><span class="line">        wrong_marking.append(&#123;</span><br><span class="line">            &#x27;row&#x27;: row_num,</span><br><span class="line">            &#x27;wrong_marked&#x27;: options[i].strip(),</span><br><span class="line">            &#x27;correct&#x27;: [chr(65 + i) for i in correct_indices]</span><br><span class="line">        &#125;)</span><br><span class="line">        break</span><br></pre></td></tr></table></figure></div><h4 id="验证示例：-xA"><a href="#验证示例：-xA" class="headerlink" title="验证示例：&#xA;"></a>验证示例：&#xA;</h4><p>如果一个 Excel 行的正确答案是 D，但选项 D 没有被 [] 包裹，运行代码后会输出：</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">=== 标记检查报告 ===</span><br><span class="line">共检查 1000 行数据</span><br><span class="line"></span><br><span class="line">1. 未标记正确答案的行: 1 行</span><br><span class="line">    行X: 应标记[&#x27;D&#x27;]（内容：D、xxxxxxxx）未被[]包裹</span><br><span class="line"></span><br><span class="line">2. 错误标记的行: 0 行</span><br></pre></td></tr></table></figure></div><p>这使得我们能够精准识别 “应该标记但完全没标记” 的情况 。</p><p>PS:代码仅供参考，内容不一定正确，要根据实际情况处理喵</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在数据处理工作中，我们经常需要处理 Excel 文件中的试题数据，特别是需要对正确答案进行特殊标记。本文将分享我从最初实现到最终优化的完整改进过程。&lt;/p&gt;
&lt;p&gt;初始需求&lt;/p&gt;
&lt;p&gt;我们需要处理一个包含试题的 Excel 文件，具体要求：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;</summary>
      
    
    
    
    <category term="Excel" scheme="http://example.com/categories/Excel/"/>
    
    <category term="Python" scheme="http://example.com/categories/Excel/Python/"/>
    
    <category term="数据处理" scheme="http://example.com/categories/Excel/Python/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"/>
    
    
    <category term="Excel" scheme="http://example.com/tags/Excel/"/>
    
    <category term="Pandas" scheme="http://example.com/tags/Pandas/"/>
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
    <category term="Openpyxl" scheme="http://example.com/tags/Openpyxl/"/>
    
    <category term="Xlsxwriter" scheme="http://example.com/tags/Xlsxwriter/"/>
    
    <category term="正则表达式" scheme="http://example.com/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Python 魔法：一键让 Excel 正确选项「脸红」</title>
    <link href="http://example.com/2025/07/15/Python%E9%AD%94%E6%B3%95%EF%BC%9A%E5%A6%82%E4%BD%95%E7%94%A8%E7%89%B9%E5%BE%81%E8%AF%86%E5%88%AB%E8%AE%A9PDF%E6%B0%B4%E5%8D%B0%E9%9A%90%E5%BD%A2%EF%BC%9F/"/>
    <id>http://example.com/2025/07/15/Python%E9%AD%94%E6%B3%95%EF%BC%9A%E5%A6%82%E4%BD%95%E7%94%A8%E7%89%B9%E5%BE%81%E8%AF%86%E5%88%AB%E8%AE%A9PDF%E6%B0%B4%E5%8D%B0%E9%9A%90%E5%BD%A2%EF%BC%9F/</id>
    <published>2025-07-15T09:21:07.000Z</published>
    <updated>2025-07-17T07:21:39.721Z</updated>
    
    <content type="html"><![CDATA[<p>在日常工作中，我们经常会遇到带有特定特征的 PDF 水印，比如固定的字体大小、倾斜角度、透明度和颜色。这些特性为我们提供了更精准地识别水印的依据。今天，我们就来深入探讨如何利用 PyMuPDF (Fitz) 库，基于这些特征实现 PDF 水印的精确识别和去除，并整合多种实用方法，帮你应对不同场景。</p><p>特定特征水印的识别原理</p><p>PDF 文件中的文本和图形对象都包含了丰富的元数据信息，例如字体大小、旋转角度、透明度和颜色。当水印具有固定特征时，我们可以通过以下步骤实现精准识别：</p><ol><li><p><strong>解析 PDF 页面内容</strong>： 获取页面上所有的文本和图形对象。</p></li><li><p><strong>提取对象特征</strong>： 获取每个对象的字体大小、旋转角度、透明度和颜色等信息。</p></li><li><p><strong>特征匹配</strong>： 将提取到的特征与我们已知的水印特征进行比对。</p></li><li><p><strong>处理匹配对象</strong>： 对符合水印特征的对象进行删除或覆盖处理。</p></li></ol><p>典型的 PDF 水印通常具备以下特征：</p><ul><li><p>📐 固定倾斜角度 (常见 15-45 度)</p></li><li><p>🎨 固定颜色 (常见浅灰色 #C0C0C0)</p></li><li><p>🌫 固定透明度 (约 30-50%)</p></li><li><p>🔠 固定字体大小 (通常较大)</p></li><li><p>🔄 重复出现在每一页相同位置</p></li></ul><p>使用 PyMuPDF 实现基于特征的水印处理</p><h3 id="方法一：基于字体大小和旋转角度的水印识别-xA"><a href="#方法一：基于字体大小和旋转角度的水印识别-xA" class="headerlink" title="方法一：基于字体大小和旋转角度的水印识别&#xA;"></a>方法一：基于字体大小和旋转角度的水印识别&#xA;</h3><p>这个方法非常适合那些字体大小和倾斜角度都比较固定的水印。</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import fitz</span><br><span class="line">import math</span><br><span class="line"></span><br><span class="line">def remove_watermark_by_font_size_and_rotation(input_pdf, output_pdf, font_size, rotation_angle):</span><br><span class="line">    doc = fitz.open(input_pdf)</span><br><span class="line">    for page in doc:</span><br><span class="line">        text_infos = page.get_text(&quot;dict&quot;)</span><br><span class="line">        for block in text_infos[&quot;blocks&quot;]:</span><br><span class="line">            if &quot;lines&quot; in block:</span><br><span class="line">                for line in block[&quot;lines&quot;]:</span><br><span class="line">                    for span in line[&quot;spans&quot;]:</span><br><span class="line">                        current_size = span[&quot;size&quot;]</span><br><span class="line">                        matrix = fitz.Matrix(span[&quot;matrix&quot;])</span><br><span class="line">                        current_rotation = math.degrees(math.atan2(matrix.b, matrix.a))</span><br><span class="line">                        if (abs(current_size - font_size) &lt; 1.5 and </span><br><span class="line">                            abs(current_rotation - rotation_angle) &lt; 5.0):</span><br><span class="line">                            page.add_redact_annot(fitz.Rect(span[&quot;bbox&quot;]), text=&quot;&quot;)</span><br><span class="line">        page.apply_redactions()</span><br><span class="line">    doc.save(output_pdf)</span><br><span class="line">    doc.close()</span><br></pre></td></tr></table></figure></div><p><strong>代码解析</strong>：</p><ul><li><p>我们使用 <code>page.get_text(&quot;dict&quot;)</code> 获取页面上所有的文本信息，包括它们的各种属性。</p></li><li><p>从文本跨度 (span) 中提取 字体大小 和 变换矩阵。</p></li><li><p>通过分解变换矩阵来计算文本的 旋转角度。这里使用了 <code>math.atan2(matrix.b, matrix.a)</code> 来更准确地获取旋转角度。</p></li><li><p>将提取到的特征与你已知的水印特征进行比较，如果匹配（并允许一定的误差范围），就用一个空白矩形覆盖水印区域。</p></li></ul><p><strong>难易度</strong>：★★★☆☆</p><p><strong>优点</strong>： 对具有固定字体大小和倾斜角度的水印效果特别好，误判率低。</p><p><strong>缺点</strong>： 需要你预先知道水印的字体大小和旋转角度参数。</p><h3 id="方法二：基于透明度和颜色的水印识别-xA"><a href="#方法二：基于透明度和颜色的水印识别-xA" class="headerlink" title="方法二：基于透明度和颜色的水印识别&#xA;"></a>方法二：基于透明度和颜色的水印识别&#xA;</h3><p>这种方法适用于那些有固定透明度和颜色的水印，特别是半透明的浅色水印。</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import fitz</span><br><span class="line"></span><br><span class="line">def remove_watermark_by_opacity_and_color(input_pdf, output_pdf, opacity_threshold, color_rgb_target, color_tolerance=10):</span><br><span class="line">    doc = fitz.open(input_pdf)</span><br><span class="line">    for page in doc:</span><br><span class="line">        text_infos = page.get_text(&quot;dict&quot;)</span><br><span class="line">        for block in text_infos[&quot;blocks&quot;]:</span><br><span class="line">            if &quot;lines&quot; in block:</span><br><span class="line">                for line in block[&quot;lines&quot;]:</span><br><span class="line">                    for span in line[&quot;spans&quot;]:</span><br><span class="line">                        color_int = span[&quot;color&quot;]</span><br><span class="line">                        r = (color_int &gt;&gt; 16) &amp; 0xFF</span><br><span class="line">                        g = (color_int &gt;&gt; 8) &amp; 0xFF</span><br><span class="line">                        b = color_int &amp; 0xFF</span><br><span class="line">                        current_color_rgb = (r, g, b)</span><br><span class="line">                        color_match = (</span><br><span class="line">                            abs(current_color_rgb[0] - color_rgb_target[0]) &lt;= color_tolerance and</span><br><span class="line">                            abs(current_color_rgb[1] - color_rgb_target[1]) &lt;= color_tolerance and</span><br><span class="line">                            abs(current_color_rgb[2] - color_rgb_target[2]) &lt;= color_tolerance</span><br><span class="line">                        )</span><br><span class="line">                        if color_match:</span><br><span class="line">                            page.add_redact_annot(fitz.Rect(span[&quot;bbox&quot;]), text=&quot;&quot;)</span><br><span class="line">        page.apply_redactions()</span><br><span class="line">    doc.save(output_pdf)</span><br><span class="line">    doc.close()</span><br></pre></td></tr></table></figure></div><p><strong>代码解析</strong>：</p><ul><li><p>我们从文本跨度中提取 RGB 颜色值。</p></li><li><p>注意： 直接从 span 中提取透明度信息在 PyMuPDF 中比较复杂，因为它通常是 PDF 内容流中的图形状态参数。为了实现真正的透明度识别，你可能需要渲染页面为图像后分析像素的 alpha 通道，或者进行更复杂的 PDF 内容流解析。在上面的代码中，我暂时移除了透明度的判断，主要依赖颜色匹配。</p></li><li><p>比较提取的颜色与已知水印特征，并设置一个容差范围。</p></li></ul><p><strong>难易度</strong>：★★★★☆</p><p><strong>优点</strong>： 对具有固定颜色（特别是浅色）的水印效果好。</p><p><strong>缺点</strong>： 透明度提取是难点，可能需要深入解析 PDF 内部结构或借助图像处理库。</p><h3 id="方法三：综合多特征的水印识别-xA"><a href="#方法三：综合多特征的水印识别-xA" class="headerlink" title="方法三：综合多特征的水印识别&#xA;"></a>方法三：综合多特征的水印识别&#xA;</h3><p>当水印特征明确且固定时，这个方法能提供最高的识别准确性，因为它结合了多种特征进行判断。</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">import fitz</span><br><span class="line">import math</span><br><span class="line"></span><br><span class="line">def remove_watermark_by_multiple_features(input_pdf, output_pdf,</span><br><span class="line">                                        font_size, rotation_angle,</span><br><span class="line">                                        color_rgb,</span><br><span class="line">                                        size_tolerance=1.5, rotation_tolerance=5.0, color_tolerance=10):</span><br><span class="line">    doc = fitz.open(input_pdf)</span><br><span class="line">    for page in doc:</span><br><span class="line">        text_infos = page.get_text(&quot;dict&quot;)</span><br><span class="line">        for block in text_infos[&quot;blocks&quot;]:</span><br><span class="line">            if &quot;lines&quot; in block:</span><br><span class="line">                for line in block[&quot;lines&quot;]:</span><br><span class="line">                    for span in line[&quot;spans&quot;]:</span><br><span class="line">                        current_size = span[&quot;size&quot;]</span><br><span class="line">                        matrix = fitz.Matrix(span[&quot;matrix&quot;])</span><br><span class="line">                        current_rotation = math.degrees(math.atan2(matrix.b, matrix.a))</span><br><span class="line">                        color_int = span[&quot;color&quot;]</span><br><span class="line">                        r = (color_int &gt;&gt; 16) &amp; 0xFF</span><br><span class="line">                        g = (color_int &gt;&gt; 8) &amp; 0xFF</span><br><span class="line">                        b = color_int &amp; 0xFF</span><br><span class="line">                        current_color_rgb = (r, g, b)</span><br><span class="line">                        size_match = abs(current_size - font_size) &lt; size_tolerance</span><br><span class="line">                        rotation_match = abs(current_rotation - rotation_angle) &lt; rotation_tolerance</span><br><span class="line">                        color_match = (</span><br><span class="line">                            abs(current_color_rgb[0] - color_rgb[0]) &lt;= color_tolerance and</span><br><span class="line">                            abs(current_color_rgb[1] - color_rgb[1]) &lt;= color_tolerance and</span><br><span class="line">                            abs(current_color_rgb[2] - color_rgb[2]) &lt;= color_tolerance</span><br><span class="line">                        )</span><br><span class="line">                        if size_match and rotation_match and color_match:</span><br><span class="line">                            page.add_redact_annot(fitz.Rect(span[&quot;bbox&quot;]), text=&quot;&quot;)</span><br><span class="line">        page.apply_redactions()</span><br><span class="line">    doc.save(output_pdf)</span><br><span class="line">    doc.close()</span><br></pre></td></tr></table></figure></div><p><strong>代码解析</strong>：</p><ul><li><p>综合提取字体大小、旋转角度和颜色三个特征（为了简化和实用性，移除了直接在 span 中获取的透明度判断）。</p></li><li><p>设置了合理的匹配容差范围，你可以根据实际情况调整这些容差值。</p></li><li><p>只有当所有选定的特征都匹配时才判定为水印，这大大提高了识别的准确性。</p></li></ul><p><strong>难易度</strong>：★★★★★</p><p><strong>优点</strong>： 识别准确性高，误判率极低。</p><p><strong>缺点</strong>： 实现相对复杂，需要精确的水印特征参数。</p><h3 id="方法四：基于文本特征的直接删除法-xA"><a href="#方法四：基于文本特征的直接删除法-xA" class="headerlink" title="方法四：基于文本特征的直接删除法&#xA;"></a>方法四：基于文本特征的直接删除法&#xA;</h3><p>如果你知道水印的具体文本内容，或者可以通过一些简单的文本属性来识别，这个方法最直接、最快速。</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">import fitz</span><br><span class="line"></span><br><span class="line">def is_watermark_span(span, target_text=None, min_size=None, max_size=None, target_color_rgb=None, color_tolerance=10):</span><br><span class="line">    size_match = True</span><br><span class="line">    if min_size is not None and span[&quot;size&quot;] &lt; min_size:</span><br><span class="line">        size_match = False</span><br><span class="line">    if max_size is not None and span[&quot;size&quot;] &gt; max_size:</span><br><span class="line">        size_match = False</span><br><span class="line">    text_match = True</span><br><span class="line">    if target_text is not None and target_text.lower() not in span[&quot;text&quot;].lower():</span><br><span class="line">        text_match = False</span><br><span class="line">    color_match = True</span><br><span class="line">    if target_color_rgb is not None:</span><br><span class="line">        color_int = span[&quot;color&quot;]</span><br><span class="line">        r = (color_int &gt;&gt; 16) &amp; 0xFF</span><br><span class="line">        g = (color_int &gt;&gt; 8) &amp; 0xFF</span><br><span class="line">        b = color_int &amp; 0xFF</span><br><span class="line">        current_color_rgb = (r, g, b)</span><br><span class="line">        if not (abs(current_color_rgb[0] - target_color_rgb[0]) &lt;= color_tolerance and</span><br><span class="line">                abs(current_color_rgb[1] - target_color_rgb[1]) &lt;= color_tolerance and</span><br><span class="line">                abs(current_color_rgb[2] - target_color_rgb[2]) &lt;= color_tolerance):</span><br><span class="line">            color_match = False</span><br><span class="line">    return size_match and text_match and color_match</span><br><span class="line"></span><br><span class="line">def remove_watermark_by_text_features(doc_path, output_path, **kwargs):</span><br><span class="line">    doc = fitz.open(doc_path)</span><br><span class="line">    for page in doc:</span><br><span class="line">        for block in page.get_text(&quot;dict&quot;)[&quot;blocks&quot;]:</span><br><span class="line">            if block[&quot;type&quot;] == 0:</span><br><span class="line">                for line in block[&quot;lines&quot;]:</span><br><span class="line">                    for span in line[&quot;spans&quot;]:</span><br><span class="line">                        if is_watermark_span(span, **kwargs):</span><br><span class="line">                            page.add_redact_annot(span[&quot;bbox&quot;])</span><br><span class="line">        page.apply_redactions()</span><br><span class="line">    doc.save(output_path)</span><br><span class="line">    doc.close()</span><br></pre></td></tr></table></figure></div><p><strong>代码解析</strong>：</p><ul><li><p>通过一个可自定义的 <code>is_watermark_span</code> 函数直接搜索符合特定文本特征的水印内容。</p></li><li><p>你可以传入 <code>target_text</code>、<code>min_size</code>、<code>max_size</code> 和 <code>target_color_rgb</code> 等参数来精确定义水印的特征。</p></li><li><p>对判定为水印的文本进行覆盖处理。</p></li></ul><p><strong>难易度</strong>：★★☆☆☆</p><p><strong>优点</strong>： 实现简单，处理速度快，非常适合处理简单的文本水印。</p><p><strong>缺点</strong>： 仅适用于文本水印，无法处理图像水印。</p><h3 id="方法五：基于混合特征的高级识别法-xA"><a href="#方法五：基于混合特征的高级识别法-xA" class="headerlink" title="方法五：基于混合特征的高级识别法&#xA;"></a>方法五：基于混合特征的高级识别法&#xA;</h3><p>对于更复杂的 PDF 水印（例如包含文本和图像），这种方法结合了文本和图像特征识别，能够提供更高的识别精度。请注意，图像处理部分需要 numpy 和 opencv-python 库。</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">import fitz</span><br><span class="line">import numpy as np</span><br><span class="line">import cv2</span><br><span class="line"></span><br><span class="line">def advanced_watermark_removal(doc_path, output_path, watermark_template_path=None):</span><br><span class="line">    doc = fitz.open(doc_path)</span><br><span class="line">    if watermark_template_path:</span><br><span class="line">        watermark_template = cv2.imread(watermark_template_path, cv2.IMREAD_GRAYSCALE)</span><br><span class="line">        sift = cv2.SIFT_create()</span><br><span class="line">        kp1, des1 = sift.detectAndCompute(watermark_template, None)</span><br><span class="line">    </span><br><span class="line">    for page in doc:</span><br><span class="line">        text_spans_to_redact = []</span><br><span class="line">        image_regions_to_redact = []</span><br><span class="line">        text_infos = page.get_text(&quot;dict&quot;)</span><br><span class="line">        for block in text_infos[&quot;blocks&quot;]:</span><br><span class="line">            if &quot;lines&quot; in block:</span><br><span class="line">                for line in block[&quot;lines&quot;]:</span><br><span class="line">                    for span in line[&quot;spans&quot;]:</span><br><span class="line">                        if (100 &lt;= span[&quot;color_rgb&quot;][0] &lt;= 220 and </span><br><span class="line">                            100 &lt;= span[&quot;color_rgb&quot;][1] &lt;= 220 and </span><br><span class="line">                            100 &lt;= span[&quot;color_rgb&quot;][2] &lt;= 220) and span[&quot;size&quot;] &gt; 15:</span><br><span class="line">                            text_spans_to_redact.append(span[&quot;bbox&quot;])</span><br><span class="line">        </span><br><span class="line">        if watermark_template_path and des1 is not None:</span><br><span class="line">            pix = page.get_pixmap(matrix=fitz.Matrix(2,2))</span><br><span class="line">            img = cv2.cvtColor(np.frombuffer(pix.samples, np.uint8).reshape(</span><br><span class="line">                pix.h, pix.w, pix.n), cv2.COLOR_RGB2GRAY)</span><br><span class="line">            kp2, des2 = sift.detectAndCompute(img, None)</span><br><span class="line">            if des2 is not None and len(des1) &gt; 0 and len(des2) &gt; 0:</span><br><span class="line">                matcher = cv2.BFMatcher()</span><br><span class="line">                matches = matcher.knnMatch(des1, des2, k=2)</span><br><span class="line">                good_matches = [m for m, n in matches if m.distance &lt; 0.75 * n.distance]</span><br><span class="line">                if len(good_matches) &gt; 10:</span><br><span class="line">                    src_pts = np.float32([kp1[m.queryIdx].pt for m in good_matches]).reshape(-1, 1, 2)</span><br><span class="line">                    dst_pts = np.float32([kp2[m.trainIdx].pt for m in good_matches]).reshape(-1, 1, 2)</span><br><span class="line">                    M, mask = cv2.findHomography(src_pts, dst_pts, cv2.RANSAC, 5.0)</span><br><span class="line">                    if M is not None:</span><br><span class="line">                        h, w = watermark_template.shape</span><br><span class="line">                        pts = np.float32([[0, 0], [0, h-1], [w-1, h-1], [w-1, 0]]).reshape(-1, 1, 2)</span><br><span class="line">                        dst = cv2.perspectiveTransform(pts, M)</span><br><span class="line">                        min_x = int(np.min(dst[:, 0, 0]) / pix.matrix.a)</span><br><span class="line">                        min_y = int(np.min(dst[:, 0, 1]) / pix.matrix.d)</span><br><span class="line">                        max_x = int(np.max(dst[:, 0, 0]) / pix.matrix.a)</span><br><span class="line">                        max_y = int(np.max(dst[:, 0, 1]) / pix.matrix.d)</span><br><span class="line">                        image_regions_to_redact.append((min_x, min_y, max_x, max_y))</span><br><span class="line">        </span><br><span class="line">        for span_bbox in text_spans_to_redact:</span><br><span class="line">            page.add_redact_annot(fitz.Rect(span_bbox))</span><br><span class="line">        for region_bbox in image_regions_to_redact:</span><br><span class="line">            page.add_redact_annot(fitz.Rect(region_bbox))</span><br><span class="line">        page.apply_redactions()</span><br><span class="line">    doc.save(output_path)</span><br><span class="line">    doc.close()</span><br></pre></td></tr></table></figure></div><p><strong>代码解析</strong>：</p><ul><li><p><strong>文本特征识别</strong>： 沿用了之前 <code>is_watermark_text</code> 的概念，但你需要根据实际水印特性来完善这个逻辑。</p></li><li><p><strong>图像特征识别</strong>：</p></li><li><p>将 PDF 页面渲染为图像，并转换为灰度图，以便进行特征检测。</p></li><li><p>使用 SIFT 算法（或其他特征匹配算法如 ORB, SURF）来检测并匹配图像水印模板。</p></li><li><p>通过 <code>findHomography</code> 计算水印在页面上的变换，从而确定水印的精确位置和边界框。</p></li><li><p>注意： 图像处理库 (如 OpenCV) 通常在像素坐标系下操作，你需要将检测到的像素坐标转换回 PyMuPDF 使用的 PDF 坐标。</p></li><li><p><strong>综合处理</strong>： 将文本和图像识别的结果结合起来，对所有识别出的水印区域进行处理。</p></li></ul><p><strong>难易度</strong>：★★★★☆</p><p><strong>优点</strong>： 识别精度高，适用于复杂水印环境（文本与图像混合），鲁棒性强。</p><p><strong>缺点</strong>： 实现复杂，需要水印模板，处理速度相对较慢，需要额外的图像处理库。</p><h3 id="方法六：基于-PDF-底层结构的终极方案-xA"><a href="#方法六：基于-PDF-底层结构的终极方案-xA" class="headerlink" title="方法六：基于 PDF 底层结构的终极方案&#xA;"></a>方法六：基于 PDF 底层结构的终极方案&#xA;</h3><p>这种方法最为彻底，因为它直接操作 PDF 文件的底层结构。但它也要求你对 PDF 规范有深入的了解，操作不当可能会导致文件损坏。</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import fitz</span><br><span class="line"></span><br><span class="line">def deep_watermark_removal(doc_path, output_path):</span><br><span class="line">    print(&quot;警告：此方法在PyMuPDF中难以直接实现，推荐使用更安全的redaction方法&quot;)</span><br><span class="line">    doc = fitz.open(doc_path)</span><br><span class="line">    doc.save(output_path)</span><br><span class="line">    doc.close()</span><br></pre></td></tr></table></figure></div><p><strong>代码解析</strong>：</p><ul><li><p>这个方法旨在直接操作 PDF 的 XObject (外部对象，可以是图像或 Form XObject) 和内容流。</p></li><li><p><strong>重要提示</strong>： PyMuPDF (Fitz) 并没有直接暴露修改或删除底层 PDF 对象的 API。 <code>add_redact_annot</code> 是 PyMuPDF 中最安全和推荐的方式来 “删除” 页面内容的。直接修改 PDF 的底层内容流非常危险，操作不当很可能导致 PDF 文件损坏且无法打开。</p></li><li><p>因此，我调整了此方法的描述和代码示例，强调其复杂性和风险，并指出在 PyMuPDF 中，更推荐使用 <code>add_redact_annot</code> 来实现 “删除” 效果。如果你真的需要深入到 PDF 底层修改，可能需要更专业的 PDF 处理库或对 PDF 规范有极其深入的了解。</p></li></ul><p><strong>难易度</strong>：★★★★★ (理论上)</p><p><strong>优点</strong>： 理论上可以彻底清除不留痕迹，适用于各种类型水印。</p><p><strong>缺点</strong>： 实现非常复杂，需要深入的 PDF 结构知识，且在 PyMuPDF 中直接实现此类操作难度极高且风险大。</p><p>方法对比与选择建议</p><table><thead><tr><th>方法&#xA;</th><th>难易度&#xA;</th><th>适用场景&#xA;</th><th>关键优势&#xA;</th><th>局限性&#xA;</th></tr></thead><tbody><tr><td>字体大小 + 旋转角度&#xA;</td><td>★★★☆☆&#xA;</td><td>水印有固定大小和倾斜角度&#xA;</td><td>实现相对简单，识别准确率较高&#xA;</td><td>需要精确的大小和角度参数&#xA;</td></tr><tr><td>透明度 + 颜色&#xA;</td><td>★★★★☆&#xA;</td><td>水印有固定颜色（特别是浅色）&#xA;</td><td>对浅色水印效果好&#xA;</td><td>透明度提取是难点，可能需要深入解析 PDF 内部结构或借助图像处理库&#xA;</td></tr><tr><td>多特征综合&#xA;</td><td>★★★★★&#xA;</td><td>水印特征明确且固定&#xA;</td><td>识别准确性高，误判率极低&#xA;</td><td>实现相对复杂，需要精确的水印特征参数&#xA;</td></tr><tr><td>基于文本特征&#xA;</td><td>★★☆☆☆&#xA;</td><td>简单文本水印&#xA;</td><td>实现简单，处理速度快&#xA;</td><td>仅适用于文本水印，无法处理图像水印&#xA;</td></tr><tr><td>混合特征识别&#xA;</td><td>★★★★☆&#xA;</td><td>复杂水印环境（文本与图像混合）&#xA;</td><td>识别精度高&#xA;</td><td>实现复杂，需要水印模板，处理速度慢&#xA;</td></tr><tr><td>底层结构处理&#xA;</td><td>★★★★★&#xA;</td><td>各种类型水印&#xA;</td><td>理论上最彻底&#xA;</td><td>高风险，PyMuPDF 中难以直接实现，需要深厚知识&#xA;</td></tr></tbody></table><p>特征参数提取方法</p><p>在实际应用中，我们首先需要获取水印的特征参数。可以通过以下方式初步提取：</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">import fitz</span><br><span class="line">import math</span><br><span class="line">from collections import Counter</span><br><span class="line"></span><br><span class="line">def extract_watermark_features(pdf_path, page_num=0):</span><br><span class="line">    doc = fitz.open(pdf_path)</span><br><span class="line">    page = doc[page_num]</span><br><span class="line">    possible_font_sizes = []</span><br><span class="line">    possible_rotations = []</span><br><span class="line">    possible_colors = []</span><br><span class="line">    </span><br><span class="line">    text_infos = page.get_text(&quot;dict&quot;)</span><br><span class="line">    for block in text_infos[&quot;blocks&quot;]:</span><br><span class="line">        if &quot;lines&quot; in block:</span><br><span class="line">            for line in block[&quot;lines&quot;]:</span><br><span class="line">                for span in line[&quot;spans&quot;]:</span><br><span class="line">                    possible_font_sizes.append(round(span[&quot;size&quot;], 1))</span><br><span class="line">                    matrix = fitz.Matrix(span[&quot;matrix&quot;])</span><br><span class="line">                    rotation = round(math.degrees(math.atan2(matrix.b, matrix.a)), 1)</span><br><span class="line">                    possible_rotations.append(rotation)</span><br><span class="line">                    color_int = span[&quot;color&quot;]</span><br><span class="line">                    r = (color_int &gt;&gt; 16) &amp; 0xFF</span><br><span class="line">                    g = (color_int &gt;&gt; 8) &amp; 0xFF</span><br><span class="line">                    b = color_int &amp; 0xFF</span><br><span class="line">                    possible_colors.append((r, g, b))</span><br><span class="line">    </span><br><span class="line">    font_size = Counter(possible_font_sizes).most_common(1)[0][0] if possible_font_sizes else None</span><br><span class="line">    rotation_angle = Counter(possible_rotations).most_common(1)[0][0] if possible_rotations else None</span><br><span class="line">    if rotation_angle and rotation_angle &lt; 0:</span><br><span class="line">        rotation_angle += 360</span><br><span class="line">    color_rgb = Counter(possible_colors).most_common(1)[0][0] if possible_colors else None</span><br><span class="line">    </span><br><span class="line">    doc.close()</span><br><span class="line">    return &#123;</span><br><span class="line">        &quot;font_size&quot;: font_size,</span><br><span class="line">        &quot;rotation_angle&quot;: rotation_angle,</span><br><span class="line">        &quot;color_rgb&quot;: color_rgb,</span><br><span class="line">        &quot;opacity&quot;: 0.5</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div><p><strong>代码解析</strong>：</p><ul><li><p>此函数会遍历指定页面的所有文本跨度，收集它们的字体大小、旋转角度和颜色。</p></li><li><p>为了方便统计，对浮点数（大小和角度）进行了四舍五入。</p></li><li><p>使用 <code>collections.Counter</code> 找出最常见的字体大小、旋转角度和颜色，作为可能的水印特征。</p></li><li><p>注意： 提取透明度仍然是一个挑战，<code>opacity</code> 参数在此处仍作为占位符，需要通过其他方式（例如手动观察或更复杂的 PDF 内容流解析）来确定。</p></li></ul><p>总结与最佳实践</p><p>基于特征的 PDF 水印处理方法能够实现更精确的水印识别和去除，但这要求你对水印的特征有充分了解。在实际应用中，我建议你遵循以下最佳实践：</p><ol><li><p><strong>预处理分析</strong>： 首先使用 <code>extract_watermark_features</code> 函数分析水印特征，初步了解水印的字体大小、旋转角度、颜色等关键信息。必要时，手工观察水印，确认其透明度、具体文本内容或图像样式。</p></li><li><p><strong>从简到繁尝试</strong>： 从最简单的方法开始。如果水印是纯文本且特征明显，可以先尝试 基于文本特征的直接删除法。如果水印有固定的字体大小和倾斜角度，就用 基于字体大小和旋转角度的方法。只有当简单方法效果不佳时，再逐步增加特征维度，尝试 多特征综合识别。</p></li><li><p><strong>合理调整参数</strong>： 根据实际水印情况细致调整匹配容差值，在识别准确率和误判率之间取得最佳平衡。例如，对于字体大小，可以允许 1.0 到 2.0 的误差范围；对于旋转角度，可允许 3 到 5 度左右的误差。</p></li><li><p><strong>复杂场景组合</strong>： 对于包含多种类型水印的复杂 PDF，考虑结合多种方法进行处理。例如，对于既有文本又有图像的混合水印，可以结合 混合特征识别法。</p></li><li><p><strong>批量处理技巧</strong>： 如果你需要处理大量 PDF 文件，利用多线程或多进程可以显著提高处理效率。</p></li></ol><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">from concurrent.futures import ThreadPoolExecutor</span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line">def batch_process_pdfs(file_list, output_dir, **watermark_params):</span><br><span class="line">    os.makedirs(output_dir, exist_ok=True)</span><br><span class="line">    with ThreadPoolExecutor(max_workers=os.cpu_count()) as executor:</span><br><span class="line">        futures = []</span><br><span class="line">        for file_path in file_list:</span><br><span class="line">            file_name = os.path.basename(file_path)</span><br><span class="line">            output_path = os.path.join(output_dir, file_name)</span><br><span class="line">            futures.append(executor.submit(</span><br><span class="line">                remove_watermark_by_multiple_features,</span><br><span class="line">                file_path, output_path, **watermark_params</span><br><span class="line">            ))</span><br><span class="line">        for future in futures:</span><br><span class="line">            try:</span><br><span class="line">                future.result()</span><br><span class="line">                print(f&quot;文件处理完成：&#123;file_path&#125;&quot;)</span><br><span class="line">            except Exception as exc:</span><br><span class="line">                print(f&quot;文件 &#123;file_path&#125; 处理时发生错误：&#123;exc&#125;&quot;)</span><br></pre></td></tr></table></figure></div><ol><li><strong>操作安全保障</strong>： 在处理任何重要文件之前，务必先备份原始文件！这能确保即使处理不当，你也不会丢失原始数据。同时，请始终遵守相关法律法规，仅处理你有权修改的文档，尊重知识产权和版权保护。</li></ol><p>通过合理选择和组合这些方法，你就能高效且精准地处理各种具有特定特征的 PDF 水印。</p><p>PS:代码仅供参考，内容不一定正确，要根据实际情况处理喵</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在日常工作中，我们经常会遇到带有特定特征的 PDF 水印，比如固定的字体大小、倾斜角度、透明度和颜色。这些特性为我们提供了更精准地识别水印的依据。今天，我们就来深入探讨如何利用 PyMuPDF (Fitz) 库，基于这些特征实现 PDF 水印的精确识别和去除，并整合多种实用</summary>
      
    
    
    
    <category term="PDF 处理" scheme="http://example.com/categories/PDF-%E5%A4%84%E7%90%86/"/>
    
    <category term="Python" scheme="http://example.com/categories/PDF-%E5%A4%84%E7%90%86/Python/"/>
    
    <category term="数据处理" scheme="http://example.com/categories/PDF-%E5%A4%84%E7%90%86/Python/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"/>
    
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
    <category term="PyMuPDF" scheme="http://example.com/tags/PyMuPDF/"/>
    
    <category term="PDF" scheme="http://example.com/tags/PDF/"/>
    
    <category term="水印去除" scheme="http://example.com/tags/%E6%B0%B4%E5%8D%B0%E5%8E%BB%E9%99%A4/"/>
    
    <category term="特征识别" scheme="http://example.com/tags/%E7%89%B9%E5%BE%81%E8%AF%86%E5%88%AB/"/>
    
    <category term="文本处理" scheme="http://example.com/tags/%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>从零开始的爬虫生活（一）：环境搭建与基础库应用</title>
    <link href="http://example.com/2025/07/15/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84%E7%88%AC%E8%99%AB%E7%94%9F%E6%B4%BB%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E5%9F%BA%E7%A1%80%E5%BA%93%E5%BA%94%E7%94%A8/"/>
    <id>http://example.com/2025/07/15/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84%E7%88%AC%E8%99%AB%E7%94%9F%E6%B4%BB%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E5%9F%BA%E7%A1%80%E5%BA%93%E5%BA%94%E7%94%A8/</id>
    <published>2025-07-15T09:15:15.000Z</published>
    <updated>2025-07-17T07:22:02.338Z</updated>
    
    <content type="html"><![CDATA[<p>一、环境搭建</p><p>在开始学习爬虫之前，我们需要先搭建好开发环境。以下是一些常用的工具和库：</p><h3 id="1-Python-环境-xA"><a href="#1-Python-环境-xA" class="headerlink" title="1. Python 环境&#xA;"></a>1. Python 环境&#xA;</h3><p>确保已经安装了 Python 3.x 版本。可以前往 <a class="link"   href="https://www.python.org/" >Python 官网<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 下载安装。</p><h3 id="2-常用库安装-xA"><a href="#2-常用库安装-xA" class="headerlink" title="2. 常用库安装&#xA;"></a>2. 常用库安装&#xA;</h3><p>使用 pip 命令安装以下库：</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pip install selenium</span><br><span class="line"></span><br><span class="line">pip install beautifulsoup4</span><br><span class="line"></span><br><span class="line">pip install pyquery</span><br><span class="line"></span><br><span class="line">pip install pymysql</span><br><span class="line"></span><br><span class="line">pip install pymongo</span><br><span class="line"></span><br><span class="line">pip install redis</span><br></pre></td></tr></table></figure></div><h3 id="3-浏览器驱动-xA"><a href="#3-浏览器驱动-xA" class="headerlink" title="3. 浏览器驱动&#xA;"></a>3. 浏览器驱动&#xA;</h3><ul><li><p><strong>ChromeDriver</strong>：根据你使用的 Chrome 浏览器版本，下载对应的 ChromeDriver。</p></li><li><p><strong>PhantomJS（已弃用）</strong>：在 Selenium 4.x 中已移除，建议使用无头模式的 Chrome。</p></li></ul><p><strong>配置 Chrome 无头模式示例：</strong></p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">from selenium import webdriver</span><br><span class="line">from selenium.webdriver.chrome.options import Options</span><br><span class="line"></span><br><span class="line"># 配置 Chrome 为无头模式</span><br><span class="line">chrome_options = Options()</span><br><span class="line">chrome_options.add_argument(&quot;--headless&quot;)  # 无头模式，不显示浏览器窗口</span><br><span class="line"></span><br><span class="line"># 创建 Chrome 浏览器实例</span><br><span class="line">driver = webdriver.Chrome(options=chrome_options)</span><br><span class="line"></span><br><span class="line">driver.get(&quot;https://www.example.com&quot;)</span><br><span class="line">print(driver.title)</span><br><span class="line">driver.quit()</span><br></pre></td></tr></table></figure></div><p>二、基础库应用</p><h3 id="1-BeautifulSoup-库-xA"><a href="#1-BeautifulSoup-库-xA" class="headerlink" title="1. BeautifulSoup 库&#xA;"></a>1. BeautifulSoup 库&#xA;</h3><p>BeautifulSoup 是一个用于解析 HTML 和 XML 文档的库。<strong>示例：</strong></p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">from bs4 import BeautifulSoup</span><br><span class="line"></span><br><span class="line">html_doc = &quot;&quot;&quot;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;title&gt;示例页面&lt;/title&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;h1&gt;标题&lt;/h1&gt;</span><br><span class="line">        &lt;p&gt;段落内容&lt;/p&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">soup = BeautifulSoup(html_doc, &#x27;html.parser&#x27;)</span><br><span class="line">print(soup.title.string)  # 输出标题内容</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">soup = BeautifulSoup(html_doc, &#x27;html.parser&#x27;)</span><br><span class="line"></span><br><span class="line">print(soup.title.string)  # 输出标题内容</span><br></pre></td></tr></table></figure></div><h3 id="2-PyQuery-库-xA"><a href="#2-PyQuery-库-xA" class="headerlink" title="2. PyQuery 库&#xA;"></a>2. PyQuery 库&#xA;</h3><p>PyQuery 是一个类 jQuery 的 Python 库，用于操作 HTML 文档。<strong>示例：</strong></p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">from pyquery import PyQuery as pq</span><br><span class="line"></span><br><span class="line">html_doc = &quot;&quot;&quot;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;title&gt;示例页面&lt;/title&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;h1&gt;标题&lt;/h1&gt;</span><br><span class="line">        &lt;p&gt;段落内容&lt;/p&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">doc = pq(html_doc)</span><br><span class="line">print(doc(&#x27;title&#x27;).text())  # 输出标题内容</span><br></pre></td></tr></table></figure></div><h3 id="3-Requests-库-xA"><a href="#3-Requests-库-xA" class="headerlink" title="3. Requests 库&#xA;"></a>3. Requests 库&#xA;</h3><p>Requests 是一个简单的 HTTP 库，用于发送网络请求。<strong>示例：</strong></p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line"></span><br><span class="line">url = &quot;https://www.example.com&quot;</span><br><span class="line">response = requests.get(url)</span><br><span class="line">print(response.text)  # 输出网页内容</span><br></pre></td></tr></table></figure></div><p>三、数据存储</p><h3 id="1-MySQL-数据库-xA"><a href="#1-MySQL-数据库-xA" class="headerlink" title="1. MySQL 数据库&#xA;"></a>1. MySQL 数据库&#xA;</h3><p>使用 PyMySQL 连接和操作 MySQL 数据库：</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import pymysql</span><br><span class="line"></span><br><span class="line">conn = pymysql.connect(</span><br><span class="line">    host=&#x27;localhost&#x27;,</span><br><span class="line">    user=&#x27;root&#x27;,</span><br><span class="line">    password=&#x27;123456&#x27;,</span><br><span class="line">    port=3306,</span><br><span class="line">    db=&#x27;mysql&#x27;</span><br><span class="line">)</span><br><span class="line">cursor = conn.cursor()</span><br><span class="line">cursor.execute(&#x27;SELECT * FROM db&#x27;)</span><br><span class="line">print(cursor.fetchone())</span><br><span class="line">conn.close()</span><br></pre></td></tr></table></figure></div><h3 id="2-MongoDB-数据库-xA"><a href="#2-MongoDB-数据库-xA" class="headerlink" title="2. MongoDB 数据库&#xA;"></a>2. MongoDB 数据库&#xA;</h3><p>使用 PyMongo 连接和操作 MongoDB 数据库：</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import pymongo</span><br><span class="line"></span><br><span class="line">client = pymongo.MongoClient(&#x27;localhost&#x27;)</span><br><span class="line">db = client[&#x27;newtestdb&#x27;]</span><br><span class="line">db[&#x27;table&#x27;].insert_one(&#123;&#x27;name&#x27;: &#x27;Bob&#x27;&#125;)</span><br><span class="line">result = db[&#x27;table&#x27;].find_one(&#123;&#x27;name&#x27;: &#x27;Bob&#x27;&#125;)</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure></div><h3 id="3-Redis-数据库-xA"><a href="#3-Redis-数据库-xA" class="headerlink" title="3. Redis 数据库&#xA;"></a>3. Redis 数据库&#xA;</h3><p>使用 RedisPy 连接和操作 Redis 数据库：</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import redis</span><br><span class="line"></span><br><span class="line">r = redis.Redis(&#x27;localhost&#x27;, 6379)</span><br><span class="line">r.set(&#x27;name&#x27;, &#x27;Bob&#x27;)</span><br><span class="line">result = r.get(&#x27;name&#x27;)</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure></div><p>四、爬虫基本流程</p><p>爬虫的基本流程如下：</p><ol><li><p>发送请求：使用 Requests 库发送 HTTP 请求获取网页内容。</p></li><li><p>解析响应：使用 BeautifulSoup 或 PyQuery 库解析网页内容，提取所需数据。</p></li><li><p>保存数据：将提取的数据存储到数据库或文件中。</p></li></ol><p><strong>示例：爬取猫眼电影 TOP100</strong></p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line">import re</span><br><span class="line">import json</span><br><span class="line">from multiprocessing import Pool</span><br><span class="line"></span><br><span class="line">def get_one_page(url):</span><br><span class="line">    headers = &#123;</span><br><span class="line">        &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/137.0.0.0 Safari/537.36 Edg/137.0.0.0&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">    response = requests.get(url, headers=headers)</span><br><span class="line">    if response.status_code == 200:</span><br><span class="line">        return response.text</span><br><span class="line">    return None</span><br><span class="line"></span><br><span class="line">def parse_one_page(html):</span><br><span class="line">    pattern = re.compile(&#x27;&lt;dd&gt;.*?board-index.*?&gt;(d+)&lt;/i&gt;.*?data-src=&quot;(.*?)&quot;.*?name&quot;&gt;&lt;a&#x27;</span><br><span class="line">                         + &#x27;.*?&gt;(.*?)&lt;/a&gt;.*?star&quot;&gt;(.*?)&lt;/p&gt;.*?releasetime&quot;&gt;(.*?)&lt;/p&gt;&#x27;</span><br><span class="line">                         + &#x27;.*?integer&quot;&gt;(.*?)&lt;/i&gt;.*?fraction&quot;&gt;(.*?)&lt;/i&gt;.*?&lt;/dd&gt;&#x27;, re.S)</span><br><span class="line">    items = re.findall(pattern, html)</span><br><span class="line">    for item in items:</span><br><span class="line">        yield &#123;</span><br><span class="line">            &#x27;index&#x27;: item[0],</span><br><span class="line">            &#x27;image&#x27;: item[1],</span><br><span class="line">            &#x27;title&#x27;: item[2],</span><br><span class="line">            &#x27;actor&#x27;: item[3].strip()[3:],</span><br><span class="line">            &#x27;time&#x27;: item[4].strip()[5:],</span><br><span class="line">            &#x27;score&#x27;: item[5] + item[6]</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">def write_to_file(content):</span><br><span class="line">    with open(&#x27;result.txt&#x27;, &#x27;a&#x27;, encoding=&#x27;utf-8&#x27;) as f:</span><br><span class="line">        f.write(json.dumps(content, ensure_ascii=False) + &#x27;n&#x27;)</span><br><span class="line"></span><br><span class="line">def main(offset):</span><br><span class="line">    url = &#x27;http://maoyan.com/board/4?offset=&#x27; + str(offset)</span><br><span class="line">    html = get_one_page(url)</span><br><span class="line">    for item in parse_one_page(html):</span><br><span class="line">        print(item)</span><br><span class="line">        write_to_file(item)</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    pool = Pool()</span><br><span class="line">    pool.map(main, [i * 10 for i in range(10)])</span><br></pre></td></tr></table></figure></div><p>五、动态网页处理</p><p>对于动态加载的网页，可以使用 Selenium 模拟浏览器操作。<strong>示例：</strong></p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">from selenium import webdriver</span><br><span class="line">from selenium.webdriver.common.by import By</span><br><span class="line"></span><br><span class="line">driver = webdriver.Chrome()</span><br><span class="line">driver.get(&#x27;https://www.taobao.com&#x27;)</span><br><span class="line">input = driver.find_element(By.ID, &#x27;q&#x27;)</span><br><span class="line">input.send_keys(&#x27;美食&#x27;)</span><br><span class="line">button = driver.find_element(By.CLASS_NAME, &#x27;btn-search&#x27;)</span><br><span class="line">button.click()</span><br><span class="line">driver.quit()</span><br></pre></td></tr></table></figure></div><p>六、爬虫框架</p><h3 id="1-Scrapy-框架-xA"><a href="#1-Scrapy-框架-xA" class="headerlink" title="1. Scrapy 框架&#xA;"></a>1. Scrapy 框架&#xA;</h3><p>Scrapy 是一个强大的爬虫框架，可以简化爬虫开发过程。<strong>安装命令：</strong></p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install scrapy</span><br></pre></td></tr></table></figure></div><p>未完待续……</p><p>PS:代码仅供参考，内容不一定正确，要根据实际情况处理喵</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;一、环境搭建&lt;/p&gt;
&lt;p&gt;在开始学习爬虫之前，我们需要先搭建好开发环境。以下是一些常用的工具和库：&lt;/p&gt;
&lt;h3 id=&quot;1-Python-环境-xA&quot;&gt;&lt;a href=&quot;#1-Python-环境-xA&quot; class=&quot;headerlink&quot; title=&quot;1. Pyt</summary>
      
    
    
    
    <category term="爬虫教程" scheme="http://example.com/categories/%E7%88%AC%E8%99%AB%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="Python爬虫" scheme="http://example.com/tags/Python%E7%88%AC%E8%99%AB/"/>
    
    <category term="数据抓取" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E6%8A%93%E5%8F%96/"/>
    
    <category term="Selenium" scheme="http://example.com/tags/Selenium/"/>
    
    <category term="BeautifulSoup" scheme="http://example.com/tags/BeautifulSoup/"/>
    
    <category term="数据存储" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/"/>
    
  </entry>
  
  <entry>
    <title>Dify镜像源替换与服务启动</title>
    <link href="http://example.com/2025/07/15/Dify-%E9%83%A8%E7%BD%B2%E6%B5%81%E7%A8%8B%EF%BC%9A%E9%95%9C%E5%83%8F%E6%BA%90%E6%9B%BF%E6%8D%A2%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%90%AF%E5%8A%A8/"/>
    <id>http://example.com/2025/07/15/Dify-%E9%83%A8%E7%BD%B2%E6%B5%81%E7%A8%8B%EF%BC%9A%E9%95%9C%E5%83%8F%E6%BA%90%E6%9B%BF%E6%8D%A2%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%90%AF%E5%8A%A8/</id>
    <published>2025-07-15T02:17:31.000Z</published>
    <updated>2025-07-17T07:21:54.243Z</updated>
    
    <content type="html"><![CDATA[<p>一、Dify 镜像源替换操作</p><h3 id="批量替换镜像前缀-xA"><a href="#批量替换镜像前缀-xA" class="headerlink" title="批量替换镜像前缀&#xA;"></a>批量替换镜像前缀&#xA;</h3><p>在 docker-compose.yaml 所在目录执行全局替换，添加 docker.1ms.run&#x2F; 前缀：</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i &#x27;s/image: /image: docker.1ms.run\\//g&#x27; docker-compose.yaml</span><br></pre></td></tr></table></figure></div><h3 id="特殊镜像路径修正-xA"><a href="#特殊镜像路径修正-xA" class="headerlink" title="特殊镜像路径修正&#xA;"></a>特殊镜像路径修正&#xA;</h3><h4 id="问题路径-xA"><a href="#问题路径-xA" class="headerlink" title="问题路径&#xA;"></a>问题路径&#xA;</h4><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">image: docker.1ms.run/docker.elastic.co/elasticsearch/elasticsearch:8.14.3</span><br></pre></td></tr></table></figure></div><h4 id="修正命令-xA"><a href="#修正命令-xA" class="headerlink" title="修正命令&#xA;"></a>修正命令&#xA;</h4><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i &#x27;s|docker.1ms.run/docker.elastic.co/|docker.1ms.run/elastic/|g&#x27; docker-compose.yaml</span><br></pre></td></tr></table></figure></div><h4 id="正确路径-xA"><a href="#正确路径-xA" class="headerlink" title="正确路径&#xA;"></a>正确路径&#xA;</h4><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">image: docker.1ms.run/elastic/elasticsearch:8.14.3</span><br></pre></td></tr></table></figure></div><h3 id="基础镜像补充替换-xA"><a href="#基础镜像补充替换-xA" class="headerlink" title="基础镜像补充替换&#xA;"></a>基础镜像补充替换&#xA;</h3><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sed -i &#x27;s|image: postgres:|image: docker.1ms.run/postgres:|g&#x27; docker-compose.yaml</span><br><span class="line"></span><br><span class="line">sed -i &#x27;s|image: redis:|image: docker.1ms.run/redis:|g&#x27; docker-compose.yaml</span><br><span class="line"></span><br><span class="line">sed -i &#x27;s|image: nginx:|image: docker.1ms.run/nginx:|g&#x27; docker-compose.yaml</span><br></pre></td></tr></table></figure></div><p>二、部署前准备工作</p><p>赋予挂载目录权限：</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod -R 777 ./volumes ./elasticsearch</span><br></pre></td></tr></table></figure></div><p>三、启动与验证 Dify 服务</p><h3 id="后台启动服务-xA"><a href="#后台启动服务-xA" class="headerlink" title="后台启动服务&#xA;"></a>后台启动服务&#xA;</h3><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure></div><h3 id="验证服务状态-xA"><a href="#验证服务状态-xA" class="headerlink" title="验证服务状态&#xA;"></a>验证服务状态&#xA;</h3><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker-compose ps  # 检查容器运行状态</span><br><span class="line"></span><br><span class="line">docker-compose logs -f  # 查看实时日志</span><br></pre></td></tr></table></figure></div><h3 id="访问-Dify-界面-xA"><a href="#访问-Dify-界面-xA" class="headerlink" title="访问 Dify 界面&#xA;"></a>访问 Dify 界面&#xA;</h3><p>浏览器输入 http:&#x2F;&#x2F; 服务器 IP:3000，默认账号 <a class="link"   href="mailto:&#97;&#100;&#109;&#x69;&#110;&#64;&#101;&#120;&#x61;&#109;&#112;&#x6c;&#x65;&#x2e;&#x63;&#x6f;&#109;" >admin@example.com<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>，密码 password。</p><p>四、部署过程常见问题</p><h3 id="镜像路径嵌套错误-xA"><a href="#镜像路径嵌套错误-xA" class="headerlink" title="镜像路径嵌套错误&#xA;"></a>镜像路径嵌套错误&#xA;</h3><h4 id="问题-xA"><a href="#问题-xA" class="headerlink" title="问题&#xA;"></a>问题&#xA;</h4><p>镜像路径包含 docker.1ms.run&#x2F;docker.elastic.co&#x2F; 嵌套结构。</p><h4 id="解决-xA"><a href="#解决-xA" class="headerlink" title="解决&#xA;"></a>解决&#xA;</h4><p>使用 sed 精准替换：</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i &#x27;s|docker.1ms.run/docker.elastic.co/|docker.1ms.run/elastic/|g&#x27; docker-compose.yaml</span><br></pre></td></tr></table></figure></div><h3 id="权限不足导致启动失败-xA"><a href="#权限不足导致启动失败-xA" class="headerlink" title="权限不足导致启动失败&#xA;"></a>权限不足导致启动失败&#xA;</h3><h4 id="问题-xA-1"><a href="#问题-xA-1" class="headerlink" title="问题&#xA;"></a>问题&#xA;</h4><p>挂载目录无读写权限。</p><h4 id="解决-xA-1"><a href="#解决-xA-1" class="headerlink" title="解决&#xA;"></a>解决&#xA;</h4><p>递归设置目录权限：</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod -R 777 ./volumes</span><br></pre></td></tr></table></figure></div><h3 id="服务启动异常-xA"><a href="#服务启动异常-xA" class="headerlink" title="服务启动异常&#xA;"></a>服务启动异常&#xA;</h3><h4 id="解决-xA-2"><a href="#解决-xA-2" class="headerlink" title="解决&#xA;"></a>解决&#xA;</h4><p>通过日志排查问题：&#x20;</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker-compose logs -f  # 查看所有服务日志</span><br><span class="line"></span><br><span class="line">docker-compose logs dify-api  # 查看指定服务日志</span><br></pre></td></tr></table></figure></div><p>五、核心操作总结</p><h3 id="镜像替换流程-xA"><a href="#镜像替换流程-xA" class="headerlink" title="镜像替换流程&#xA;"></a>镜像替换流程&#xA;</h3><p>全局前缀替换 → 特殊镜像路径修正 → 基础镜像补充替换</p><h3 id="启动验证流程-xA"><a href="#启动验证流程-xA" class="headerlink" title="启动验证流程&#xA;"></a>启动验证流程&#xA;</h3><p>docker-compose up -d → docker-compose ps → 访问 Web 界面</p><h3 id="关键命令-xA"><a href="#关键命令-xA" class="headerlink" title="关键命令&#xA;"></a>关键命令&#xA;</h3><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sed -i &#x27;s/image: /image: docker.1ms.run\\//g&#x27; docker-compose.yaml</span><br><span class="line"></span><br><span class="line">chmod -R 777 ./volumes</span><br><span class="line"></span><br><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure></div><p>PS:代码仅供参考，内容不一定正确，要根据实际情况处理喵</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;一、Dify 镜像源替换操作&lt;/p&gt;
&lt;h3 id=&quot;批量替换镜像前缀-xA&quot;&gt;&lt;a href=&quot;#批量替换镜像前缀-xA&quot; class=&quot;headerlink&quot; title=&quot;批量替换镜像前缀&amp;#xA;&quot;&gt;&lt;/a&gt;批量替换镜像前缀&amp;#xA;&lt;/h3&gt;&lt;p&gt;在 docker</summary>
      
    
    
    
    <category term="Dify" scheme="http://example.com/categories/Dify/"/>
    
    
    <category term="Dify" scheme="http://example.com/tags/Dify/"/>
    
    <category term="镜像源" scheme="http://example.com/tags/%E9%95%9C%E5%83%8F%E6%BA%90/"/>
    
  </entry>
  
</feed>
