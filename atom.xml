<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2025-08-05T08:41:01.163Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>XXXBK</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python异闻录（三）</title>
    <link href="http://example.com/2025/08/05/Python%E5%BC%82%E9%97%BB%E5%BD%95%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://example.com/2025/08/05/Python%E5%BC%82%E9%97%BB%E5%BD%95%EF%BC%88%E4%B8%89%EF%BC%89/</id>
    <published>2025-08-05T08:36:02.000Z</published>
    <updated>2025-08-05T08:41:01.163Z</updated>
    
    <content type="html"><![CDATA[<h1 id="7-元编程"><a href="#7-元编程" class="headerlink" title="7. 元编程"></a>7. 元编程</h1><h2 id="7-1-动态创建类"><a href="#7-1-动态创建类" class="headerlink" title="7.1 动态创建类"></a>7.1 动态创建类</h2><ul><li><p>概念：在程序运行时动态地创建类，而不是在代码中静态定义。</p></li><li><p>实现方式：使用 <code>type()</code> 函数，<code>type()</code> 函数既可以返回对象的类型，也可以用于动态创建类。</p></li><li><p><code>type()</code> 动态创建类的语法：<code>type(class_name, bases, namespace)</code>，其中 <code>class_name</code> 是类名，<code>bases</code> 是父类元组，<code>namespace</code> 是类的属性和方法字典。</p></li></ul><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#定义类的方法</span><br><span class="line"></span><br><span class="line">def say_hello(self):</span><br><span class="line"></span><br><span class="line">   print(f&quot;Hello, I&#x27;m &#123;self.name&#125;&quot;)</span><br><span class="line"></span><br><span class="line">def set_age(self, age):</span><br><span class="line"></span><br><span class="line">self.age = age</span><br><span class="line"></span><br><span class="line"># 动态创建类</span><br><span class="line"></span><br><span class="line">Person = type(&quot;Person&quot;, (object,), &#123;</span><br><span class="line"></span><br><span class="line">   &quot;name&quot;: &quot;Unknown&quot;,</span><br><span class="line"></span><br><span class="line">   &quot;say_hello&quot;: say_hello,</span><br><span class="line"></span><br><span class="line">   &quot;set_age&quot;: set_age</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"># 使用动态创建的类</span><br><span class="line"></span><br><span class="line">p = Person()</span><br><span class="line"></span><br><span class="line">p.say_hello()  # 输出Hello, I&#x27;m Unknown</span><br><span class="line"></span><br><span class="line">p.name = &quot;Alice&quot;</span><br><span class="line"></span><br><span class="line">p.say_hello()  # 输出Hello, I&#x27;m Alice</span><br><span class="line"></span><br><span class="line">p.set_age(18)</span><br><span class="line"></span><br><span class="line">print(p.age)  # 输出18</span><br></pre></td></tr></table></figure></div><h1 id="8-性能优化"><a href="#8-性能优化" class="headerlink" title="8. 性能优化"></a>8. 性能优化</h1><h2 id="8-1-生成器"><a href="#8-1-生成器" class="headerlink" title="8.1 生成器"></a>8.1 生成器</h2><ul><li><p>概念：生成器是一种特殊的迭代器，通过 <code>yield</code> 关键字返回值，每次调用 <code>next()</code> 方法时，从上次 <code>yield</code> 的位置继续执行。</p></li><li><p>特点：</p><ul><li><p>惰性计算：生成器不会一次性生成所有数据，而是在需要时生成，节省内存空间。</p></li><li><p>可迭代性：生成器是可迭代对象，可以使用 <code>for</code> 循环遍历。</p></li></ul></li><li><p>应用场景：处理大量数据、实现无限序列等。</p></li></ul><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># 生成器函数</span><br><span class="line"></span><br><span class="line">def number_generator(n):</span><br><span class="line"></span><br><span class="line">   for i in range(n):</span><br><span class="line"></span><br><span class="line">       yield i</span><br><span class="line"></span><br><span class="line">       print(f&quot;Yielded &#123;i&#125;&quot;)</span><br><span class="line"></span><br><span class="line"># 使用生成器</span><br><span class="line"></span><br><span class="line">gen = number_generator(3)</span><br><span class="line"></span><br><span class="line">print(next(gen))  # 输出0，之后打印Yielded 0</span><br><span class="line"></span><br><span class="line">print(next(gen))  # 输出1，之后打印Yielded 1</span><br><span class="line"></span><br><span class="line">print(next(gen))  # 输出2，之后打印Yielded 2</span><br><span class="line"></span><br><span class="line"># 使用for循环遍历</span><br><span class="line"></span><br><span class="line">for num in number_generator(3):</span><br><span class="line"></span><br><span class="line">   print(num)  # 依次输出0、1、2，每次输出前会打印Yielded相应数字</span><br></pre></td></tr></table></figure></div><h2 id="8-2-slots"><a href="#8-2-slots" class="headerlink" title="8.2 __slots__"></a>8.2 <code>__slots__</code></h2><ul><li><p>概念：<code>__slots__</code> 是一个类属性，用于限制类的实例可以添加的属性，同时可以提高属性访问速度和节省内存。</p></li><li><p>原理：默认情况下，类的实例会使用字典存储属性，<code>__slots__</code> 会让实例使用固定大小的数组存储属性，而不是字典。</p></li><li><p>注意事项：</p><ul><li><p><code>__slots__</code> 中定义的属性是固定的，实例不能添加 <code>__slots__</code> 之外的属性。</p></li><li><p>子类如果没有定义 <code>__slots__</code>，则可以继承父类的 <code>__slots__</code> 并添加新属性；如果子类定义了 <code>__slots__</code>，则是父类 <code>__slots__</code> 与子类 <code>__slots__</code> 的并集。</p></li></ul></li></ul><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Person:</span><br><span class="line"></span><br><span class="line">   __slots__ = (&quot;name&quot;, &quot;age&quot;)  # 限制只能有name和age属性</span><br><span class="line"></span><br><span class="line">p = Person()</span><br><span class="line"></span><br><span class="line">p.name = &quot;Alice&quot;</span><br><span class="line"></span><br><span class="line">p.age = 18</span><br><span class="line"></span><br><span class="line"># p.gender = &quot;female&quot;  # 会抛出AttributeError，因为gender不在__slots__中</span><br></pre></td></tr></table></figure></div><h1 id="9-标准库"><a href="#9-标准库" class="headerlink" title="9. 标准库"></a>9. 标准库</h1><h2 id="9-1-re-模块（正则表达式）"><a href="#9-1-re-模块（正则表达式）" class="headerlink" title="9.1 re 模块（正则表达式）"></a>9.1 <code>re</code> 模块（正则表达式）</h2><ul><li><p>概念：<code>re</code> 模块提供了正则表达式的支持，用于字符串的匹配、查找、替换等操作。</p></li><li><p>常用函数：</p><ul><li><p><code>re.match(pattern, string)</code>：从字符串开头匹配模式，返回匹配对象或 <code>None</code>。</p></li><li><p><code>re.search(pattern, string)</code>：在整个字符串中查找第一个匹配模式的位置，返回匹配对象或 <code>None</code>。</p></li><li><p><code>re.findall(pattern, string)</code>：返回所有匹配模式的子串列表。</p></li><li><p><code>re.sub(pattern, repl, string)</code>：将匹配模式的子串替换为 <code>repl</code>，返回替换后的字符串。</p></li></ul></li><li><p>常用元字符：<code>. </code>（匹配任意字符）、<code>*</code>（匹配前一个字符 0 次或多次）、<code>+</code>（匹配前一个字符 1 次或多次）、<code>?</code>（匹配前一个字符 0 次或 1 次）、<code>^</code>（匹配字符串开头）、<code>$</code>（匹配字符串结尾）、<code>[]</code>（字符集）、<code>()</code>（分组）等。</p></li></ul><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line"></span><br><span class="line"># match示例</span><br><span class="line"></span><br><span class="line">result = re.match(r&quot;Hello&quot;, &quot;Hello World&quot;)</span><br><span class="line"></span><br><span class="line">print(result.group())  # 输出Hello</span><br><span class="line"></span><br><span class="line"># search示例</span><br><span class="line"></span><br><span class="line">result = re.search(r&quot;World&quot;, &quot;Hello World&quot;)</span><br><span class="line"></span><br><span class="line">print(result.group())  # 输出World</span><br><span class="line"></span><br><span class="line"># findall示例</span><br><span class="line"></span><br><span class="line">result = re.findall(r&quot;d+&quot;, &quot;There are 123 apples and 456 bananas&quot;)</span><br><span class="line"></span><br><span class="line">print(result)  # 输出[&#x27;123&#x27;, &#x27;456&#x27;]</span><br><span class="line"></span><br><span class="line"># sub示例</span><br><span class="line"></span><br><span class="line">result = re.sub(r&quot;d+&quot;, &quot;many&quot;, &quot;There are 123 apples and 456 bananas&quot;)</span><br><span class="line"></span><br><span class="line">print(result)  # 输出There are many apples and many bananas</span><br></pre></td></tr></table></figure></div><h2 id="9-2-pathlib-模块"><a href="#9-2-pathlib-模块" class="headerlink" title="9.2 pathlib 模块"></a>9.2 <code>pathlib</code> 模块</h2><ul><li><p>概念：<code>pathlib</code> 模块提供了面向对象的文件系统路径操作方式，相比传统的 <code>os.path</code> 模块更直观、易用。</p></li><li><p>常用类：<code>Path</code> 是主要的类，用于表示文件或目录的路径。</p></li><li><p>常用方法：</p><ul><li><p><code>exists()</code>：判断路径是否存在。</p></li><li><p><code>is_file()</code>：判断是否为文件。</p></li><li><p><code>is_dir()</code>：判断是否为目录。</p></li><li><p><code>mkdir()</code>：创建目录。</p></li><li><p><code>glob()</code>：查找匹配的文件或目录。</p></li><li><p><code>read_text()</code>：读取文本文件内容。</p></li><li><p><code>write_text()</code>：写入文本内容到文件。</p></li></ul></li></ul><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">from pathlib import Path</span><br><span class="line"></span><br><span class="line"># 创建Path对象</span><br><span class="line"></span><br><span class="line">path = Path(&quot;example.txt&quot;)</span><br><span class="line"></span><br><span class="line"># 检查路径是否存在</span><br><span class="line"></span><br><span class="line">print(path.exists())  # 输出False（假设文件不存在）</span><br><span class="line"></span><br><span class="line"># 创建文件并写入内容</span><br><span class="line"></span><br><span class="line">path.write_text(&quot;Hello, pathlib!&quot;)</span><br><span class="line"></span><br><span class="line">print(path.exists())  # 输出True</span><br><span class="line"></span><br><span class="line">print(path.is_file())  # 输出True</span><br><span class="line"></span><br><span class="line"># 读取文件内容</span><br><span class="line"></span><br><span class="line">print(path.read_text())  # 输出Hello, pathlib!</span><br><span class="line"></span><br><span class="line"># 查找当前目录下的txt文件</span><br><span class="line"></span><br><span class="line">txt_files = list(Path(&quot;.&quot;).glob(&quot;*.txt&quot;))</span><br><span class="line"></span><br><span class="line">print(txt_files)  # 输出包含example.txt的列表</span><br></pre></td></tr></table></figure></div><h1 id="10-类型系统"><a href="#10-类型系统" class="headerlink" title="10. 类型系统"></a>10. 类型系统</h1><h2 id="10-1-泛型"><a href="#10-1-泛型" class="headerlink" title="10.1 泛型"></a>10.1 泛型</h2><ul><li><p>概念：泛型允许在定义函数、类或接口时使用类型变量，而不是具体的类型，从而实现代码的复用和类型安全。</p></li><li><p>作用：在不牺牲类型检查的前提下，使代码能够处理多种不同类型的数据。</p></li><li><p>实现：使用 <code>typing</code> 模块中的 <code>Generic</code>、<code>TypeVar</code> 等工具。<code>TypeVar</code> 用于定义类型变量，<code>Generic</code> 用于使类支持泛型。</p></li></ul><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">from typing import TypeVar, Generic, List</span><br><span class="line"></span><br><span class="line"># 定义类型变量</span><br><span class="line"></span><br><span class="line">T = TypeVar(&#x27;T&#x27;)</span><br><span class="line"></span><br><span class="line"># 泛型函数</span><br><span class="line"></span><br><span class="line">def first_element(lst: List[T]) -&gt; T:</span><br><span class="line"></span><br><span class="line">   return lst[0]</span><br><span class="line"></span><br><span class="line"># 泛型类</span><br><span class="line"></span><br><span class="line">class Stack(Generic[T]):</span><br><span class="line"></span><br><span class="line">   def __init__(self):</span><br><span class="line"></span><br><span class="line">       self.items: List[T] = []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   def push(self, item: T) -&gt; None:</span><br><span class="line"></span><br><span class="line">       self.items.append(item)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   def pop(self) -&gt; T:</span><br><span class="line"></span><br><span class="line">       return self.items.pop()</span><br><span class="line"></span><br><span class="line"># 使用泛型函数</span><br><span class="line"></span><br><span class="line">int_list = [1, 2, 3]</span><br><span class="line"></span><br><span class="line">print(first_element(int_list))  # 输出1，类型为int</span><br><span class="line"></span><br><span class="line">str_list = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br><span class="line"></span><br><span class="line">print(first_element(str_list))  # 输出a，类型为str</span><br><span class="line"></span><br><span class="line"># 使用泛型类</span><br><span class="line"></span><br><span class="line">int_stack = Stack[int]()</span><br><span class="line"></span><br><span class="line">int_stack.push(1)</span><br><span class="line"></span><br><span class="line">int_stack.push(2)</span><br><span class="line"></span><br><span class="line">print(int_stack.pop())  # 输出2，类型为int</span><br><span class="line"></span><br><span class="line">str_stack = Stack[str]()</span><br><span class="line"></span><br><span class="line">str_stack.push(&quot;hello&quot;)</span><br><span class="line"></span><br><span class="line">str_stack.push(&quot;world&quot;)</span><br><span class="line"></span><br><span class="line">print(str_stack.pop())  # 输出world，类型为str</span><br></pre></td></tr></table></figure></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;7-元编程&quot;&gt;&lt;a href=&quot;#7-元编程&quot; class=&quot;headerlink&quot; title=&quot;7. 元编程&quot;&gt;&lt;/a&gt;7. 元编程&lt;/h1&gt;&lt;h2 id=&quot;7-1-动态创建类&quot;&gt;&lt;a href=&quot;#7-1-动态创建类&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="Python" scheme="http://example.com/categories/Python/"/>
    
    <category term="类型注解" scheme="http://example.com/categories/Python/%E7%B1%BB%E5%9E%8B%E6%B3%A8%E8%A7%A3/"/>
    
    
    <category term="正则表达式" scheme="http://example.com/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
    <category term="元编程" scheme="http://example.com/tags/%E5%85%83%E7%BC%96%E7%A8%8B/"/>
    
    <category term="生成器" scheme="http://example.com/tags/%E7%94%9F%E6%88%90%E5%99%A8/"/>
    
    <category term="类型系统" scheme="http://example.com/tags/%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Python异闻录（二）</title>
    <link href="http://example.com/2025/08/05/Python%E5%BC%82%E9%97%BB%E5%BD%95%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://example.com/2025/08/05/Python%E5%BC%82%E9%97%BB%E5%BD%95%EF%BC%88%E4%BA%8C%EF%BC%89/</id>
    <published>2025-08-05T08:35:56.000Z</published>
    <updated>2025-08-05T08:47:09.685Z</updated>
    
    <content type="html"><![CDATA[<h1 id="4-面向对象"><a href="#4-面向对象" class="headerlink" title="4. 面向对象"></a>4. 面向对象</h1><h2 id="4-1-类与对象基础"><a href="#4-1-类与对象基础" class="headerlink" title="4.1 类与对象基础"></a>4.1 类与对象基础</h2><h3 id="4-1-1-类的定义与对象的创建"><a href="#4-1-1-类的定义与对象的创建" class="headerlink" title="4.1.1 类的定义与对象的创建"></a>4.1.1 类的定义与对象的创建</h3><ul><li>类的语法结构：使用<code>class</code>关键字定义，包含类名、属性和方法</li></ul><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class ClassName:</span><br><span class="line"></span><br><span class="line">  # 类属性</span><br><span class="line"></span><br><span class="line">  class_attribute = value</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  # 实例方法</span><br><span class="line"></span><br><span class="line">  def method_name(self, parameters):</span><br><span class="line"></span><br><span class="line">      # 方法体代码</span><br></pre></td></tr></table></figure></div><ul><li><p>对象的实例化过程及调用类中方法的方式：通过类名加括号实例化对象，如<code>object_name = ClassName()</code>；调用方法为<code>object_name.method_name(arguments)</code></p></li><li><p>类与对象的关系：类是对象的模板，对象是类的实例</p></li></ul><h3 id="4-1-2-类的属性与方法"><a href="#4-1-2-类的属性与方法" class="headerlink" title="4.1.2 类的属性与方法"></a>4.1.2 类的属性与方法</h3><ul><li><p>实例属性与类属性的定义及区别：</p><ul><li><p>实例属性：在<code>__init__</code>方法中通过<code>self</code>定义，每个对象的实例属性独立</p></li><li><p>类属性：在类中直接定义，所有对象共享类属性</p></li></ul></li><li><p>实例方法、类方法与静态方法的定义和使用场景：</p><ul><li><p>实例方法：第一个参数为<code>self</code>，用于操作实例属性</p></li><li><p>类方法：使用<code>@classmethod</code>装饰，第一个参数为<code>cls</code>，用于操作类属性</p></li><li><p>静态方法：使用<code>@staticmethod</code>装饰，无默认参数，与类和实例的状态无关</p></li></ul></li><li><p>方法中<code>self</code>参数的含义及作用：代表实例对象本身，用于访问实例属性和实例方法</p></li></ul><h3 id="4-1-3-继承与多态"><a href="#4-1-3-继承与多态" class="headerlink" title="4.1.3 继承与多态"></a>4.1.3 继承与多态</h3><ul><li><p>继承的基本语法：子类继承父类的属性和方法，语法为<code>class SubClassName(ParentClassName):</code></p></li><li><p>方法重写：子类对父类方法的重新定义，覆盖父类的方法实现</p></li><li><p>多态的概念及在代码中的体现：不同对象调用相同方法呈现不同行为，提高代码的灵活性</p></li></ul><h2 id="4-2-枚举（Enum）"><a href="#4-2-枚举（Enum）" class="headerlink" title="4.2 枚举（Enum）"></a>4.2 枚举（Enum）</h2><ul><li><p>概念：是一种特殊的类，用于定义命名的常量集合，每个常量都是枚举类的实例</p></li><li><p>作用：使代码更具可读性和可维护性，避免使用魔法数字</p></li><li><p>实现：通过<code>enum</code>模块的<code>Enum</code>类实现</p></li></ul><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">from enum import Enum</span><br><span class="line"></span><br><span class="line">class Color(Enum):</span><br><span class="line"></span><br><span class="line">  RED = 1</span><br><span class="line"></span><br><span class="line">  GREEN = 2</span><br><span class="line"></span><br><span class="line">  BLUE = 3</span><br><span class="line"></span><br><span class="line">print(Color.RED)  # 输出Color.RED</span><br><span class="line"></span><br><span class="line">print(Color.RED.value)  # 输出1</span><br><span class="line"></span><br><span class="line">print(Color(2))  # 输出Color.GREEN</span><br></pre></td></tr></table></figure></div><h2 id="4-3-数据类（dataclass）"><a href="#4-3-数据类（dataclass）" class="headerlink" title="4.3 数据类（dataclass）"></a>4.3 数据类（dataclass）</h2><ul><li><p>概念：是一种用于存储数据的类，通过<code>@dataclass</code>装饰器可以自动生成<code>__init__</code>、<code>__repr__</code>、<code>__eq__</code>等方法，简化类的定义</p></li><li><p>作用：减少样板代码，专注于数据的定义</p></li><li><p>语法：使用<code>@dataclass</code>装饰类，在类中定义数据字段</p></li></ul><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">from dataclasses import dataclass</span><br><span class="line"></span><br><span class="line">@dataclass</span><br><span class="line"></span><br><span class="line">class Person:</span><br><span class="line"></span><br><span class="line">  name: str</span><br><span class="line"></span><br><span class="line">  age: int</span><br><span class="line"></span><br><span class="line">  gender: str = &quot;unknown&quot;  # 带有默认值</span><br><span class="line"></span><br><span class="line">p = Person(&quot;Alice&quot;, 18)</span><br><span class="line"></span><br><span class="line">print(p)  # 输出Person(name=&#x27;Alice&#x27;, age=18, gender=&#x27;unknown&#x27;)</span><br><span class="line"></span><br><span class="line">print(p.name)  # 输出Alice</span><br><span class="line"></span><br><span class="line">p2 = Person(&quot;Bob&quot;, 20)</span><br><span class="line"></span><br><span class="line">print(p == p2)  # 输出False</span><br></pre></td></tr></table></figure></div><h2 id="4-4-魔法方法"><a href="#4-4-魔法方法" class="headerlink" title="4.4 魔法方法"></a>4.4 魔法方法</h2><h3 id="4-4-1-魔法方法的特点与作用"><a href="#4-4-1-魔法方法的特点与作用" class="headerlink" title="4.4.1 魔法方法的特点与作用"></a>4.4.1 魔法方法的特点与作用</h3><ul><li><p>以双下划线开头和结尾的特殊方法</p></li><li><p>自动调用的机制及在面向对象编程中的意义：在特定操作时自动触发，用于自定义对象的行为</p></li></ul><h3 id="4-4-2-常用魔法方法"><a href="#4-4-2-常用魔法方法" class="headerlink" title="4.4.2 常用魔法方法"></a>4.4.2 常用魔法方法</h3><ul><li><p><code>__init__</code>方法：对象初始化时的操作，用于设置实例属性</p></li><li><p><code>__str__</code>与<code>__repr__</code>方法：控制对象的字符串表示，<code>__str__</code>更注重可读性，<code>__repr__</code>更注重准确性</p></li><li><p><code>__add__</code>等运算符重载方法：自定义对象的运算规则，如<code>__add__</code>定义<code>+</code>运算符的行为</p></li><li><p><code>__len__</code>方法：获取对象长度的自定义实现，通过<code>len()</code>函数调用</p></li></ul><h2 id="4-5-抽象基类（ABC）"><a href="#4-5-抽象基类（ABC）" class="headerlink" title="4.5 抽象基类（ABC）"></a>4.5 抽象基类（ABC）</h2><ul><li><p>概念：抽象基类是不能被实例化的类，用于定义接口，强制子类实现特定的方法</p></li><li><p>实现：通过<code>abc</code>模块的<code>ABC</code>类和<code>abstractmethod</code>装饰器实现</p></li></ul><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">from abc import ABC, abstractmethod</span><br><span class="line"></span><br><span class="line">class Animal(ABC):</span><br><span class="line"></span><br><span class="line">  @abstractmethod</span><br><span class="line"></span><br><span class="line">  def sound(self):</span><br><span class="line"></span><br><span class="line">      pass  # 抽象方法，无具体实现</span><br><span class="line"></span><br><span class="line">class Dog(Animal):</span><br><span class="line"></span><br><span class="line">  def sound(self):  # 必须实现父类的抽象方法</span><br><span class="line"></span><br><span class="line">      return &quot;Woof!&quot;</span><br><span class="line"></span><br><span class="line">class Cat(Animal):</span><br><span class="line"></span><br><span class="line">  def sound(self):  # 必须实现父类的抽象方法</span><br><span class="line"></span><br><span class="line">      return &quot;Meow!&quot;</span><br><span class="line"></span><br><span class="line">dog = Dog()</span><br><span class="line"></span><br><span class="line">print(dog.sound())  # 输出Woof!</span><br><span class="line"></span><br><span class="line">cat = Cat()</span><br><span class="line"></span><br><span class="line">print(cat.sound())  # 输出Meow!</span><br></pre></td></tr></table></figure></div><h2 id="4-6-属性装饰器（-property）"><a href="#4-6-属性装饰器（-property）" class="headerlink" title="4.6 属性装饰器（@property）"></a>4.6 属性装饰器（@property）</h2><ul><li><p>作用：将方法转换为属性，可像访问属性一样调用方法，同时能控制属性的访问和修改逻辑</p></li><li><p>组成：包含<code>@property</code>装饰的 getter 方法，以及<code>@属性名.setter</code>装饰的 setter 方法</p></li></ul><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class Circle:</span><br><span class="line"></span><br><span class="line">  def __init__(self, radius):</span><br><span class="line"></span><br><span class="line">      self._radius = radius  # 私有变量，约定以单下划线开头</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  @property</span><br><span class="line"></span><br><span class="line">  def radius(self):  # getter方法，用于获取属性值</span><br><span class="line"></span><br><span class="line">      return self._radius</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  @radius.setter</span><br><span class="line"></span><br><span class="line">  def radius(self, value):  # setter方法，用于设置属性值，可添加验证逻辑</span><br><span class="line"></span><br><span class="line">      if value &gt; 0:</span><br><span class="line"></span><br><span class="line">          self._radius = value</span><br><span class="line"></span><br><span class="line">      else:</span><br><span class="line"></span><br><span class="line">          raise ValueError(&quot;Radius must be positive&quot;)</span><br><span class="line"></span><br><span class="line">circle = Circle(5)</span><br><span class="line"></span><br><span class="line">print(circle.radius)  # 输出5，调用getter方法</span><br><span class="line"></span><br><span class="line">circle.radius = 10</span><br><span class="line"></span><br><span class="line">print(circle.radius)  # 输出10，调用setter方法</span><br><span class="line"></span><br><span class="line">circle.radius = -3  # 抛出ValueError异常</span><br></pre></td></tr></table></figure></div><h2 id="4-7-多继承与-MRO（方法解析顺序）"><a href="#4-7-多继承与-MRO（方法解析顺序）" class="headerlink" title="4.7 多继承与 MRO（方法解析顺序）"></a>4.7 多继承与 MRO（方法解析顺序）</h2><ul><li><p>多继承：一个类可以同时继承多个父类，语法为<code>class SubClassName(Parent1, Parent2, ...):</code></p></li><li><p>MRO（Method Resolution Order）：方法解析顺序，用于确定多继承中方法的调用顺序，Python 中采用 C3 线性化算法</p></li><li><p><code>super()</code>的工作原理：根据 MRO 顺序调用父类的方法，而非直接调用某个特定父类</p></li></ul><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class A:</span><br><span class="line"></span><br><span class="line">  def show(self):</span><br><span class="line"></span><br><span class="line">      print(&quot;A&quot;)</span><br><span class="line"></span><br><span class="line">class B(A):</span><br><span class="line"></span><br><span class="line">  def show(self):</span><br><span class="line"></span><br><span class="line">      super().show()  # 调用MRO中下一个类的show方法</span><br><span class="line"></span><br><span class="line">      print(&quot;B&quot;)</span><br><span class="line"></span><br><span class="line">class C(A):</span><br><span class="line"></span><br><span class="line">  def show(self):</span><br><span class="line"></span><br><span class="line">      super().show()</span><br><span class="line"></span><br><span class="line">      print(&quot;C&quot;)</span><br><span class="line"></span><br><span class="line">class D(B, C):</span><br><span class="line"></span><br><span class="line">  def show(self):</span><br><span class="line"></span><br><span class="line">      super().show()</span><br><span class="line"></span><br><span class="line">      print(&quot;D&quot;)</span><br><span class="line"></span><br><span class="line">d = D()</span><br><span class="line"></span><br><span class="line">d.show()</span><br><span class="line"></span><br><span class="line"># 输出顺序：A、C、B、D（根据D的MRO：D -&gt; B -&gt; C -&gt; A -&gt; object）</span><br></pre></td></tr></table></figure></div><h1 id="5-文件操作与异常处理"><a href="#5-文件操作与异常处理" class="headerlink" title="5. 文件操作与异常处理"></a>5. 文件操作与异常处理</h1><h2 id="5-1-文件操作基础"><a href="#5-1-文件操作基础" class="headerlink" title="5.1 文件操作基础"></a>5.1 文件操作基础</h2><h3 id="5-1-1-文件的打开与关闭"><a href="#5-1-1-文件的打开与关闭" class="headerlink" title="5.1.1 文件的打开与关闭"></a>5.1.1 文件的打开与关闭</h3><ul><li><p><code>open()</code>函数的参数：</p><ul><li><p>文件名：指定要操作的文件路径</p></li><li><p>模式：如<code>r</code>（只读）、<code>w</code>（写入）、<code>a</code>（追加）等</p></li><li><p>编码：如<code>utf-8</code>，指定文件的编码格式</p></li></ul></li><li><p>with 语句的使用：自动关闭文件，避免资源泄露，语法为<code>with open(filename, mode, encoding) as file_object:</code></p></li></ul><h3 id="5-1-2-文件读写操作"><a href="#5-1-2-文件读写操作" class="headerlink" title="5.1.2 文件读写操作"></a>5.1.2 文件读写操作</h3><ul><li><p>文本文件的读取：</p><ul><li><p><code>read()</code>：读取整个文件内容</p></li><li><p><code>readline()</code>：读取一行内容</p></li><li><p><code>readlines()</code>：读取所有行，返回一个列表</p></li></ul></li><li><p>文本文件的写入：</p><ul><li><p><code>write()</code>：写入字符串</p></li><li><p><code>writelines()</code>：写入字符串列表</p></li></ul></li><li><p>常见文件操作异常及处理：如<code>FileNotFoundError</code>（文件未找到）、<code>PermissionError</code>（权限错误）等</p></li></ul><h2 id="5-2-永久存储"><a href="#5-2-永久存储" class="headerlink" title="5.2 永久存储"></a>5.2 永久存储</h2><h3 id="5-2-1-数据持久化的概念"><a href="#5-2-1-数据持久化的概念" class="headerlink" title="5.2.1 数据持久化的概念"></a>5.2.1 数据持久化的概念</h3><ul><li><p>将内存中的数据保存到外部存储介质（如硬盘）</p></li><li><p>实现数据长期保存和复用的意义：避免程序运行结束后数据丢失，便于数据的共享和二次处理</p></li></ul><h3 id="5-2-2-常见的永久存储方式"><a href="#5-2-2-常见的永久存储方式" class="headerlink" title="5.2.2 常见的永久存储方式"></a>5.2.2 常见的永久存储方式</h3><ul><li><p>文本文件存储：适用于简单的字符串数据</p></li><li><p>CSV 文件存储：用于表格形式的数据存储，以逗号分隔字段</p></li><li><p>JSON 格式存储：轻量级的数据交换格式，适用于结构化数据</p></li></ul><h3 id="5-2-3-永久存储的实现"><a href="#5-2-3-永久存储的实现" class="headerlink" title="5.2.3 永久存储的实现"></a>5.2.3 永久存储的实现</h3><ul><li><p>使用 Python 内置模块操作不同格式的存储文件：如<code>csv</code>模块操作 CSV 文件，<code>json</code>模块操作 JSON 文件</p></li><li><p>数据的序列化与反序列化：</p><ul><li><p><code>json</code>模块的<code>dump()</code>函数：将数据序列化并写入文件</p></li><li><p><code>json</code>模块的<code>load()</code>函数：从文件中读取数据并反序列化</p></li></ul></li></ul><h2 id="5-3-异常"><a href="#5-3-异常" class="headerlink" title="5.3 异常"></a>5.3 异常</h2><h3 id="5-3-1-异常的概念与类型"><a href="#5-3-1-异常的概念与类型" class="headerlink" title="5.3.1 异常的概念与类型"></a>5.3.1 异常的概念与类型</h3><ul><li><p>异常：程序运行过程中出现的错误，会导致程序终止</p></li><li><p>常见异常类型：<code>SyntaxError</code>（语法错误）、<code>TypeError</code>（类型错误）、<code>ValueError</code>（值错误）、<code>FileNotFoundError</code>（文件未找到错误）等</p></li></ul><h3 id="5-3-2-异常处理机制"><a href="#5-3-2-异常处理机制" class="headerlink" title="5.3.2 异常处理机制"></a>5.3.2 异常处理机制</h3><ul><li>try-except 语句：捕获并处理异常</li></ul><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line"></span><br><span class="line">   # 可能发生异常的代码</span><br><span class="line"></span><br><span class="line">except ExceptionType:</span><br><span class="line"></span><br><span class="line">   # 处理异常的代码</span><br></pre></td></tr></table></figure></div><ul><li>try-except-else 语句：当没有异常发生时执行 else 块</li></ul><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line"></span><br><span class="line">   # 可能发生异常的代码</span><br><span class="line"></span><br><span class="line">except ExceptionType:</span><br><span class="line"></span><br><span class="line">   # 处理异常的代码</span><br><span class="line"></span><br><span class="line">else:</span><br><span class="line"></span><br><span class="line">   # 没有异常时执行的代码</span><br></pre></td></tr></table></figure></div><ul><li>try-except-finally 语句：无论是否发生异常，finally 块都会执行</li></ul><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line"></span><br><span class="line">   # 可能发生异常的代码</span><br><span class="line"></span><br><span class="line">except ExceptionType:</span><br><span class="line"></span><br><span class="line">   # 处理异常的代码</span><br><span class="line"></span><br><span class="line">finally:</span><br><span class="line"></span><br><span class="line">   # 无论是否异常都执行的代码</span><br></pre></td></tr></table></figure></div><h3 id="5-3-3-异常的抛出与自定义"><a href="#5-3-3-异常的抛出与自定义" class="headerlink" title="5.3.3 异常的抛出与自定义"></a>5.3.3 异常的抛出与自定义</h3><ul><li><p>raise 语句：主动抛出异常，如<code>raise Exception(&quot;错误信息&quot;)</code></p></li><li><p>自定义异常类：根据业务需求定义特定的异常类型，继承自<code>Exception</code>类</p></li></ul><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class CustomException(Exception):</span><br><span class="line"></span><br><span class="line">   pass</span><br></pre></td></tr></table></figure></div><h2 id="5-4-上下文管理器的自定义实现"><a href="#5-4-上下文管理器的自定义实现" class="headerlink" title="5.4 上下文管理器的自定义实现"></a>5.4 上下文管理器的自定义实现</h2><ul><li><p>概念：用于管理资源的对象，确保资源在使用后被正确释放，通过<code>with</code>语句使用</p></li><li><p>实现：定义一个类，包含<code>__enter__</code>和<code>__exit__</code>方法</p><ul><li><p><code>__enter__</code>：进入<code>with</code>语句块时调用，返回要管理的资源</p></li><li><p><code>__exit__</code>：离开<code>with</code>语句块时调用，释放资源</p></li></ul></li></ul><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class FileManager:</span><br><span class="line"></span><br><span class="line">   def __init__(self, filename):</span><br><span class="line"></span><br><span class="line">       self.filename = filename</span><br><span class="line"></span><br><span class="line">       self.file = None</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line"></span><br><span class="line">   def __enter__(self):</span><br><span class="line"></span><br><span class="line">       self.file = open(self.filename, &#x27;r&#x27;)  # 获取资源</span><br><span class="line"></span><br><span class="line">       return self.file  # 返回资源供with语句使用</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line"></span><br><span class="line">   def __exit__(self, exc_type, exc_val, exc_tb):</span><br><span class="line"></span><br><span class="line">       if self.file:</span><br><span class="line"></span><br><span class="line">           self.file.close()  # 释放资源</span><br><span class="line"></span><br><span class="line">       # 处理异常（若有），返回True表示异常已处理，不会向外传播</span><br><span class="line"></span><br><span class="line">       return False</span><br><span class="line"></span><br><span class="line">with FileManager(&quot;example.txt&quot;) as f:</span><br><span class="line"></span><br><span class="line">   content = f.read()  # 使用资源</span><br><span class="line"></span><br><span class="line"># 离开with块后，文件自动关闭</span><br></pre></td></tr></table></figure></div><h2 id="5-5-异常链与-from-语法"><a href="#5-5-异常链与-from-语法" class="headerlink" title="5.5 异常链与 from 语法"></a>5.5 异常链与 from 语法</h2><ul><li><p>异常链：当一个异常引发另一个异常时，形成异常链，保留原始异常信息</p></li><li><p><code>from</code>语法：显式指定异常的原因，将原始异常关联到新异常</p></li></ul><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line"></span><br><span class="line">   1 / 0  # 引发ZeroDivisionError</span><br><span class="line"></span><br><span class="line">except ZeroDivisionError as e:</span><br><span class="line"></span><br><span class="line">   # 使用from语法将原始异常e作为新异常的原因</span><br><span class="line"></span><br><span class="line">   raise ValueError(&quot;Invalid input&quot;) from e</span><br></pre></td></tr></table></figure></div><p>执行上述代码会输出：</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line"></span><br><span class="line"> File &quot;...&quot;, line 2, in &lt;module&gt;</span><br><span class="line"></span><br><span class="line">   1 / 0</span><br><span class="line"></span><br><span class="line">ZeroDivisionError: division by zero</span><br><span class="line"></span><br><span class="line">The above exception was the direct cause of the following exception:</span><br><span class="line"></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line"></span><br><span class="line"> File &quot;...&quot;, line 5, in &lt;module&gt;</span><br><span class="line"></span><br><span class="line">   raise ValueError(&quot;Invalid input&quot;) from e</span><br><span class="line"></span><br><span class="line">ValueError: Invalid input</span><br></pre></td></tr></table></figure></div><h1 id="6-并发编程"><a href="#6-并发编程" class="headerlink" title="6. 并发编程"></a>6. 并发编程</h1><h2 id="6-1-多线程基础"><a href="#6-1-多线程基础" class="headerlink" title="6.1 多线程基础"></a>6.1 多线程基础</h2><h3 id="6-1-1-线程的概念与特点"><a href="#6-1-1-线程的概念与特点" class="headerlink" title="6.1.1 线程的概念与特点"></a>6.1.1 线程的概念与特点</h3><ul><li><p>线程：是程序执行的最小单位，一个进程可以包含多个线程，线程共享进程的资源。</p></li><li><p>特点：</p><ul><li><p>轻量级：线程的创建和销毁开销比进程小。</p></li><li><p>共享资源：同一进程内的线程共享内存空间等资源，便于数据交换，但需要注意线程安全。</p></li><li><p>并发执行：多个线程可以同时执行，提高程序的执行效率，尤其是在 I&#x2F;O 密集型任务中。</p></li></ul></li></ul><h3 id="6-1-2-线程的创建与启动"><a href="#6-1-2-线程的创建与启动" class="headerlink" title="6.1.2 线程的创建与启动"></a>6.1.2 线程的创建与启动</h3><ul><li><p>使用 <code>threading</code> 模块创建线程，主要有两种方式：</p><ul><li><p>继承 <code>threading.Thread</code> 类，重写 <code>run()</code> 方法。</p></li><li><p>直接将函数作为参数传递给 <code>threading.Thread</code> 类的构造函数。</p></li></ul></li></ul><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">import threading</span><br><span class="line"></span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line"># 方式一：继承Thread类</span><br><span class="line"></span><br><span class="line">class MyThread(threading.Thread):</span><br><span class="line"></span><br><span class="line">   def run(self):</span><br><span class="line"></span><br><span class="line">       for i in range(3):</span><br><span class="line"></span><br><span class="line">           print(f&quot;Thread &#123;self.name&#125; is running: &#123;i&#125;&quot;)</span><br><span class="line"></span><br><span class="line">           time.sleep(1)</span><br><span class="line"></span><br><span class="line"># 方式二：以函数为参数</span><br><span class="line"></span><br><span class="line">def thread_func(name):</span><br><span class="line"></span><br><span class="line">   for i in range(3):</span><br><span class="line"></span><br><span class="line">       print(f&quot;Thread &#123;name&#125; is running: &#123;i&#125;&quot;)</span><br><span class="line"></span><br><span class="line">       time.sleep(1)</span><br><span class="line"></span><br><span class="line"># 启动线程</span><br><span class="line"></span><br><span class="line">t1 = MyThread(name=&quot;Thread-1&quot;)</span><br><span class="line"></span><br><span class="line">t1.start()</span><br><span class="line"></span><br><span class="line">t2 = threading.Thread(target=thread_func, args=(&quot;Thread-2&quot;,))</span><br><span class="line"></span><br><span class="line">t2.start()</span><br><span class="line"></span><br><span class="line"># 等待线程结束</span><br><span class="line"></span><br><span class="line">t1.join()</span><br><span class="line"></span><br><span class="line">t2.join()</span><br><span class="line"></span><br><span class="line">print(&quot;All threads finished&quot;)</span><br></pre></td></tr></table></figure></div><h3 id="6-1-3-线程同步与锁机制"><a href="#6-1-3-线程同步与锁机制" class="headerlink" title="6.1.3 线程同步与锁机制"></a>6.1.3 线程同步与锁机制</h3><ul><li><p>线程同步：当多个线程共享资源时，为了避免数据竞争和不一致，需要进行线程同步。</p></li><li><p>锁机制：<code>threading.Lock</code> 是常用的同步机制，通过 <code>acquire()</code> 获取锁，<code>release()</code> 释放锁，确保同一时间只有一个线程访问共享资源。</p></li></ul><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">import threading</span><br><span class="line"></span><br><span class="line">count = 0</span><br><span class="line"></span><br><span class="line">lock = threading.Lock()</span><br><span class="line"></span><br><span class="line">def increment():</span><br><span class="line"></span><br><span class="line">   global count</span><br><span class="line"></span><br><span class="line">   for _ in range(100000):</span><br><span class="line"></span><br><span class="line">       lock.acquire()  # 获取锁</span><br><span class="line"></span><br><span class="line">       count += 1</span><br><span class="line"></span><br><span class="line">       lock.release()  # 释放锁</span><br><span class="line"></span><br><span class="line">t1 = threading.Thread(target=increment)</span><br><span class="line"></span><br><span class="line">t2 = threading.Thread(target=increment)</span><br><span class="line"></span><br><span class="line">t1.start()</span><br><span class="line"></span><br><span class="line">t2.start()</span><br><span class="line"></span><br><span class="line">t1.join()</span><br><span class="line"></span><br><span class="line">t2.join()</span><br><span class="line"></span><br><span class="line">print(f&quot;Final count: &#123;count&#125;&quot;)  # 输出200000，保证了结果的正确性</span><br></pre></td></tr></table></figure></div><h2 id="6-2-多进程基础"><a href="#6-2-多进程基础" class="headerlink" title="6.2 多进程基础"></a>6.2 多进程基础</h2><h3 id="6-2-1-进程的概念与特点"><a href="#6-2-1-进程的概念与特点" class="headerlink" title="6.2.1 进程的概念与特点"></a>6.2.1 进程的概念与特点</h3><ul><li><p>进程：是程序的一次执行过程，拥有独立的内存空间和系统资源。</p></li><li><p>特点：</p><ul><li><p>独立性：进程之间相互独立，各自拥有独立的内存空间，互不干扰。</p></li><li><p>开销大：进程的创建、销毁和切换开销比线程大。</p></li><li><p>安全性高：由于进程间内存独立，不会出现线程间的资源竞争问题，但进程间通信相对复杂。</p></li></ul></li></ul><h3 id="6-2-2-进程的创建与启动"><a href="#6-2-2-进程的创建与启动" class="headerlink" title="6.2.2 进程的创建与启动"></a>6.2.2 进程的创建与启动</h3><ul><li><p>使用 <code>multiprocessing</code> 模块创建进程，常用方式与线程类似：</p><ul><li><p>继承 <code>multiprocessing.Process</code> 类，重写 <code>run()</code> 方法。</p></li><li><p>将函数作为参数传递给 <code>multiprocessing.Process</code> 类的构造函数。</p></li></ul></li></ul><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">import multiprocessing</span><br><span class="line"></span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line"># 方式一：继承Process类</span><br><span class="line"></span><br><span class="line">class MyProcess(multiprocessing.Process):</span><br><span class="line"></span><br><span class="line">   def run(self):</span><br><span class="line"></span><br><span class="line">       for i in range(3):</span><br><span class="line"></span><br><span class="line">           print(f&quot;Process &#123;self.name&#125; is running: &#123;i&#125;&quot;)</span><br><span class="line"></span><br><span class="line">           time.sleep(1)</span><br><span class="line"></span><br><span class="line"># 方式二：以函数为参数</span><br><span class="line"></span><br><span class="line">def process_func(name):</span><br><span class="line"></span><br><span class="line">   for i in range(3):</span><br><span class="line"></span><br><span class="line">       print(f&quot;Process &#123;name&#125; is running: &#123;i&#125;&quot;)</span><br><span class="line"></span><br><span class="line">       time.sleep(1)</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:  # 多进程在Windows下必须加上这句</span><br><span class="line"></span><br><span class="line">   p1 = MyProcess(name=&quot;Process-1&quot;)</span><br><span class="line"></span><br><span class="line">   p1.start()</span><br><span class="line"></span><br><span class="line">   p2 = multiprocessing.Process(target=process_func, args=(&quot;Process-2&quot;,))</span><br><span class="line"></span><br><span class="line">   p2.start()</span><br><span class="line"></span><br><span class="line">   p1.join()</span><br><span class="line"></span><br><span class="line">   p2.join()</span><br><span class="line"></span><br><span class="line">   print(&quot;All processes finished&quot;)</span><br></pre></td></tr></table></figure></div><h3 id="6-2-3-进程间通信"><a href="#6-2-3-进程间通信" class="headerlink" title="6.2.3 进程间通信"></a>6.2.3 进程间通信</h3><ul><li><p>由于进程间内存独立，需要特定的机制进行通信，常用的有队列（<code>Queue</code>）和管道（<code>Pipe</code>）。</p><ul><li><p>队列：<code>multiprocessing.Queue</code> 是线程安全的，可用于多个进程间传递数据。</p></li><li><p>管道：<code>multiprocessing.Pipe</code> 用于两个进程间的通信，返回两个连接对象，分别代表管道的两端。</p></li></ul></li></ul><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">import multiprocessing</span><br><span class="line"></span><br><span class="line">def producer(queue):</span><br><span class="line"></span><br><span class="line">   for i in range(5):</span><br><span class="line"></span><br><span class="line">       queue.put(i)</span><br><span class="line"></span><br><span class="line">       print(f&quot;Produced: &#123;i&#125;&quot;)</span><br><span class="line"></span><br><span class="line">def consumer(queue):</span><br><span class="line"></span><br><span class="line">   while True:</span><br><span class="line"></span><br><span class="line">       item = queue.get()</span><br><span class="line"></span><br><span class="line">       if item is None:</span><br><span class="line"></span><br><span class="line">           break</span><br><span class="line"></span><br><span class="line">       print(f&quot;Consumed: &#123;item&#125;&quot;)</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line"></span><br><span class="line">   queue = multiprocessing.Queue()</span><br><span class="line"></span><br><span class="line">   p1 = multiprocessing.Process(target=producer, args=(queue,))</span><br><span class="line"></span><br><span class="line">   p2 = multiprocessing.Process(target=consumer, args=(queue,))</span><br><span class="line"></span><br><span class="line">   p1.start()</span><br><span class="line"></span><br><span class="line">   p2.start()</span><br><span class="line"></span><br><span class="line">   p1.join()</span><br><span class="line"></span><br><span class="line">   queue.put(None)  # 发送结束信号</span><br><span class="line"></span><br><span class="line">   p2.join()</span><br></pre></td></tr></table></figure></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;4-面向对象&quot;&gt;&lt;a href=&quot;#4-面向对象&quot; class=&quot;headerlink&quot; title=&quot;4. 面向对象&quot;&gt;&lt;/a&gt;4. 面向对象&lt;/h1&gt;&lt;h2 id=&quot;4-1-类与对象基础&quot;&gt;&lt;a href=&quot;#4-1-类与对象基础&quot; class=&quot;header</summary>
      
    
    
    
    <category term="Python" scheme="http://example.com/categories/Python/"/>
    
    
    <category term="面向对象" scheme="http://example.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
    <category term="类与对象" scheme="http://example.com/tags/%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/"/>
    
    <category term="魔法方法" scheme="http://example.com/tags/%E9%AD%94%E6%B3%95%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Python异闻录（一）</title>
    <link href="http://example.com/2025/08/05/Python%E5%BC%82%E9%97%BB%E5%BD%95%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://example.com/2025/08/05/Python%E5%BC%82%E9%97%BB%E5%BD%95%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2025-08-05T08:35:46.000Z</published>
    <updated>2025-08-05T08:45:16.273Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Python-基础语法"><a href="#1-Python-基础语法" class="headerlink" title="1. Python 基础语法"></a>1. Python 基础语法</h1><h2 id="1-1-变量与数据类型"><a href="#1-1-变量与数据类型" class="headerlink" title="1.1 变量与数据类型"></a>1.1 变量与数据类型</h2><h3 id="1-1-1-变量的命名规则与赋值方式"><a href="#1-1-1-变量的命名规则与赋值方式" class="headerlink" title="1.1.1 变量的命名规则与赋值方式"></a>1.1.1 变量的命名规则与赋值方式</h3><ul><li><p>命名规则：需遵循 <code>Python</code> 标识符命名规范，由字母、数字和下划线组成，且不能以数字开头</p></li><li><p>赋值方式：使用等号<code>=</code>进行赋值，如<code>variable_name = value</code></p></li></ul><h3 id="1-1-2-基本数据类型"><a href="#1-1-2-基本数据类型" class="headerlink" title="1.1.2 基本数据类型"></a>1.1.2 基本数据类型</h3><ul><li><p>整数 (<code>int</code>)：表示没有小数部分的数字</p></li><li><p>浮点数 (<code>float</code>)：带有小数部分的数字</p></li><li><p>字符串 (<code>str</code>)：由字符组成的序列，用单引号<code>&#39;</code>或双引号<code>&quot;</code>包裹</p></li><li><p>布尔值 (<code>bool</code>)：只有<code>True</code>和<code>False</code>两个值，分别表示真和假</p></li></ul><h3 id="1-1-3-字符串的格式化方法"><a href="#1-1-3-字符串的格式化方法" class="headerlink" title="1.1.3 字符串的格式化方法"></a>1.1.3 字符串的格式化方法</h3><ul><li><p>f-string（Python 3.6+）：在字符串前加<code>f</code>，通过<code>&#123;&#125;</code>嵌入变量或表达式</p></li><li><p><code>.format()</code>方法：使用<code>&#123;&#125;</code>作为占位符，通过<code>format()</code>方法传入参数</p></li><li><p><code>%</code>操作符：使用<code>%</code>作为占位符，按照指定格式进行格式化</p></li></ul><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">name = &quot;Alice&quot;</span><br><span class="line"></span><br><span class="line">print(f&quot;Hello, &#123;name&#125;!&quot;)  # f-string（Python 3.6+）</span><br><span class="line"></span><br><span class="line">print(&quot;Hello, &#123;&#125;!&quot;.format(name))  # format方法</span><br><span class="line"></span><br><span class="line">print(&quot;Hello, %s!&quot; % name)  # %操作符</span><br></pre></td></tr></table></figure></div><h3 id="1-1-4-布尔值的隐式转换规则"><a href="#1-1-4-布尔值的隐式转换规则" class="headerlink" title="1.1.4 布尔值的隐式转换规则"></a>1.1.4 布尔值的隐式转换规则</h3><ul><li><p>以下值在布尔判断中会被视为<code>False</code>：</p><ul><li><p>数字<code>0</code>（包括整数 0、浮点数 0.0 等）</p></li><li><p>空字符串<code>&quot;&quot;</code></p></li><li><p>空列表<code>[]</code>、空元组<code>()</code>、空字典<code>&#123;&#125;</code>、空集合<code>set()</code></p></li><li><p><code>None</code></p></li></ul></li><li><p>其他值通常被视为<code>True</code></p></li></ul><h3 id="1-1-5-数据类型转换及实例应用"><a href="#1-1-5-数据类型转换及实例应用" class="headerlink" title="1.1.5 数据类型转换及实例应用"></a>1.1.5 数据类型转换及实例应用</h3><ul><li><p>常用转换函数：<code>int()</code>、<code>float()</code>、<code>str()</code>、<code>bool()</code></p></li><li><p>实例应用：在不同数据处理场景中进行类型转换以满足运算或操作需求</p></li></ul><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 数据类型转换示例</span><br><span class="line">num_str = &quot;123&quot;</span><br><span class="line"></span><br><span class="line">num_int = int(num_str)</span><br><span class="line"></span><br><span class="line">print(num_int + 1)  # 输出124</span><br></pre></td></tr></table></figure></div><h2 id="1-2-运算符与表达式"><a href="#1-2-运算符与表达式" class="headerlink" title="1.2 运算符与表达式"></a>1.2 运算符与表达式</h2><h3 id="1-2-1-算术运算符及优先级"><a href="#1-2-1-算术运算符及优先级" class="headerlink" title="1.2.1 算术运算符及优先级"></a>1.2.1 算术运算符及优先级</h3><ul><li><p>常用算术运算符：<code>+</code>（加）、<code>-</code>（减）、<code>*</code>（乘）、<code>/</code>（除）、<code>//</code>（整除）、<code>%</code>（取余）、<code>**</code>（幂运算）</p></li><li><p>优先级：先进行幂运算，再进行乘除运算，最后进行加减运算，可使用括号改变运算顺序</p></li></ul><h3 id="1-2-2-比较运算符与逻辑运算符"><a href="#1-2-2-比较运算符与逻辑运算符" class="headerlink" title="1.2.2 比较运算符与逻辑运算符"></a>1.2.2 比较运算符与逻辑运算符</h3><ul><li><p>比较运算符：<code>&gt;</code>（大于）、<code>&lt;</code>（小于）、<code>==</code>（等于）、<code>!=</code>（不等于）、<code>&gt;=</code>（大于等于）、<code>&lt;=</code>（小于等于），返回布尔值</p></li><li><p>逻辑运算符：<code>and</code>（与）、<code>or</code>（或）、<code>not</code>（非），用于组合多个条件</p></li></ul><h3 id="1-2-3-成员运算符和身份运算符"><a href="#1-2-3-成员运算符和身份运算符" class="headerlink" title="1.2.3 成员运算符和身份运算符"></a>1.2.3 成员运算符和身份运算符</h3><ul><li><p>成员运算符：</p><ul><li><p><code>in</code>：判断某个元素是否在序列或集合中，存在返回<code>True</code>，否则返回<code>False</code></p></li><li><p><code>not in</code>：判断某个元素是否不在序列或集合中，不在返回<code>True</code>，否则返回<code>False</code></p></li></ul></li><li><p>身份运算符：</p><ul><li><p><code>is</code>：判断两个对象是否为同一个对象，是返回<code>True</code>，否则返回<code>False</code></p></li><li><p><code>is not</code>：判断两个对象是否不为同一个对象，不是返回<code>True</code>，否则返回<code>False</code></p></li></ul></li></ul><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 成员运算符示例</span><br><span class="line">list1 = [1, 2, 3]</span><br><span class="line"></span><br><span class="line">print(2 in list1)  # 输出True</span><br><span class="line"></span><br><span class="line">print(4 not in list1)  # 输出True</span><br><span class="line"></span><br><span class="line"># 身份运算符示例</span><br><span class="line">a = [1, 2, 3]</span><br><span class="line"></span><br><span class="line">b = a</span><br><span class="line"></span><br><span class="line">c = [1, 2, 3]</span><br><span class="line"></span><br><span class="line">print(a is b)  # 输出True</span><br><span class="line"></span><br><span class="line">print(a is not c)  # 输出True</span><br></pre></td></tr></table></figure></div><h3 id="1-2-4-海象运算符（-，Python-3-8-）"><a href="#1-2-4-海象运算符（-，Python-3-8-）" class="headerlink" title="1.2.4 海象运算符（:&#x3D;，Python 3.8+）"></a>1.2.4 海象运算符（:&#x3D;，Python 3.8+）</h3><ul><li><p>作用：在表达式中同时完成赋值和判断操作</p></li><li><p>用法：将赋值表达式写在<code>:=</code>左侧，右侧为要赋的值</p></li></ul><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (n := len(&quot;hello&quot;)) &gt; 3:</span><br><span class="line"></span><br><span class="line">   print(f&quot;Length is &#123;n&#125;&quot;)  # 输出Length is 5</span><br></pre></td></tr></table></figure></div><h3 id="1-2-5-运算符的链式比较"><a href="#1-2-5-运算符的链式比较" class="headerlink" title="1.2.5 运算符的链式比较"></a>1.2.5 运算符的链式比较</h3><ul><li><p><code>Python</code> 特有的语法糖，可同时进行多个比较操作</p></li><li><p>等价于使用<code>and</code>连接多个比较表达式</p></li></ul><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if 1 &lt; x &lt; 5:  # 等价于 x &gt; 1 and x &lt; 5</span><br><span class="line"></span><br><span class="line">   print(&quot;Valid range&quot;)</span><br></pre></td></tr></table></figure></div><h3 id="1-2-6-赋值运算符及复合赋值的使用"><a href="#1-2-6-赋值运算符及复合赋值的使用" class="headerlink" title="1.2.6 赋值运算符及复合赋值的使用"></a>1.2.6 赋值运算符及复合赋值的使用</h3><ul><li><p>基本赋值运算符：<code>=</code>，将右边的值赋给左边的变量</p></li><li><p>复合赋值运算符：<code>+=</code>、<code>-=</code>、<code>*=</code>、<code>/=</code>等，如<code>a += b</code>等价于<code>a = a + b</code></p></li></ul><h2 id="1-3-流程控制"><a href="#1-3-流程控制" class="headerlink" title="1.3 流程控制"></a>1.3 流程控制</h2><h3 id="1-3-1-条件语句"><a href="#1-3-1-条件语句" class="headerlink" title="1.3.1 条件语句"></a>1.3.1 条件语句</h3><ul><li>if 单分支：当条件满足时执行相应代码块</li></ul><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if condition:</span><br><span class="line"></span><br><span class="line">   # 条件满足时执行的代码</span><br></pre></td></tr></table></figure></div><ul><li>if-else 双分支：条件满足执行一个代码块，不满足执行另一个代码块</li></ul><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if condition:</span><br><span class="line">   # 条件满足时执行的代码</span><br><span class="line"></span><br><span class="line">else:</span><br><span class="line">   # 条件不满足时执行的代码</span><br></pre></td></tr></table></figure></div><ul><li>if-elif-else 多分支：多个条件依次判断，满足其中一个条件就执行相应代码块</li></ul><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if condition1:</span><br><span class="line">   # 满足条件1时执行的代码</span><br><span class="line"></span><br><span class="line">elif condition2:</span><br><span class="line">   # 满足条件2时执行的代码</span><br><span class="line"></span><br><span class="line">else:</span><br><span class="line">   # 所有条件都不满足时执行的代码</span><br></pre></td></tr></table></figure></div><h3 id="1-3-2-三元表达式"><a href="#1-3-2-三元表达式" class="headerlink" title="1.3.2 三元表达式"></a>1.3.2 三元表达式</h3><ul><li><p>概念：是一种简洁的条件表达式，可在一行代码中实现简单的条件判断和赋值操作</p></li><li><p>语法：<code>value_if_true if condition else value_if_false</code></p></li><li><p>应用场景：适用于简单的条件判断，使代码更简洁紧凑</p></li></ul><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 三元表达式示例</span><br><span class="line"></span><br><span class="line">age = 18</span><br><span class="line"></span><br><span class="line">status = &quot;成年人&quot; if age &gt;= 18 else &quot;未成年人&quot;</span><br><span class="line"></span><br><span class="line">print(status)  # 输出&quot;成年人&quot;</span><br></pre></td></tr></table></figure></div><h3 id="1-3-3-循环语句"><a href="#1-3-3-循环语句" class="headerlink" title="1.3.3 循环语句"></a>1.3.3 循环语句</h3><ul><li>for 循环：用于遍历序列或使用<code>range</code>函数生成的数字序列</li></ul><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 遍历序列</span><br><span class="line"></span><br><span class="line">for item in sequence:</span><br><span class="line">   # 循环体代码</span><br><span class="line"></span><br><span class="line"># range函数应用</span><br><span class="line"></span><br><span class="line">for i in range(1, 5):</span><br><span class="line">   print(i)</span><br></pre></td></tr></table></figure></div><ul><li>while 循环：当条件满足时，重复执行循环体</li></ul><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while condition:</span><br><span class="line"></span><br><span class="line">   # 循环体代码</span><br></pre></td></tr></table></figure></div><h3 id="1-3-4-循环控制"><a href="#1-3-4-循环控制" class="headerlink" title="1.3.4 循环控制"></a>1.3.4 循环控制</h3><ul><li><p>break 语句：用于跳出当前循环</p></li><li><p>continue 语句：用于跳过当前循环中的剩余语句，直接进入下一次循环</p></li></ul><h3 id="1-3-5-嵌套循环的逻辑与实例"><a href="#1-3-5-嵌套循环的逻辑与实例" class="headerlink" title="1.3.5 嵌套循环的逻辑与实例"></a>1.3.5 嵌套循环的逻辑与实例</h3><ul><li><p>逻辑：在一个循环内部再包含一个或多个循环</p></li><li><p>实例：</p></li></ul><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for i in range(1, 4):</span><br><span class="line"></span><br><span class="line">   for j in range(1, 4):</span><br><span class="line"></span><br><span class="line">       print(i * j, end=&quot; &quot;)</span><br><span class="line"></span><br><span class="line">   print()</span><br></pre></td></tr></table></figure></div><h2 id="1-4-变量作用域"><a href="#1-4-变量作用域" class="headerlink" title="1.4 变量作用域"></a>1.4 变量作用域</h2><h3 id="1-4-1-全局变量与局部变量"><a href="#1-4-1-全局变量与局部变量" class="headerlink" title="1.4.1 全局变量与局部变量"></a>1.4.1 全局变量与局部变量</h3><ul><li><p>全局变量：在函数外部定义的变量，作用域为整个程序</p></li><li><p>局部变量：在函数内部定义的变量，作用域仅为该函数内部</p></li><li><p><code>global</code>关键字：在函数内部声明变量为全局变量，可修改全局变量的值</p></li></ul><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">x = 10  # 全局变量</span><br><span class="line"></span><br><span class="line">def func():</span><br><span class="line"></span><br><span class="line">   global x  # 声明x为全局变量</span><br><span class="line"></span><br><span class="line">   x = 20  # 修改全局变量的值</span><br><span class="line"></span><br><span class="line">func()</span><br><span class="line"></span><br><span class="line">print(x)  # 输出20</span><br></pre></td></tr></table></figure></div><h2 id="1-5-字符串的原始字符串（Raw-String）"><a href="#1-5-字符串的原始字符串（Raw-String）" class="headerlink" title="1.5 字符串的原始字符串（Raw String）"></a>1.5 字符串的原始字符串（Raw String）</h2><ul><li><p>定义：在字符串前加<code>r</code>或<code>R</code>，字符串中的转义字符不被解析</p></li><li><p>应用场景：处理路径或正则表达式时避免转义字符干扰</p></li></ul><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">path = r&quot;C:UsersNameDocuments&quot;  # 原始字符串，反斜杠不被转义</span><br><span class="line"></span><br><span class="line">print(path)  # 输出C:UsersNameDocuments</span><br></pre></td></tr></table></figure></div><h2 id="1-6-内存机制"><a href="#1-6-内存机制" class="headerlink" title="1.6 内存机制"></a>1.6 内存机制</h2><ul><li><p>引用计数：<code>Python</code>中主要的内存管理方式，每个对象都有一个引用计数器，当引用计数为 0 时，对象被销毁</p></li><li><p>垃圾回收：</p><ul><li><p>当对象之间存在循环引用时，引用计数无法将其回收，此时会启动垃圾回收机制</p></li><li><p>通过<code>gc</code>模块可以手动控制垃圾回收</p></li></ul></li><li><p>内存池：为了提高内存分配效率，<code>Python</code>会预先分配一定数量的小内存块，用于存储小型对象（如整数、短字符串等）</p></li><li><p>不可变对象与内存：不可变对象（如整数、字符串、元组）在创建后不能修改，当对其进行操作时会创建新的对象</p></li></ul><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line"></span><br><span class="line">import gc</span><br><span class="line"></span><br><span class="line"># 引用计数示例</span><br><span class="line"></span><br><span class="line">a = [1, 2, 3]</span><br><span class="line"></span><br><span class="line">print(sys.getrefcount(a))  # 输出2，因为getrefcount函数也会增加一次引用</span><br><span class="line"></span><br><span class="line">b = a</span><br><span class="line"></span><br><span class="line">print(sys.getrefcount(a))  # 输出3</span><br><span class="line"></span><br><span class="line"># 手动触发垃圾回收</span><br><span class="line"></span><br><span class="line">gc.collect()</span><br></pre></td></tr></table></figure></div><h1 id="2-数据结构基础"><a href="#2-数据结构基础" class="headerlink" title="2. 数据结构基础"></a>2. 数据结构基础</h1><h2 id="2-1-序列类型"><a href="#2-1-序列类型" class="headerlink" title="2.1 序列类型"></a>2.1 序列类型</h2><h3 id="2-1-1-列表（List）"><a href="#2-1-1-列表（List）" class="headerlink" title="2.1.1 列表（List）"></a>2.1.1 列表（List）</h3><ul><li><p>创建：使用方括号<code>[]</code>创建，如<code>list_name = [element1, element2, ...]</code></p></li><li><p>索引与切片：通过索引访问单个元素，通过切片获取子列表，索引从 0 开始</p></li><li><p>增删改查操作：</p><ul><li><p>增加：<code>append()</code>、<code>insert()</code>、<code>extend()</code>等方法</p></li><li><p>删除：<code>remove()</code>、<code>pop()</code>、<code>del</code>语句等</p></li><li><p>修改：通过索引直接赋值修改元素</p></li><li><p>查询：<code>in</code>关键字、<code>index()</code>方法等</p></li></ul></li></ul><h3 id="2-1-2-列表推导式与生成器表达式"><a href="#2-1-2-列表推导式与生成器表达式" class="headerlink" title="2.1.2 列表推导式与生成器表达式"></a>2.1.2 列表推导式与生成器表达式</h3><ul><li><p>列表推导式：是一种简化循环和条件判断的写法，能快速生成列表</p></li><li><p>生成器表达式：与列表推导式类似，但返回的是一个生成器对象，更节省内存</p></li></ul><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 列表推导式示例</span><br><span class="line"></span><br><span class="line">squares = [x**2 for x in range(10) if x % 2 == 0]</span><br><span class="line"></span><br><span class="line"># 生成器表达式示例</span><br><span class="line"></span><br><span class="line">gen = (x**2 for x in range(10) if x % 2 == 0)</span><br></pre></td></tr></table></figure></div><h3 id="2-1-3-元组（Tuple）"><a href="#2-1-3-元组（Tuple）" class="headerlink" title="2.1.3 元组（Tuple）"></a>2.1.3 元组（Tuple）</h3><ul><li><p>不可变特性：一旦创建，元素不能被修改</p></li><li><p>适用场景：用于存储不希望被修改的数据，如坐标、配置信息等</p></li><li><p>创建：使用圆括号<code>()</code>创建，如<code>tuple_name = (element1, element2, ...)</code></p></li></ul><h3 id="2-1-4-字符串（String）"><a href="#2-1-4-字符串（String）" class="headerlink" title="2.1.4 字符串（String）"></a>2.1.4 字符串（String）</h3><ul><li><p>常用方法：</p><ul><li><p>拼接：使用<code>+</code>运算符</p></li><li><p>分割：<code>split()</code>方法</p></li><li><p>替换：<code>replace()</code>方法</p></li><li><p>大小写转换：<code>upper()</code>、<code>lower()</code>方法等</p></li></ul></li><li><p>创建：使用单引号<code>&#39;</code>或双引号<code>&quot;</code>包裹，如<code>str_name = &quot;string content&quot;</code></p></li></ul><h2 id="2-2-映射类型"><a href="#2-2-映射类型" class="headerlink" title="2.2 映射类型"></a>2.2 映射类型</h2><h3 id="2-2-1-字典（Dictionary）"><a href="#2-2-1-字典（Dictionary）" class="headerlink" title="2.2.1 字典（Dictionary）"></a>2.2.1 字典（Dictionary）</h3><ul><li><p>键值对结构：由键和对应的值组成，格式为<code>&#123;key1: value1, key2: value2, ...&#125;</code></p></li><li><p>创建与访问：</p><ul><li><p>创建：<code>dict_name = &#123;key1: value1, key2: value2, ...&#125;</code>或<code>dict()</code>函数</p></li><li><p>访问：通过键访问对应的值，如<code>dict_name[key]</code></p></li></ul></li><li><p>键的特性：键必须是不可变类型（如字符串、数字、元组），且不能重复</p></li><li><p>字典的常用操作：</p><ul><li><p>添加：<code>dict_name[new_key] = new_value</code></p></li><li><p>删除：<code>del</code>语句、<code>pop()</code>方法等</p></li><li><p>遍历键值对：<code>for key, value in dict_name.items():</code></p></li></ul></li></ul><h3 id="2-2-2-字典的-setdefault-与-defaultdict"><a href="#2-2-2-字典的-setdefault-与-defaultdict" class="headerlink" title="2.2.2 字典的 setdefault 与 defaultdict"></a>2.2.2 字典的 setdefault 与 defaultdict</h3><ul><li><p><code>setdefault()</code>方法：获取指定键的值，若键不存在则设置默认值并返回</p></li><li><p><code>defaultdict</code>（来自<code>collections</code>模块）：创建字典时指定默认值类型，避免键不存在的错误</p></li></ul><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># setdefault示例</span><br><span class="line"></span><br><span class="line">d = &#123;&#125;</span><br><span class="line"></span><br><span class="line">d.setdefault(&quot;key&quot;, []).append(1)  # 无需先检查键是否存在</span><br><span class="line"></span><br><span class="line">print(d)  # 输出&#123;&#x27;key&#x27;: [1]&#125;</span><br><span class="line"></span><br><span class="line"># defaultdict示例</span><br><span class="line"></span><br><span class="line">from collections import defaultdict</span><br><span class="line"></span><br><span class="line">dd = defaultdict(list)</span><br><span class="line"></span><br><span class="line">dd[&quot;key&quot;].append(1)</span><br><span class="line"></span><br><span class="line">print(dd)  # 输出defaultdict(list, &#123;&#x27;key&#x27;: [1]&#125;)</span><br></pre></td></tr></table></figure></div><h2 id="2-3-集合类型"><a href="#2-3-集合类型" class="headerlink" title="2.3 集合类型"></a>2.3 集合类型</h2><h3 id="2-3-1-集合（Set）"><a href="#2-3-1-集合（Set）" class="headerlink" title="2.3.1 集合（Set）"></a>2.3.1 集合（Set）</h3><ul><li><p>去重特性：自动去除重复元素</p></li><li><p>集合运算：</p><ul><li><p>交集：<code>&amp;</code>运算符或<code>intersection()</code>方法</p></li><li><p>并集：<code>|</code>运算符或<code>union()</code>方法</p></li><li><p>差集：<code>-</code>运算符或<code>difference()</code>方法等</p></li></ul></li><li><p>创建：使用花括号<code>&#123;&#125;</code>或<code>set()</code>函数，如<code>set_name = &#123;element1, element2, ...&#125;</code></p></li></ul><h3 id="2-3-2-集合的基本操作与应用场景"><a href="#2-3-2-集合的基本操作与应用场景" class="headerlink" title="2.3.2 集合的基本操作与应用场景"></a>2.3.2 集合的基本操作与应用场景</h3><ul><li><p>基本操作：添加元素<code>add()</code>、删除元素<code>remove()</code>、清空集合<code>clear()</code>等</p></li><li><p>应用场景：用于数据去重、集合运算等场景</p></li></ul><h3 id="2-3-3-浅拷贝与深拷贝"><a href="#2-3-3-浅拷贝与深拷贝" class="headerlink" title="2.3.3 浅拷贝与深拷贝"></a>2.3.3 浅拷贝与深拷贝</h3><ul><li><p><code>copy()</code>（浅拷贝）：只拷贝对象本身，对于对象中的嵌套对象，只拷贝其引用，原对象和拷贝对象的嵌套对象会相互影响</p></li><li><p><code>deepcopy()</code>（深拷贝）：不仅拷贝对象本身，还会递归拷贝对象中的所有嵌套对象，原对象和拷贝对象的嵌套对象互不影响</p></li></ul><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import copy</span><br><span class="line"></span><br><span class="line"># 浅拷贝示例</span><br><span class="line"></span><br><span class="line">list1 = [1, [2, 3]]</span><br><span class="line"></span><br><span class="line">list2 = list1.copy()</span><br><span class="line"></span><br><span class="line">list1[1].append(4)</span><br><span class="line"></span><br><span class="line">print(list2)  # 输出[1, [2, 3, 4]]</span><br><span class="line"></span><br><span class="line"># 深拷贝示例</span><br><span class="line"></span><br><span class="line">list3 = [1, [2, 3]]</span><br><span class="line"></span><br><span class="line">list4 = copy.deepcopy(list3)</span><br><span class="line"></span><br><span class="line">list3[1].append(4)</span><br><span class="line"></span><br><span class="line">print(list4)  # 输出[1, [2, 3]]</span><br></pre></td></tr></table></figure></div><h3 id="2-3-4-集合的不可变版本-frozenset"><a href="#2-3-4-集合的不可变版本-frozenset" class="headerlink" title="2.3.4 集合的不可变版本 frozenset"></a>2.3.4 集合的不可变版本 frozenset</h3><ul><li><p>特性：创建后不可修改，可作为字典的键或其他集合的元素</p></li><li><p>创建：使用<code>frozenset()</code>函数</p></li></ul><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fs = frozenset([1, 2, 3])</span><br><span class="line"></span><br><span class="line">d = &#123;fs: &quot;value&quot;&#125;  # 可作为字典的键</span><br><span class="line"></span><br><span class="line">print(d)  # 输出&#123;frozenset(&#123;1, 2, 3&#125;): &#x27;value&#x27;&#125;</span><br></pre></td></tr></table></figure></div><h2 id="2-4-队列与栈的实现"><a href="#2-4-队列与栈的实现" class="headerlink" title="2.4 队列与栈的实现"></a>2.4 队列与栈的实现</h2><ul><li><p>使用<code>collections.deque</code>高效实现，提供两端快速添加和删除元素的操作</p></li><li><p>队列：先进先出（FIFO），使用<code>append()</code>入队，<code>popleft()</code>出队</p></li><li><p>栈：后进先出（LIFO），使用<code>append()</code>入栈，<code>pop()</code>出栈</p></li></ul><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">from collections import deque</span><br><span class="line"></span><br><span class="line"># 队列实现</span><br><span class="line"></span><br><span class="line">queue = deque()</span><br><span class="line"></span><br><span class="line">queue.append(1)  # 入队</span><br><span class="line"></span><br><span class="line">queue.append(2)</span><br><span class="line"></span><br><span class="line">print(queue.popleft())  # 出队，输出1</span><br><span class="line"></span><br><span class="line"># 栈实现</span><br><span class="line"></span><br><span class="line">stack = deque()</span><br><span class="line"></span><br><span class="line">stack.append(1)  # 入栈</span><br><span class="line"></span><br><span class="line">stack.append(2)</span><br><span class="line"></span><br><span class="line">print(stack.pop())  # 出栈，输出2</span><br></pre></td></tr></table></figure></div><h1 id="3-函数编程"><a href="#3-函数编程" class="headerlink" title="3. 函数编程"></a>3. 函数编程</h1><h2 id="3-1-函数基础"><a href="#3-1-函数基础" class="headerlink" title="3.1 函数基础"></a>3.1 函数基础</h2><h3 id="3-1-1-函数的定义与调用"><a href="#3-1-1-函数的定义与调用" class="headerlink" title="3.1.1 函数的定义与调用"></a>3.1.1 函数的定义与调用</h3><ul><li>函数的语法结构：使用<code>def</code>关键字定义，包含函数名、参数和返回值</li></ul><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def function_name(parameters):</span><br><span class="line"></span><br><span class="line">   # 函数体代码</span><br><span class="line"></span><br><span class="line">   return return_value</span><br></pre></td></tr></table></figure></div><ul><li>函数调用的方式及参数传递：通过函数名加括号调用，如<code>function_name(arguments)</code>，参数按位置或关键字传递</li></ul><h3 id="3-1-2-函数参数"><a href="#3-1-2-函数参数" class="headerlink" title="3.1.2 函数参数"></a>3.1.2 函数参数</h3><ul><li><p>位置参数与关键字参数的使用区别：</p><ul><li><p>位置参数：按参数位置顺序传递</p></li><li><p>关键字参数：通过参数名指定传递的值，可改变参数顺序</p></li></ul></li><li><p>默认参数的设置与注意事项：在定义函数时为参数指定默认值，默认参数必须放在位置参数后面</p></li><li><p>不定长参数的应用：</p><ul><li><p><code>*args</code>：接收任意数量的位置参数，返回一个元组</p></li><li><p><code>**kwargs</code>：接收任意数量的关键字参数，返回一个字典</p></li></ul></li></ul><h3 id="3-1-3-函数的返回值"><a href="#3-1-3-函数的返回值" class="headerlink" title="3.1.3 函数的返回值"></a>3.1.3 函数的返回值</h3><ul><li><p>return 语句的作用：用于返回函数的计算结果，结束函数执行</p></li><li><p>多返回值的处理方式：返回多个值时，以元组形式返回，可通过多个变量接收</p></li><li><p>函数的嵌套调用：在一个函数内部调用另一个函数</p></li></ul><h2 id="3-2-lambda-表达式"><a href="#3-2-lambda-表达式" class="headerlink" title="3.2 lambda 表达式"></a>3.2 lambda 表达式</h2><ul><li><p>概念：是一种匿名函数，即没有函数名的函数，语法简洁，适用于创建简单的函数</p></li><li><p>语法：<code>lambda parameters: expression</code>，其中<code>parameters</code>是参数列表，<code>expression</code>是函数体，返回表达式的结果</p></li><li><p>应用场景：作为参数传递给高阶函数（如<code>map()</code>、<code>filter()</code>、<code>sorted()</code>等），简化代码编写</p></li></ul><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># lambda表达式示例</span><br><span class="line"></span><br><span class="line">add = lambda x, y: x + y</span><br><span class="line"></span><br><span class="line">print(add(3, 5))  # 输出8</span><br><span class="line"></span><br><span class="line"># 作为sorted函数的key参数</span><br><span class="line"></span><br><span class="line">students = [(&quot;Alice&quot;, 20), (&quot;Bob&quot;, 18), (&quot;Charlie&quot;, 22)]</span><br><span class="line"></span><br><span class="line">sorted_students = sorted(students, key=lambda x: x[1])  # 按年龄排序</span><br></pre></td></tr></table></figure></div><h2 id="3-3-类型注解"><a href="#3-3-类型注解" class="headerlink" title="3.3 类型注解"></a>3.3 类型注解</h2><ul><li><p>概念：是一种为函数参数、返回值以及变量指定数据类型的方式，提高代码的可读性和可维护性，便于静态类型检查工具进行类型检查</p></li><li><p>语法：</p><ul><li><p>函数参数注解：<code>def function_name(param: type) -&gt; return_type:</code></p></li><li><p>变量注解：<code>variable_name: type = value</code></p></li></ul></li><li><p>注意事项：类型注解不会影响程序的运行，仅作为提示信息</p></li></ul><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 函数参数和返回值注解</span><br><span class="line"></span><br><span class="line">def add(a: int, b: int) -&gt; int:</span><br><span class="line"></span><br><span class="line">   return a + b</span><br><span class="line"></span><br><span class="line"># 变量注解</span><br><span class="line"></span><br><span class="line">name: str = &quot;Alice&quot;</span><br><span class="line"></span><br><span class="line">age: int = 18</span><br><span class="line"></span><br><span class="line">scores: list[float] = [90.5, 88.0, 95.5]</span><br></pre></td></tr></table></figure></div><h2 id="3-4-高阶函数"><a href="#3-4-高阶函数" class="headerlink" title="3.4 高阶函数"></a>3.4 高阶函数</h2><h3 id="3-4-1-高阶函数的定义"><a href="#3-4-1-高阶函数的定义" class="headerlink" title="3.4.1 高阶函数的定义"></a>3.4.1 高阶函数的定义</h3><ul><li><p>接受函数作为参数或返回函数的函数</p></li><li><p>高阶函数在代码复用和逻辑抽象中的作用：提高代码的复用性，简化复杂逻辑的实现</p></li></ul><h3 id="3-4-2-常用高阶函数"><a href="#3-4-2-常用高阶函数" class="headerlink" title="3.4.2 常用高阶函数"></a>3.4.2 常用高阶函数</h3><ul><li><p><code>map()</code>函数：对可迭代对象中的元素应用指定函数，返回一个迭代器</p></li><li><p><code>filter()</code>函数：根据指定条件筛选可迭代对象中的元素，返回一个迭代器</p></li><li><p><code>sorted()</code>函数：对可迭代对象进行排序，可通过<code>key</code>参数自定义排序规则</p></li></ul><h3 id="3-4-3-高阶函数的应用实例"><a href="#3-4-3-高阶函数的应用实例" class="headerlink" title="3.4.3 高阶函数的应用实例"></a>3.4.3 高阶函数的应用实例</h3><ul><li>利用<code>map()</code>实现数据类型批量转换：</li></ul><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str_list = [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;]</span><br><span class="line"></span><br><span class="line">int_list = list(map(int, str_list))</span><br></pre></td></tr></table></figure></div><ul><li>借助<code>filter()</code>筛选符合条件的数据：</li></ul><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">numbers = [1, 2, 3, 4, 5, 6]</span><br><span class="line"></span><br><span class="line">even_numbers = list(filter(lambda x: x % 2 == 0, numbers))</span><br></pre></td></tr></table></figure></div><ul><li>通过<code>sorted()</code>对复杂数据结构进行排序：</li></ul><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">students = [(&quot;Alice&quot;, 20), (&quot;Bob&quot;, 18), (&quot;Charlie&quot;, 22)]</span><br><span class="line"></span><br><span class="line">sorted_students = sorted(students, key=lambda x: x[1])</span><br></pre></td></tr></table></figure></div><h2 id="3-5-闭包与装饰器"><a href="#3-5-闭包与装饰器" class="headerlink" title="3.5 闭包与装饰器"></a>3.5 闭包与装饰器</h2><h3 id="3-5-1-闭包"><a href="#3-5-1-闭包" class="headerlink" title="3.5.1 闭包"></a>3.5.1 闭包</h3><ul><li><p>概念：函数嵌套时，内部函数引用了外部函数的变量，并且外部函数返回内部函数，这样的内部函数称为闭包</p></li><li><p>作用：保留外部变量的状态，实现数据封装和复用</p></li></ul><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">def outer():</span><br><span class="line"></span><br><span class="line">  x = 1</span><br><span class="line"></span><br><span class="line">  def inner():</span><br><span class="line"></span><br><span class="line">      print(x)  # 记住x的值</span><br><span class="line"></span><br><span class="line">  return inner</span><br><span class="line"></span><br><span class="line">closure_func = outer()</span><br><span class="line"></span><br><span class="line">closure_func()  # 输出1</span><br></pre></td></tr></table></figure></div><h3 id="3-5-2-装饰器"><a href="#3-5-2-装饰器" class="headerlink" title="3.5.2 装饰器"></a>3.5.2 装饰器</h3><ul><li><p>概念：是一种修改函数行为的工具，本质上是一个高阶函数，接受函数作为参数，并返回一个新的函数</p></li><li><p>作用：在不修改原函数代码的情况下，为函数添加额外功能，如日志记录、性能测试等</p></li></ul><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line"></span><br><span class="line">def log_time(func):</span><br><span class="line"></span><br><span class="line">  def wrapper(*args, **kwargs):</span><br><span class="line"></span><br><span class="line">      start = time.time()</span><br><span class="line"></span><br><span class="line">      result = func(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">      print(f&quot;Time used: &#123;time.time() - start&#125;&quot;)</span><br><span class="line"></span><br><span class="line">      return result</span><br><span class="line"></span><br><span class="line">  return wrapper</span><br><span class="line"></span><br><span class="line">@log_time</span><br><span class="line"></span><br><span class="line">def add(a, b):</span><br><span class="line"></span><br><span class="line">  return a + b</span><br><span class="line"></span><br><span class="line">add(3, 5)  # 输出Time used: ...（具体时间）并返回8</span><br></pre></td></tr></table></figure></div><h2 id="3-6-偏函数（functools-partial）"><a href="#3-6-偏函数（functools-partial）" class="headerlink" title="3.6 偏函数（functools.partial）"></a>3.6 偏函数（functools.partial）</h2><ul><li><p>概念：通过固定函数的部分参数，生成一个新的函数</p></li><li><p>作用：简化函数调用，当函数的某些参数经常取固定值时，可使用偏函数减少重复传递参数的工作</p></li></ul><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">from functools import partial</span><br><span class="line"></span><br><span class="line"># 原函数pow(base, exp)，计算base的exp次方</span><br><span class="line"></span><br><span class="line">pow_2 = partial(pow, exp=2)  # 固定exp参数为2</span><br><span class="line"></span><br><span class="line">print(pow_2(5))  # 输出25，等价于pow(5, 2)</span><br><span class="line"></span><br><span class="line">pow_3 = partial(pow, exp=3)  # 固定exp参数为3</span><br><span class="line"></span><br><span class="line">print(pow_3(2))  # 输出8，等价于pow(2, 3)</span><br></pre></td></tr></table></figure></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-Python-基础语法&quot;&gt;&lt;a href=&quot;#1-Python-基础语法&quot; class=&quot;headerlink&quot; title=&quot;1. Python 基础语法&quot;&gt;&lt;/a&gt;1. Python 基础语法&lt;/h1&gt;&lt;h2 id=&quot;1-1-变量与数据类型&quot;&gt;&lt;a hre</summary>
      
    
    
    
    <category term="Python教程" scheme="http://example.com/categories/Python%E6%95%99%E7%A8%8B/"/>
    
    <category term="语法详解" scheme="http://example.com/categories/Python%E6%95%99%E7%A8%8B/%E8%AF%AD%E6%B3%95%E8%AF%A6%E8%A7%A3/"/>
    
    
    <category term="Python基础" scheme="http://example.com/tags/Python%E5%9F%BA%E7%A1%80/"/>
    
    <category term="数据类型" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    
    <category term="函数编程" scheme="http://example.com/tags/%E5%87%BD%E6%95%B0%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>《水印处理的成长日记：从0开始的PDF处理之路》</title>
    <link href="http://example.com/2025/07/16/%E3%80%8A%E6%B0%B4%E5%8D%B0%E5%A4%84%E7%90%86%E7%9A%84%E6%88%90%E9%95%BF%E6%97%A5%E8%AE%B0%EF%BC%9A%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84PDF%E5%A4%84%E7%90%86%E4%B9%8B%E8%B7%AF%E3%80%8B/"/>
    <id>http://example.com/2025/07/16/%E3%80%8A%E6%B0%B4%E5%8D%B0%E5%A4%84%E7%90%86%E7%9A%84%E6%88%90%E9%95%BF%E6%97%A5%E8%AE%B0%EF%BC%9A%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84PDF%E5%A4%84%E7%90%86%E4%B9%8B%E8%B7%AF%E3%80%8B/</id>
    <published>2025-07-16T10:02:16.000Z</published>
    <updated>2025-07-17T07:21:58.663Z</updated>
    
    <content type="html"><![CDATA[<p>在日常办公和学习中，我们经常会遇到带有水印的 PDF 文档，这些水印不仅影响阅读体验，还可能干扰文档的二次编辑和使用。本文将带你从零开始，一步步构建一个功能完善的 PDF 水印去除工具，实现从单文件处理到批量转换的完整解决方案。</p><p>需求分析：为什么需要 PDF 水印去除工具</p><p>PDF 水印通常分为可见水印和不可见水印两类。可见水印多以文字、Logo 等形式存在，虽然不影响内容的可读性，但在文档分发、打印等场景下会显得不够专业。特别是一些带有 “内部资料”、”草稿” 等字样的水印，在正式场合使用时需要去除。</p><p>理想的 PDF 水印去除工具应具备以下功能：</p><ul><li><p>精准识别并去除各类可见水印</p></li><li><p>保留原文档的文本格式和图片内容</p></li><li><p>支持批量处理多个 PDF 文件</p></li><li><p>提供直观易用的图形界面</p></li><li><p>输出格式支持 Word，方便后续编辑</p></li></ul><p>基础版本：实现单文件水印去除功能</p><p>我们先从基础版本开始，搭建一个能够处理单个 PDF 文件的水印去除工具。这个版本将实现水印识别、内容提取和格式转换的核心功能。</p><h3 id="核心技术选型-xA"><a href="#核心技术选型-xA" class="headerlink" title="核心技术选型&#xA;"></a>核心技术选型&#xA;</h3><p>实现 PDF 水印去除需要用到以下关键库：</p><ul><li><p><code>fitz</code>（PyMuPDF）：用于 PDF 文件的解析和内容提取</p></li><li><p><code>python-docx</code>：用于生成 Word 格式的输出文件</p></li><li><p><code>PIL</code>（Pillow）：用于处理 PDF 中的图片内容</p></li><li><p><code>PyQt5</code>：用于构建图形用户界面</p></li></ul><h3 id="核心功能实现-xA"><a href="#核心功能实现-xA" class="headerlink" title="核心功能实现&#xA;"></a>核心功能实现&#xA;</h3><p>基础版本的核心功能主要分为三个模块：PDF 信息提取、水印识别与去除、Word 文档生成。</p><h4 id="PDF-信息提取模块-xA"><a href="#PDF-信息提取模块-xA" class="headerlink" title="PDF 信息提取模块&#xA;"></a>PDF 信息提取模块&#xA;</h4><p><code>extract_full_pdf_info</code>函数负责从 PDF 中提取文本内容、图片和格式信息：</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">def extract_full_pdf_info(pdf_path: str) -&gt; List[Dict[str, Any]]:</span><br><span class="line">    if not os.path.exists(pdf_path):</span><br><span class="line">        raise FileNotFoundError(f&quot;PDF文件未找到: &#123;pdf_path&#125;&quot;)</span><br><span class="line">    doc = fitz.open(pdf_path)</span><br><span class="line">    full_info = []</span><br><span class="line">    temp_image_dir = os.path.abspath(&quot;temp_pdf_images&quot;)</span><br><span class="line">    os.makedirs(temp_image_dir, exist_ok=True)</span><br><span class="line">    for page_num in range(len(doc)):</span><br><span class="line">        page = doc[page_num]</span><br><span class="line">        page_data = &#123;</span><br><span class="line">            &quot;page_number&quot;: page_num + 1,</span><br><span class="line">            &quot;page_size&quot;: &#123;&quot;width&quot;: page.rect.width, &quot;height&quot;: page.rect.height&#125;,</span><br><span class="line">            &quot;rotation&quot;: page.rotation,</span><br><span class="line">            &quot;text_content&quot;: [],</span><br><span class="line">            &quot;images&quot;: []</span><br><span class="line">        &#125;</span><br><span class="line">        # 提取文本内容</span><br><span class="line">        text_blocks = page.get_text(&quot;dict&quot;)[&quot;blocks&quot;]</span><br><span class="line">        for block in text_blocks:</span><br><span class="line">            if block[&quot;type&quot;] == 0:  # 文本块</span><br><span class="line">                # 处理文本块、行和文字片段...</span><br><span class="line">        # 提取图片</span><br><span class="line">        images = page.get_images(full=True)</span><br><span class="line">        # 处理图片提取、软掩码合并和格式转换...</span><br><span class="line">        full_info.append(page_data)</span><br><span class="line">    doc.close()</span><br><span class="line">    return full_info</span><br></pre></td></tr></table></figure></div><h4 id="水印识别与去除模块-xA"><a href="#水印识别与去除模块-xA" class="headerlink" title="水印识别与去除模块&#xA;"></a>水印识别与去除模块&#xA;</h4><p><code>remove_watermark_by_alpha</code>函数通过分析文本的透明度、字体大小和颜色来识别并去除水印：</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">def remove_watermark_by_alpha(full_info: List[Dict[str, Any]]) -&gt; List[Dict[str, Any]]:</span><br><span class="line">    clean_full_info = []</span><br><span class="line">    watermark_removed_count = 0</span><br><span class="line">    ALPHA_THRESHOLD = 150  # 透明度阈值</span><br><span class="line">    TARGET_FONT_SIZE = 18  # 水印字体大小</span><br><span class="line">    FONT_SIZE_TOLERANCE = 1  # 字体大小容差</span><br><span class="line">    TARGET_COLOR_INT_VALUE = 13882323  # 水印颜色值</span><br><span class="line">    for page in full_info:</span><br><span class="line">        clean_text_blocks = []</span><br><span class="line">        for text_block in page[&quot;text_content&quot;]:</span><br><span class="line">            # 处理文本块，过滤水印内容...</span><br><span class="line">            watermark_removed_count += 1  # 统计去除的水印数量</span><br><span class="line">        clean_page = &#123;**page, &quot;text_content&quot;: clean_text_blocks, &quot;images&quot;: page[&quot;images&quot;]&#125;</span><br><span class="line">        clean_full_info.append(clean_page)</span><br><span class="line">    print(f&quot;水印移除完成。共移除 &#123;watermark_removed_count&#125; 处水印文本。&quot;)</span><br><span class="line">    return clean_full_info</span><br></pre></td></tr></table></figure></div><h4 id="Word-文档生成模块-xA"><a href="#Word-文档生成模块-xA" class="headerlink" title="Word 文档生成模块&#xA;"></a>Word 文档生成模块&#xA;</h4><p><code>generate_word_from_data</code>函数将清理后的内容转换为 Word 文档：</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def generate_word_from_data(clean_info: List[Dict[str, Any]], output_word_path: str) -&gt; None:</span><br><span class="line">    doc = Document()</span><br><span class="line">    font_mapping = get_system_font_mapping()  # 字体映射表</span><br><span class="line">    # 收集并排序文本和图片元素...</span><br><span class="line">    # 生成Word内容，保留原格式...</span><br><span class="line">    try:</span><br><span class="line">        doc.save(output_word_path)</span><br><span class="line">        print(f&quot;Word文档已保存至：&#123;output_word_path&#125;&quot;)</span><br><span class="line">    except Exception as e:</span><br><span class="line">       print(f&quot;保存Word文档失败：&#123;e&#125;&quot;)</span><br></pre></td></tr></table></figure></div><h3 id="基础版本界面设计-xA"><a href="#基础版本界面设计-xA" class="headerlink" title="基础版本界面设计&#xA;"></a>基础版本界面设计&#xA;</h3><p>基础版本采用简洁的图形界面，主要包含文件选择、处理和状态显示功能：</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class PdfWatermarkRemoverApp(QWidget):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        super().__init__()</span><br><span class="line">        self.setWindowTitle(&quot;PDF水印移除工具&quot;)</span><br><span class="line">        self.setFixedSize(750, 400)</span><br><span class="line">        self.init_ui()</span><br><span class="line">        # 初始化其他属性...</span><br><span class="line">    def init_ui(self):</span><br><span class="line">        main_layout = QVBoxLayout()</span><br><span class="line">        # 设置布局、添加文件选择框、处理按钮和状态标签...</span><br><span class="line">    def browse_pdf_file(self):</span><br><span class="line">        # 打开文件对话框，选择PDF文件...</span><br><span class="line">    def start_processing(self):</span><br><span class="line">        # 开始处理PDF文件...</span><br></pre></td></tr></table></figure></div><p>优化版本：功能增强与体验提升</p><p>在基础版本的基础上，我们进一步优化功能，增加批量处理能力，提升用户体验，打造一个更实用的工具。</p><h3 id="核心功能改进-xA"><a href="#核心功能改进-xA" class="headerlink" title="核心功能改进&#xA;"></a>核心功能改进&#xA;</h3><p>优化版本主要在以下几个方面进行了改进：</p><h4 id="1-增加文件夹批量处理功能-xA"><a href="#1-增加文件夹批量处理功能-xA" class="headerlink" title="1. 增加文件夹批量处理功能&#xA;"></a>1. 增加文件夹批量处理功能&#xA;</h4><p>用户可以选择整个文件夹进行批量处理，工具会自动识别并处理文件夹中的所有 PDF 文件：</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def browse_folder(self):</span><br><span class="line">    folder_path = QFileDialog.getExistingDirectory(self, &quot;选择包含 PDF 文件的文件夹&quot;)</span><br><span class="line">    if folder_path:</span><br><span class="line">        self.processing_queue = []</span><br><span class="line">        # 遍历文件夹，收集所有PDF文件...</span><br><span class="line">        self.total_files_to_process = len(self.processing_queue)</span><br><span class="line">        self.processing_mode = &quot;folder&quot;</span><br><span class="line">       # 更新界面显示...</span><br></pre></td></tr></table></figure></div><h4 id="2-改进的文件处理流程-xA"><a href="#2-改进的文件处理流程-xA" class="headerlink" title="2. 改进的文件处理流程&#xA;"></a>2. 改进的文件处理流程&#xA;</h4><p>引入处理队列和工作线程，支持连续处理多个文件，并显示实时进度：</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def process_next_file(self):</span><br><span class="line">    if not self.processing_queue:</span><br><span class="line">        self.on_all_processing_finished()  # 所有文件处理完成</span><br><span class="line">        return</span><br><span class="line">    current_pdf_path = self.processing_queue.pop(0)</span><br><span class="line">    # 确定输出路径...</span><br><span class="line">    # 检查文件是否已存在，处理覆盖逻辑...</span><br><span class="line">    self.processed_count += 1</span><br><span class="line">   self.status_label.setText(f&quot;正在处理第 &#123;self.processed_count&#125; / &#123;self.total_files_to_process&#125; 个文件...&quot;)</span><br><span class="line">    # 启动工作线程处理当前文件...</span><br></pre></td></tr></table></figure></div><h4 id="3-增强的图片处理能力-xA"><a href="#3-增强的图片处理能力-xA" class="headerlink" title="3. 增强的图片处理能力&#xA;"></a>3. 增强的图片处理能力&#xA;</h4><p>优化图片提取和转换逻辑，更好地保留图片质量和透明度：</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">def convert_image_format(temp_path, target_format=&#x27;png&#x27;):</span><br><span class="line">    try:</span><br><span class="line">        with Image.open(temp_path) as img:</span><br><span class="line">            original_mode = img.mode</span><br><span class="line">            new_path = os.path.splitext(temp_path)[0] + f&#x27;.&#123;target_format&#125;&#x27;</span><br><span class="line">            if &#x27;A&#x27; in original_mode:  # 处理透明图片</span><br><span class="line">                if original_mode != &#x27;RGBA&#x27;:</span><br><span class="line">                    img = img.convert(&#x27;RGBA&#x27;)</span><br><span class="line"></span><br><span class="line">               img.save(new_path, format=target_format.upper())</span><br><span class="line">               # 输出转换信息...</span><br><span class="line">           else:</span><br><span class="line">               # 处理非透明图片...</span><br><span class="line">           return new_path</span><br><span class="line">   except Exception as e:</span><br><span class="line">       # 处理转换错误...</span><br></pre></td></tr></table></figure></div><h4 id="4-更智能的文本格式处理-xA"><a href="#4-更智能的文本格式处理-xA" class="headerlink" title="4. 更智能的文本格式处理&#xA;"></a>4. 更智能的文本格式处理&#xA;</h4><p>优化文本排版逻辑，自动识别标题、段落，保持原文档的格式风格：</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 分析最常见的字体大小作为正文字体</span><br><span class="line">if all_font_sizes:</span><br><span class="line">   from collections import Counter</span><br><span class="line">   most_common_size = Counter(all_font_sizes).most_common(1)[0][0]</span><br><span class="line">   print(f&quot;分析得出正文字体大小: &#123;most_common_size&#125;&quot;)</span><br><span class="line">   title_font_threshold = most_common_size * 1.2  # 标题字体阈值</span><br><span class="line">else:</span><br><span class="line">   # 使用默认值...</span><br></pre></td></tr></table></figure></div><h3 id="界面与交互优化-xA"><a href="#界面与交互优化-xA" class="headerlink" title="界面与交互优化&#xA;"></a>界面与交互优化&#xA;</h3><p>优化版本的界面更加友好，交互更加流畅：</p><h4 id="1-直观的文件选择界面-xA"><a href="#1-直观的文件选择界面-xA" class="headerlink" title="1. 直观的文件选择界面&#xA;"></a>1. 直观的文件选择界面&#xA;</h4><p>提供文件和文件夹两种选择方式，满足不同场景需求：</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 选择文件按钮</span><br><span class="line">self.browse_files_button = QPushButton(&quot;选择文件...&quot;)</span><br><span class="line">self.browse_files_button.clicked.connect(self.browse_pdf_files)</span><br><span class="line"></span><br><span class="line"># 选择文件夹按钮</span><br><span class="line">self.browse_folder_button = QPushButton(&quot;选择文件夹...&quot;)</span><br><span class="line">self.browse_folder_button.clicked.connect(self.browse_folder)</span><br></pre></td></tr></table></figure></div><h4 id="2-实时进度显示-xA"><a href="#2-实时进度显示-xA" class="headerlink" title="2. 实时进度显示&#xA;"></a>2. 实时进度显示&#xA;</h4><p>清晰展示当前处理进度和状态，让用户了解处理情况：</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">self.status_label = QLabel(&quot;等待选择文件/文件夹...&quot;)</span><br><span class="line">self.current_file_status_label = QLabel(&quot;&quot;)  # 显示当前处理的文件名</span><br></pre></td></tr></table></figure></div><h4 id="3-文件覆盖策略选择-xA"><a href="#3-文件覆盖策略选择-xA" class="headerlink" title="3. 文件覆盖策略选择&#xA;"></a>3. 文件覆盖策略选择&#xA;</h4><p>当输出文件已存在时，提供灵活的覆盖选项：</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 覆盖所有文件复选框</span><br><span class="line">self.overwrite_all_checkbox = QCheckBox(&quot;对当前批次的所有冲突文件执行此操作&quot;)</span><br><span class="line">self.overwrite_all_checkbox.setVisible(False)  # 默认隐藏</span><br></pre></td></tr></table></figure></div><p>工具使用指南</p><p>使用优化后的 PDF 水印去除工具非常简单，只需几个步骤即可完成水印去除：</p><ol><li><p><strong>选择文件或文件夹</strong>：点击 “选择文件” 按钮处理单个 PDF，或点击 “选择文件夹” 按钮批量处理多个 PDF。</p></li><li><p><strong>开始处理</strong>：点击 “开始处理” 按钮，工具将自动去除水印并转换为 Word 格式。</p></li><li><p><strong>查看结果</strong>：处理完成后，工具会显示成功和失败的文件统计，结果文件将保存在源文件所在目录的 “_无水印” 子文件夹中。</p></li></ol><p>常见问题与解决方案</p><p>在使用过程中，可能会遇到一些常见问题，以下是解决方案：</p><ol><li><p><strong>水印去除不彻底</strong>：可能是水印特征发生变化，可以调整 <code>remove_watermark_by_alpha</code> 函数中的阈值参数。</p></li><li><p><strong>图片显示异常</strong>：部分特殊格式的图片可能转换失败，可以尝试更新 Pillow 库到最新版本。</p></li><li><p><strong>格式错乱</strong>：复杂排版的 PDF 转换后可能出现格式问题，可以手动调整 Word 文档的样式。</p></li><li><p><strong>处理速度慢</strong>：大型 PDF 文件处理需要较长时间，请耐心等待，工具正在后台工作。</p></li></ol><p>总结与展望</p><p>通过本文介绍的方法，我们成功构建了一个功能完善的 PDF 水印去除工具，实现了从单文件处理到批量转换的完整解决方案。该工具能够精准去除水印，保留原文档的文本格式和图片内容，大大提高了文档处理效率。</p><p>未来，我们可以从以下几个方面进一步优化这个工具：</p><ul><li><p>增加对更多水印类型的支持，如图片水印、倾斜文字水印等</p></li><li><p>优化 OCR 功能，提高扫描版 PDF 的处理效果</p></li><li><p>增加自定义水印规则的功能，允许用户手动标记水印特征</p></li><li><p>支持更多输出格式，如 Markdown、HTML 等</p></li><li><p>开发云同步功能，实现跨设备使用</p></li></ul><p>完整代码实现</p><p>以下是完整的 PDF 水印去除工具代码，包含所有功能模块和界面实现：</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line">import sys</span><br><span class="line">import tempfile</span><br><span class="line">from typing import List, Dict, Any, Tuple, Optional</span><br><span class="line">from collections import Counter</span><br><span class="line">from PyQt5.QtWidgets import (QApplication, QWidget, QVBoxLayout, QHBoxLayout,</span><br><span class="line">                          QPushButton, QLabel, QFileDialog, QProgressBar,</span><br><span class="line">                          QMessageBox, QCheckBox, QFrame)</span><br><span class="line">from PyQt5.QtCore import Qt, QThread, pyqtSignal</span><br><span class="line">from PyQt5.QtGui import QFont</span><br><span class="line">import fitz  # PyMuPDF</span><br><span class="line">from docx import Document</span><br><span class="line">from docx.shared import Pt, Inches</span><br><span class="line">from docx.oxml.ns import qn</span><br><span class="line">from docx.enum.text import WD_ALIGN_PARAGRAPH</span><br><span class="line">from PIL import Image</span><br><span class="line"></span><br><span class="line"># 全局临时目录，用于存储提取的图片</span><br><span class="line">GLOBAL_TEMP_DIR = os.path.join(tempfile.gettempdir(), &quot;pdf_watermark_remover&quot;)</span><br><span class="line">os.makedirs(GLOBAL_TEMP_DIR, exist_ok=True)</span><br><span class="line"></span><br><span class="line">class PDFProcessor:</span><br><span class="line">   &quot;&quot;&quot;PDF处理核心类，负责提取内容、去除水印和生成Word文档&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">   @staticmethod</span><br><span class="line">   def extract_full_pdf_info(pdf_path: str) -&gt; List[Dict[str, Any]]:</span><br><span class="line">       &quot;&quot;&quot;提取PDF中的文本、图片和格式信息&quot;&quot;&quot;</span><br><span class="line">       if not os.path.exists(pdf_path):</span><br><span class="line">           raise FileNotFoundError(f&quot;PDF文件未找到: &#123;pdf_path&#125;&quot;)</span><br><span class="line"></span><br><span class="line">       doc = fitz.open(pdf_path)</span><br><span class="line">       full_info = []</span><br><span class="line">       temp_image_dir = os.path.join(GLOBAL_TEMP_DIR, os.path.basename(pdf_path).replace(&#x27;.pdf&#x27;, &#x27;&#x27;))</span><br><span class="line">       os.makedirs(temp_image_dir, exist_ok=True)</span><br><span class="line"></span><br><span class="line">       for page_num in range(len(doc)):</span><br><span class="line">           page = doc[page_num]</span><br><span class="line">           page_data = &#123;</span><br><span class="line">               &quot;page_number&quot;: page_num + 1,</span><br><span class="line">               &quot;page_size&quot;: &#123;&quot;width&quot;: page.rect.width, &quot;height&quot;: page.rect.height&#125;,</span><br><span class="line">               &quot;rotation&quot;: page.rotation,</span><br><span class="line">               &quot;text_content&quot;: [],</span><br><span class="line">               &quot;images&quot;: []</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           # 提取文本内容</span><br><span class="line">           text_blocks = page.get_text(&quot;dict&quot;)[&quot;blocks&quot;]</span><br><span class="line">           for block in text_blocks:</span><br><span class="line">               if block[&quot;type&quot;] == 0:  # 文本块</span><br><span class="line">                   text_block_data = &#123;</span><br><span class="line">                       &quot;bbox&quot;: block[&quot;bbox&quot;],</span><br><span class="line">                       &quot;lines&quot;: []</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   for line in block[&quot;lines&quot;]:</span><br><span class="line">                       line_data = &#123;</span><br><span class="line">                           &quot;spans&quot;: [],</span><br><span class="line">                           &quot;bbox&quot;: line[&quot;bbox&quot;]</span><br><span class="line">                       &#125;</span><br><span class="line"></span><br><span class="line">                       for span in line[&quot;spans&quot;]:</span><br><span class="line">                           span_data = &#123;</span><br><span class="line">                               &quot;text&quot;: span[&quot;text&quot;],</span><br><span class="line">                               &quot;font&quot;: span[&quot;font&quot;],</span><br><span class="line">                               &quot;size&quot;: span[&quot;size&quot;],</span><br><span class="line">                               &quot;color&quot;: span[&quot;color&quot;],</span><br><span class="line">                               &quot;flags&quot;: span[&quot;flags&quot;],</span><br><span class="line">                               &quot;bbox&quot;: span[&quot;bbox&quot;]</span><br><span class="line">                           &#125;</span><br><span class="line">                           line_data[&quot;spans&quot;].append(span_data)</span><br><span class="line"></span><br><span class="line">                       text_block_data[&quot;lines&quot;].append(line_data)</span><br><span class="line"></span><br><span class="line">                   page_data[&quot;text_content&quot;].append(text_block_data)</span><br><span class="line"></span><br><span class="line">           # 提取图片</span><br><span class="line">           images = page.get_images(full=True)</span><br><span class="line">           for img_index, img in enumerate(images):</span><br><span class="line">               xref = img[0]</span><br><span class="line">               base_image = doc.extract_image(xref)</span><br><span class="line">               image_bytes = base_image[&quot;image&quot;]</span><br><span class="line">               image_ext = base_image[&quot;ext&quot;]</span><br><span class="line">               image_width = base_image[&quot;width&quot;]</span><br><span class="line">               image_height = base_image[&quot;height&quot;]</span><br><span class="line"></span><br><span class="line">               # 构建图片路径</span><br><span class="line">               img_filename = f&quot;page_&#123;page_num+1&#125;_img_&#123;img_index&#125;.&#123;image_ext&#125;&quot;</span><br><span class="line">               img_path = os.path.join(temp_image_dir, img_filename)</span><br><span class="line"></span><br><span class="line">               # 保存图片</span><br><span class="line">               with open(img_path, &quot;wb&quot;) as f:</span><br><span class="line">                   f.write(image_bytes)</span><br><span class="line"></span><br><span class="line">               # 处理软掩码（透明度）</span><br><span class="line">               if base_image[&quot;smask&quot;]:</span><br><span class="line">                   smask_image = doc.extract_image(base_image[&quot;smask&quot;])</span><br><span class="line">                   smask_bytes = smask_image[&quot;image&quot;]</span><br><span class="line">                   smask_path = os.path.join(temp_image_dir, f&quot;page_&#123;page_num+1&#125;_img_&#123;img_index&#125;_mask.&#123;image_ext&#125;&quot;)</span><br><span class="line"></span><br><span class="line">                   with open(smask_path, &quot;wb&quot;) as f:</span><br><span class="line">                       f.write(smask_bytes)</span><br><span class="line"></span><br><span class="line">                   # 合并图片和掩码</span><br><span class="line">                   img_path = PDFProcessor.merge_image_with_mask(img_path, smask_path)</span><br><span class="line">                   os.remove(smask_path)  # 清理临时掩码文件</span><br><span class="line"></span><br><span class="line">               # 转换图片格式为PNG以确保兼容性</span><br><span class="line">               if image_ext.lower() != &#x27;png&#x27;:</span><br><span class="line">                   img_path = PDFProcessor.convert_image_format(img_path, &#x27;png&#x27;)</span><br><span class="line"></span><br><span class="line">               # 获取图片在页面中的位置</span><br><span class="line">               img_rect = page.get_image_rects(xref)[0]</span><br><span class="line"></span><br><span class="line">               page_data[&quot;images&quot;].append(&#123;</span><br><span class="line">                   &quot;path&quot;: img_path,</span><br><span class="line">                   &quot;ext&quot;: image_ext,</span><br><span class="line">                   &quot;width&quot;: image_width,</span><br><span class="line">                   &quot;height&quot;: image_height,</span><br><span class="line">                   &quot;rect&quot;: img_rect,</span><br><span class="line">                   &quot;index&quot;: img_index</span><br><span class="line">               &#125;)</span><br><span class="line"></span><br><span class="line">           full_info.append(page_data)</span><br><span class="line"></span><br><span class="line">       doc.close()</span><br><span class="line">       return full_info</span><br><span class="line"></span><br><span class="line">   @staticmethod</span><br><span class="line">   def merge_image_with_mask(image_path: str, mask_path: str) -&gt; str:</span><br><span class="line">       &quot;&quot;&quot;合并图片和掩码以保留透明度&quot;&quot;&quot;</span><br><span class="line">       try:</span><br><span class="line">           with Image.open(image_path) as img, Image.open(mask_path) as mask:</span><br><span class="line">               # 确保图片和掩码尺寸一致</span><br><span class="line">               if img.size != mask.size:</span><br><span class="line">                   mask = mask.resize(img.size)</span><br><span class="line"></span><br><span class="line">               # 合并图片和掩码</span><br><span class="line">               img.putalpha(mask)</span><br><span class="line">               new_path = os.path.splitext(image_path)[0] + &#x27;_merged.png&#x27;</span><br><span class="line">               img.save(new_path, &#x27;PNG&#x27;)</span><br><span class="line">               os.remove(image_path)  # 移除原始图片</span><br><span class="line">               return new_path</span><br><span class="line">       except Exception as e:</span><br><span class="line">           print(f&quot;合并图片和掩码失败: &#123;e&#125;&quot;)</span><br><span class="line">           return image_path  # 失败时返回原始图片路径</span><br><span class="line"></span><br><span class="line">   @staticmethod</span><br><span class="line">   def convert_image_format(temp_path: str, target_format: str = &#x27;png&#x27;) -&gt; str:</span><br><span class="line">       &quot;&quot;&quot;转换图片格式&quot;&quot;&quot;</span><br><span class="line">       try:</span><br><span class="line">           with Image.open(temp_path) as img:</span><br><span class="line">               original_mode = img.mode</span><br><span class="line">               new_path = os.path.splitext(temp_path)[0] + f&#x27;.&#123;target_format&#125;&#x27;</span><br><span class="line"></span><br><span class="line">               # 处理透明图片</span><br><span class="line">               if &#x27;A&#x27; in original_mode:</span><br><span class="line">                   if original_mode != &#x27;RGBA&#x27;:</span><br><span class="line">                       img = img.convert(&#x27;RGBA&#x27;)</span><br><span class="line">                   img.save(new_path, format=target_format.upper())</span><br><span class="line">               else:</span><br><span class="line">                   # 非透明图片直接转换</span><br><span class="line">                   img.save(new_path, format=target_format.upper())</span><br><span class="line"></span><br><span class="line">               os.remove(temp_path)  # 移除原始格式图片</span><br><span class="line">               return new_path</span><br><span class="line">       except Exception as e:</span><br><span class="line">           print(f&quot;转换图片格式失败: &#123;e&#125;&quot;)</span><br><span class="line">           return temp_path  # 失败时返回原始路径</span><br><span class="line"></span><br><span class="line">   @staticmethod</span><br><span class="line">   def remove_watermark_by_alpha(full_info: List[Dict[str, Any]]) -&gt; List[Dict[str, Any]]:</span><br><span class="line">       &quot;&quot;&quot;通过透明度、字体大小和颜色识别并去除水印&quot;&quot;&quot;</span><br><span class="line">       clean_full_info = []</span><br><span class="line">       watermark_removed_count = 0</span><br><span class="line"></span><br><span class="line">       # 水印特征参数</span><br><span class="line">       ALPHA_THRESHOLD = 150  # 透明度阈值</span><br><span class="line">       TARGET_FONT_SIZE = 18  # 水印字体大小</span><br><span class="line">       FONT_SIZE_TOLERANCE = 1  # 字体大小容差</span><br><span class="line">       TARGET_COLOR_INT_VALUE = 13882323  # 水印颜色值</span><br><span class="line"></span><br><span class="line">       for page in full_info:</span><br><span class="line">           clean_text_blocks = []</span><br><span class="line"></span><br><span class="line">           for text_block in page[&quot;text_content&quot;]:</span><br><span class="line">               clean_lines = []</span><br><span class="line"></span><br><span class="line">               for line in text_block[&quot;lines&quot;]:</span><br><span class="line">                   clean_spans = []</span><br><span class="line"></span><br><span class="line">                   for span in line[&quot;spans&quot;]:</span><br><span class="line">                       # 检查是否为水印文本</span><br><span class="line">                       is_watermark = False</span><br><span class="line"></span><br><span class="line">                       # 检查字体大小</span><br><span class="line">                       size_diff = abs(span[&quot;size&quot;] - TARGET_FONT_SIZE)</span><br><span class="line">                       if size_diff &lt;= FONT_SIZE_TOLERANCE:</span><br><span class="line">                           # 检查颜色</span><br><span class="line">                           if span[&quot;color&quot;] == TARGET_COLOR_INT_VALUE:</span><br><span class="line">                               # 检查透明度（通过flags判断）</span><br><span class="line">                               # flags的第3位表示透明度</span><br><span class="line">                               if (span[&quot;flags&quot;] &amp; 0b100) != 0:</span><br><span class="line">                                   is_watermark = True</span><br><span class="line"></span><br><span class="line">                       if not is_watermark:</span><br><span class="line">                           clean_spans.append(span)</span><br><span class="line">                       else:</span><br><span class="line">                           watermark_removed_count += 1</span><br><span class="line"></span><br><span class="line">                   if clean_spans:  # 只保留有内容的行</span><br><span class="line">                       clean_line = &#123;**line, &quot;spans&quot;: clean_spans&#125;</span><br><span class="line">                       clean_lines.append(clean_line)</span><br><span class="line"></span><br><span class="line">               if clean_lines:  # 只保留有内容的文本块</span><br><span class="line">                   clean_block = &#123;** text_block, &quot;lines&quot;: clean_lines&#125;</span><br><span class="line">                   clean_text_blocks.append(clean_block)</span><br><span class="line"></span><br><span class="line">           # 保留图片信息</span><br><span class="line">           clean_page = &#123;**page, &quot;text_content&quot;: clean_text_blocks, &quot;images&quot;: page[&quot;images&quot;]&#125;</span><br><span class="line">           clean_full_info.append(clean_page)</span><br><span class="line"></span><br><span class="line">       print(f&quot;水印移除完成。共移除 &#123;watermark_removed_count&#125; 处水印文本。&quot;)</span><br><span class="line">       return clean_full_info</span><br><span class="line"></span><br><span class="line">   @staticmethod</span><br><span class="line">   def get_system_font_mapping() -&gt; Dict[str, str]:</span><br><span class="line">       &quot;&quot;&quot;获取系统字体映射表，用于PDF到Word的字体转换&quot;&quot;&quot;</span><br><span class="line">       return &#123;</span><br><span class="line">           &quot;SimSun&quot;: &quot;宋体&quot;,</span><br><span class="line">           &quot;SimHei&quot;: &quot;黑体&quot;,</span><br><span class="line">           &quot;Microsoft YaHei&quot;: &quot;微软雅黑&quot;,</span><br><span class="line">           &quot;KaiTi&quot;: &quot;楷体&quot;,</span><br><span class="line">           &quot;FangSong&quot;: &quot;仿宋&quot;,</span><br><span class="line">           &quot;Arial&quot;: &quot;Arial&quot;,</span><br><span class="line">           &quot;Times New Roman&quot;: &quot;Times New Roman&quot;,</span><br><span class="line">           # 可以根据需要添加更多字体映射</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   @staticmethod</span><br><span class="line">   def generate_word_from_data(clean_info: List[Dict[str, Any]], output_word_path: str) -&gt; None:</span><br><span class="line">       &quot;&quot;&quot;从清理后的PDF信息生成Word文档&quot;&quot;&quot;</span><br><span class="line">       doc = Document()</span><br><span class="line">       font_mapping = PDFProcessor.get_system_font_mapping()</span><br><span class="line"></span><br><span class="line">       # 收集所有字体大小用于分析</span><br><span class="line">       all_font_sizes = []</span><br><span class="line">       for page in clean_info:</span><br><span class="line">           for block in page[&quot;text_content&quot;]:</span><br><span class="line">               for line in block[&quot;lines&quot;]:</span><br><span class="line">                   for span in line[&quot;spans&quot;]:</span><br><span class="line">                       all_font_sizes.append(span[&quot;size&quot;])</span><br><span class="line"></span><br><span class="line">       # 分析最常见的字体大小作为正文字体</span><br><span class="line">       if all_font_sizes:</span><br><span class="line">           most_common_size = Counter(all_font_sizes).most_common(1)[0][0]</span><br><span class="line">           print(f&quot;分析得出正文字体大小: &#123;most_common_size&#125;&quot;)</span><br><span class="line">           title_font_threshold = most_common_size * 1.2  # 标题字体阈值</span><br><span class="line">       else:</span><br><span class="line">           most_common_size = 12  # 默认正文字体大小</span><br><span class="line">           title_font_threshold = 14  # 默认标题字体阈值</span><br><span class="line"></span><br><span class="line">       # 处理每一页内容</span><br><span class="line">       for page in clean_info:</span><br><span class="line">           # 为新页面添加分页符（第一页除外）</span><br><span class="line">           if page[&quot;page_number&quot;] &gt; 1:</span><br><span class="line">               doc.add_page_break()</span><br><span class="line"></span><br><span class="line">           # 添加页码</span><br><span class="line">           page_paragraph = doc.add_paragraph()</span><br><span class="line">           page_run = page_paragraph.add_run(f&quot;第 &#123;page[&#x27;page_number&#x27;]&#125; 页&quot;)</span><br><span class="line">           page_run.font.size = Pt(9)</span><br><span class="line">           page_paragraph.alignment = WD_ALIGN_PARAGRAPH.CENTER</span><br><span class="line"></span><br><span class="line">           # 收集页面上的所有元素（文本块和图片）并按位置排序</span><br><span class="line">           page_elements = []</span><br><span class="line"></span><br><span class="line">           # 添加文本块</span><br><span class="line">           for block in page[&quot;text_content&quot;]:</span><br><span class="line">               # 使用文本块的边界框顶部作为排序依据</span><br><span class="line">               block_top = block[&quot;bbox&quot;][1]</span><br><span class="line">               page_elements.append(&#123;</span><br><span class="line">                   &quot;type&quot;: &quot;text&quot;,</span><br><span class="line">                   &quot;top&quot;: block_top,</span><br><span class="line">                   &quot;data&quot;: block</span><br><span class="line">               &#125;)</span><br><span class="line"></span><br><span class="line">           # 添加图片</span><br><span class="line">           for img in page[&quot;images&quot;]:</span><br><span class="line">               # 使用图片的顶部位置作为排序依据</span><br><span class="line">               img_top = img[&quot;rect&quot;][1]</span><br><span class="line">               page_elements.append(&#123;</span><br><span class="line">                   &quot;type&quot;: &quot;image&quot;,</span><br><span class="line">                   &quot;top&quot;: img_top,</span><br><span class="line">                   &quot;data&quot;: img</span><br><span class="line">               &#125;)</span><br><span class="line"></span><br><span class="line">           # 按元素在页面中的垂直位置排序</span><br><span class="line">           page_elements.sort(key=lambda x: x[&quot;top&quot;])</span><br><span class="line"></span><br><span class="line">           # 处理排序后的元素</span><br><span class="line">           for element in page_elements:</span><br><span class="line">               if element[&quot;type&quot;] == &quot;text&quot;:</span><br><span class="line">                   PDFProcessor._add_text_block_to_doc(doc, element[&quot;data&quot;], font_mapping,</span><br><span class="line">                                                     title_font_threshold, most_common_size)</span><br><span class="line">               elif element[&quot;type&quot;] == &quot;image&quot;:</span><br><span class="line">                   PDFProcessor._add_image_to_doc(doc, element[&quot;data&quot;])</span><br><span class="line"></span><br><span class="line">       # 保存生成的Word文档</span><br><span class="line">       try:</span><br><span class="line">           # 确保输出目录存在</span><br><span class="line">           output_dir = os.path.dirname(output_word_path)</span><br><span class="line">           os.makedirs(output_dir, exist_ok=True)</span><br><span class="line"></span><br><span class="line">           doc.save(output_word_path)</span><br><span class="line">           print(f&quot;Word文档已保存至：&#123;output_word_path&#125;&quot;)</span><br><span class="line">       except Exception as e:</span><br><span class="line">           print(f&quot;保存Word文档失败：&#123;e&#125;&quot;)</span><br><span class="line">           raise</span><br><span class="line"></span><br><span class="line">   @staticmethod</span><br><span class="line">   def _add_text_block_to_doc(doc, text_block, font_mapping, title_threshold, normal_size):</span><br><span class="line">       &quot;&quot;&quot;将文本块添加到Word文档&quot;&quot;&quot;</span><br><span class="line">       for line in text_block[&quot;lines&quot;]:</span><br><span class="line">           paragraph = doc.add_paragraph()</span><br><span class="line"></span><br><span class="line">           for span in line[&quot;spans&quot;]:</span><br><span class="line">               run = paragraph.add_run(span[&quot;text&quot;])</span><br><span class="line"></span><br><span class="line">               # 设置字体</span><br><span class="line">               font_name = span[&quot;font&quot;]</span><br><span class="line">               # 映射到系统可用字体</span><br><span class="line">               mapped_font = font_mapping.get(font_name, font_name)</span><br><span class="line">               try:</span><br><span class="line">                   run.font.name = mapped_font</span><br><span class="line">                   # 设置中文字体</span><br><span class="line">                   run._element.rPr.rFonts.set(qn(&#x27;w:eastAsia&#x27;), mapped_font)</span><br><span class="line">               except Exception as e:</span><br><span class="line">                   print(f&quot;设置字体 &#123;mapped_font&#125; 失败: &#123;e&#125;&quot;)</span><br><span class="line">                   run.font.name = &quot;宋体&quot;</span><br><span class="line">                   run._element.rPr.rFonts.set(qn(&#x27;w:eastAsia&#x27;), &quot;宋体&quot;)</span><br><span class="line"></span><br><span class="line">               # 设置字体大小</span><br><span class="line">               try:</span><br><span class="line">                   run.font.size = Pt(span[&quot;size&quot;])</span><br><span class="line">               except:</span><br><span class="line">                   run.font.size = Pt(normal_size)</span><br><span class="line"></span><br><span class="line">               # 设置字体颜色（简化处理，仅使用黑白两色）</span><br><span class="line">               if span[&quot;color&quot;] in (0, 255):  # 黑色或白色</span><br><span class="line">                   run.font.color.rgb = None  # 使用默认颜色</span><br><span class="line">               else:</span><br><span class="line">                   # 转换PDF颜色值（整数）为RGB</span><br><span class="line">                   rgb = PDFProcessor._int_to_rgb(span[&quot;color&quot;])</span><br><span class="line">                   run.font.color.rgb = rgb</span><br><span class="line"></span><br><span class="line">           # 根据字体大小判断是否为标题</span><br><span class="line">           if line[&quot;spans&quot;]:</span><br><span class="line">               first_span_size = line[&quot;spans&quot;][0][&quot;size&quot;]</span><br><span class="line">               if first_span_size &gt;= title_threshold:</span><br><span class="line">                   paragraph.style = doc.styles[&quot;Heading 2&quot;]</span><br><span class="line">               else:</span><br><span class="line">                   paragraph.style = doc.styles[&quot;Normal&quot;]</span><br><span class="line"></span><br><span class="line">   @staticmethod</span><br><span class="line">   def _add_image_to_doc(doc, img_data):</span><br><span class="line">       &quot;&quot;&quot;将图片添加到Word文档&quot;&quot;&quot;</span><br><span class="line">       try:</span><br><span class="line">           if os.path.exists(img_data[&quot;path&quot;]):</span><br><span class="line">               # 计算图片在Word中的尺寸（英寸）</span><br><span class="line">               # 72像素 = 1英寸</span><br><span class="line">               width_in_inches = img_data[&quot;width&quot;] / 72</span><br><span class="line">               height_in_inches = img_data[&quot;height&quot;] / 72</span><br><span class="line"></span><br><span class="line">               # 限制最大宽度为6英寸，保持比例</span><br><span class="line">               if width_in_inches &gt; 6:</span><br><span class="line">                   ratio = 6 / width_in_inches</span><br><span class="line">                   width_in_inches = 6</span><br><span class="line">                   height_in_inches *= ratio</span><br><span class="line"></span><br><span class="line">               # 添加图片</span><br><span class="line">               paragraph = doc.add_paragraph()</span><br><span class="line">               run = paragraph.add_run()</span><br><span class="line">               run.add_picture(img_data[&quot;path&quot;], width=Inches(width_in_inches),</span><br><span class="line">                              height=Inches(height_in_inches))</span><br><span class="line">               paragraph.alignment = WD_ALIGN_PARAGRAPH.CENTER  # 图片居中对齐</span><br><span class="line">       except Exception as e:</span><br><span class="line">           print(f&quot;添加图片到文档失败: &#123;e&#125;&quot;)</span><br><span class="line"></span><br><span class="line">   @staticmethod</span><br><span class="line">   def _int_to_rgb(color_int: int) -&gt; Tuple[int, int, int]:</span><br><span class="line">       &quot;&quot;&quot;将整数颜色值转换为RGB tuple&quot;&quot;&quot;</span><br><span class="line">       blue = color_int &amp; 0xff</span><br><span class="line">       green = (color_int &gt;&gt; 8) &amp; 0xff</span><br><span class="line">       red = (color_int &gt;&gt; 16) &amp; 0xff</span><br><span class="line">       return (red, green, blue)</span><br><span class="line"></span><br><span class="line">class ProcessingThread(QThread):</span><br><span class="line">   &quot;&quot;&quot;处理PDF文件的工作线程&quot;&quot;&quot;</span><br><span class="line">   finished = pyqtSignal(bool, str, str)  # 处理完成信号 (成功, 原文件路径, 结果文件路径)</span><br><span class="line">   progress_updated = pyqtSignal(str)  # 进度更新信号</span><br><span class="line"></span><br><span class="line">   def __init__(self, pdf_path: str, output_path: str):</span><br><span class="line">       super().__init__()</span><br><span class="line">       self.pdf_path = pdf_path</span><br><span class="line">       self.output_path = output_path</span><br><span class="line"></span><br><span class="line">   def run(self):</span><br><span class="line">       try:</span><br><span class="line">           self.progress_updated.emit(f&quot;正在提取PDF内容: &#123;os.path.basename(self.pdf_path)&#125;&quot;)</span><br><span class="line"></span><br><span class="line">           # 提取PDF信息</span><br><span class="line">           pdf_info = PDFProcessor.extract_full_pdf_info(self.pdf_path)</span><br><span class="line"></span><br><span class="line">           self.progress_updated.emit(f&quot;正在去除水印: &#123;os.path.basename(self.pdf_path)&#125;&quot;)</span><br><span class="line"></span><br><span class="line">           # 去除水印</span><br><span class="line">           clean_info = PDFProcessor.remove_watermark_by_alpha(pdf_info)</span><br><span class="line"></span><br><span class="line">           self.progress_updated.emit(f&quot;正在生成Word文档: &#123;os.path.basename(self.output_path)&#125;&quot;)</span><br><span class="line"></span><br><span class="line">           # 生成Word文档</span><br><span class="line">           PDFProcessor.generate_word_from_data(clean_info, self.output_path)</span><br><span class="line"></span><br><span class="line">           self.finished.emit(True, self.pdf_path, self.output_path)</span><br><span class="line">       except Exception as e:</span><br><span class="line">           error_msg = f&quot;处理失败: &#123;str(e)&#125;&quot;</span><br><span class="line">           print(error_msg)</span><br><span class="line">           self.progress_updated.emit(error_msg)</span><br><span class="line">           self.finished.emit(False, self.pdf_path, str(e))</span><br><span class="line"></span><br><span class="line">class PdfWatermarkRemoverApp(QWidget):</span><br><span class="line">   &quot;&quot;&quot;PDF水印去除工具主界面&quot;&quot;&quot;</span><br><span class="line">   def __init__(self):</span><br><span class="line">       super().__init__()</span><br><span class="line">       self.processing_queue = []  # 待处理文件队列</span><br><span class="line">       self.processed_count = 0  # 已处理文件数</span><br><span class="line">       self.total_files_to_process = 0  # 总文件数</span><br><span class="line">       self.success_count = 0  # 处理成功数</span><br><span class="line">       self.failure_count = 0  # 处理失败数</span><br><span class="line">       self.failed_files = []  # 处理失败的文件列表</span><br><span class="line">       self.processing_mode = None  # &#x27;file&#x27; 或 &#x27;folder&#x27;</span><br><span class="line">       self.overwrite_all = None  # None:未设置, True:全部覆盖, False:全部跳过</span><br><span class="line">       self.init_ui()</span><br><span class="line"></span><br><span class="line">   def init_ui(self):</span><br><span class="line">       &quot;&quot;&quot;初始化用户界面&quot;&quot;&quot;</span><br><span class="line">       self.setWindowTitle(&quot;PDF水印去除工具&quot;)</span><br><span class="line">       self.setFixedSize(750, 400)</span><br><span class="line"></span><br><span class="line">       # 设置中文字体</span><br><span class="line">       font = QFont()</span><br><span class="line">       font.setFamily(&quot;SimHei&quot;)</span><br><span class="line">       self.setFont(font)</span><br><span class="line"></span><br><span class="line">       main_layout = QVBoxLayout()</span><br><span class="line">       main_layout.setSpacing(15)</span><br><span class="line">       main_layout.setContentsMargins(20, 20, 20, 20)</span><br><span class="line"></span><br><span class="line">       # 标题</span><br><span class="line">       title_label = QLabel(&quot;PDF水印去除与Word转换工具&quot;)</span><br><span class="line">       title_font = QFont()</span><br><span class="line">       title_font.setFamily(&quot;SimHei&quot;)</span><br><span class="line">       title_font.setPointSize(14)</span><br><span class="line">       title_font.setBold(True)</span><br><span class="line">       title_label.setFont(title_font)</span><br><span class="line">       title_label.setAlignment(Qt.AlignCenter)</span><br><span class="line">       main_layout.addWidget(title_label)</span><br><span class="line"></span><br><span class="line">       # 分隔线</span><br><span class="line">       line = QFrame()</span><br><span class="line">       line.setFrameShape(QFrame.HLine)</span><br><span class="line">       line.setFrameShadow(QFrame.Sunken)</span><br><span class="line">       main_layout.addWidget(line)</span><br><span class="line"></span><br><span class="line">       # 文件选择区域</span><br><span class="line">       file_selection_layout = QVBoxLayout()</span><br><span class="line"></span><br><span class="line">       # 选择文件按钮</span><br><span class="line">       self.browse_files_button = QPushButton(&quot;选择文件...&quot;)</span><br><span class="line">       self.browse_files_button.setFont(font)</span><br><span class="line">       self.browse_files_button.clicked.connect(self.browse_pdf_files)</span><br><span class="line">       file_selection_layout.addWidget(self.browse_files_button)</span><br><span class="line"></span><br><span class="line">       # 选择文件夹按钮</span><br><span class="line">       self.browse_folder_button = QPushButton(&quot;选择文件夹...&quot;)</span><br><span class="line">       self.browse_folder_button.setFont(font)</span><br><span class="line">       self.browse_folder_button.clicked.connect(self.browse_folder)</span><br><span class="line">       file_selection_layout.addWidget(self.browse_folder_button)</span><br><span class="line"></span><br><span class="line">       # 选中的文件/文件夹显示</span><br><span class="line">       self.selected_path_label = QLabel(&quot;未选择任何文件或文件夹&quot;)</span><br><span class="line">       self.selected_path_label.setFont(font)</span><br><span class="line">       self.selected_path_label.setWordWrap(True)</span><br><span class="line">       file_selection_layout.addWidget(self.selected_path_label)</span><br><span class="line"></span><br><span class="line">       main_layout.addLayout(file_selection_layout)</span><br><span class="line"></span><br><span class="line">       # 处理按钮</span><br><span class="line">       self.process_button = QPushButton(&quot;开始处理&quot;)</span><br><span class="line">       self.process_button.setFont(font)</span><br><span class="line">       self.process_button.setMinimumHeight(40)</span><br><span class="line">       self.process_button.clicked.connect(self.start_processing)</span><br><span class="line">       self.process_button.setEnabled(False)  # 初始禁用</span><br><span class="line">       main_layout.addWidget(self.process_button)</span><br><span class="line"></span><br><span class="line">       # 进度显示区域</span><br><span class="line">       progress_layout = QVBoxLayout()</span><br><span class="line"></span><br><span class="line">       self.status_label = QLabel(&quot;等待选择文件/文件夹...&quot;)</span><br><span class="line">       self.status_label.setFont(font)</span><br><span class="line">       progress_layout.addWidget(self.status_label)</span><br><span class="line"></span><br><span class="line">       self.current_file_status_label = QLabel(&quot;&quot;)</span><br><span class="line">       self.current_file_status_label.setFont(font)</span><br><span class="line">       self.current_file_status_label.setWordWrap(True)</span><br><span class="line">       progress_layout.addWidget(self.current_file_status_label)</span><br><span class="line"></span><br><span class="line">       self.progress_bar = QProgressBar()</span><br><span class="line">       self.progress_bar.setValue(0)</span><br><span class="line">       progress_layout.addWidget(self.progress_bar)</span><br><span class="line"></span><br><span class="line">       main_layout.addLayout(progress_layout)</span><br><span class="line"></span><br><span class="line">       # 覆盖选项（默认隐藏）</span><br><span class="line">       self.overwrite_layout = QHBoxLayout()</span><br><span class="line"></span><br><span class="line">       self.overwrite_label = QLabel(&quot;文件已存在，是否覆盖？&quot;)</span><br><span class="line">       self.overwrite_label.setFont(font)</span><br><span class="line">       self.overwrite_layout.addWidget(self.overwrite_label)</span><br><span class="line"></span><br><span class="line">       self.overwrite_button = QPushButton(&quot;覆盖&quot;)</span><br><span class="line">       self.overwrite_button.setFont(font)</span><br><span class="line">       self.overwrite_button.clicked.connect(lambda: self.handle_overwrite_choice(True))</span><br><span class="line">       self.overwrite_layout.addWidget(self.overwrite_button)</span><br><span class="line"></span><br><span class="line">       self.skip_button = QPushButton(&quot;跳过&quot;)</span><br><span class="line">       self.skip_button.setFont(font)</span><br><span class="line">       self.skip_button.clicked.connect(lambda: self.handle_overwrite_choice(False))</span><br><span class="line">       self.overwrite_layout.addWidget(self.skip_button)</span><br><span class="line"></span><br><span class="line">       self.overwrite_all_checkbox = QCheckBox(&quot;对当前批次的所有冲突文件执行此操作&quot;)</span><br><span class="line">       self.overwrite_all_checkbox.setFont(font)</span><br><span class="line">       self.overwrite_all_checkbox.setVisible(False)</span><br><span class="line">       self.overwrite_layout.addWidget(self.overwrite_all_checkbox)</span><br><span class="line"></span><br><span class="line">       main_layout.addLayout(self.overwrite_layout)</span><br><span class="line">       self.overwrite_layout.setVisible(False)  # 默认隐藏</span><br><span class="line"></span><br><span class="line">       # 状态统计区域</span><br><span class="line">       self.stats_label = QLabel(&quot;处理统计: 0 成功, 0 失败&quot;)</span><br><span class="line">       self.stats_label.setFont(font)</span><br><span class="line">       main_layout.addWidget(self.stats_label)</span><br><span class="line"></span><br><span class="line">       # 底部说明</span><br><span class="line">       note_label = QLabel(&quot;说明: 处理后的文件将保存至源文件所在目录的 &#x27;_无水印&#x27; 子文件夹中&quot;)</span><br><span class="line">       note_font = QFont()</span><br><span class="line">       note_font.setFamily(&quot;SimHei&quot;)</span><br><span class="line">       note_font.setPointSize(9)</span><br><span class="line">       note_label.setFont(note_font)</span><br><span class="line">       note_label.setAlignment(Qt.AlignRight)</span><br><span class="line">       main_layout.addWidget(note_label)</span><br><span class="line"></span><br><span class="line">       self.setLayout(main_layout)</span><br><span class="line"></span><br><span class="line">   def browse_pdf_files(self):</span><br><span class="line">       &quot;&quot;&quot;浏览并选择PDF文件&quot;&quot;&quot;</span><br><span class="line">       file_paths, _ = QFileDialog.getOpenFileNames(self, &quot;选择PDF文件&quot;, &quot;&quot;, &quot;PDF文件 (*.pdf)&quot;)</span><br><span class="line">       if file_paths:</span><br><span class="line">           self.processing_mode = &quot;file&quot;</span><br><span class="line">           self.processing_queue = list(file_paths)</span><br><span class="line">           self.total_files_to_process = len(self.processing_queue)</span><br><span class="line">           self.selected_path_label.setText(f&quot;已选择 &#123;self.total_files_to_process&#125; 个PDF文件&quot;)</span><br><span class="line">           self.process_button.setEnabled(True)</span><br><span class="line">           self.reset_processing_stats()</span><br><span class="line"></span><br><span class="line">   def browse_folder(self):</span><br><span class="line">       &quot;&quot;&quot;浏览并选择文件夹&quot;&quot;&quot;</span><br><span class="line">       folder_path = QFileDialog.getExistingDirectory(self, &quot;选择包含 PDF 文件的文件夹&quot;)</span><br><span class="line">       if folder_path:</span><br><span class="line">           self.processing_mode = &quot;folder&quot;</span><br><span class="line">           # 查找文件夹中的所有PDF文件</span><br><span class="line">           pdf_files = []</span><br><span class="line">           for root, _, files in os.walk(folder_path):</span><br><span class="line">               for file in files:</span><br><span class="line">                   if file.lower().endswith(&#x27;.pdf&#x27;):</span><br><span class="line">                       pdf_files.append(os.path.join(root, file))</span><br><span class="line"></span><br><span class="line">           self.processing_queue = pdf_files</span><br><span class="line">           self.total_files_to_process = len(self.processing_queue)</span><br><span class="line">           self.selected_path_label.setText(</span><br><span class="line">               f&quot;已选择文件夹: &#123;folder_path&#125;n包含 &#123;self.total_files_to_process&#125; 个PDF文件&quot;)</span><br><span class="line">           self.process_button.setEnabled(self.total_files_to_process &gt; 0)</span><br><span class="line">           self.reset_processing_stats()</span><br><span class="line"></span><br><span class="line">   def reset_processing_stats(self):</span><br><span class="line">       &quot;&quot;&quot;重置处理统计信息&quot;&quot;&quot;</span><br><span class="line">       self.processed_count = 0</span><br><span class="line">       self.success_count = 0</span><br><span class="line">       self.failure_count = 0</span><br><span class="line">       self.failed_files = []</span><br><span class="line">       self.progress_bar.setValue(0)</span><br><span class="line">       self.stats_label.setText(&quot;处理统计: 0 成功, 0 失败&quot;)</span><br><span class="line">       self.status_label.setText(&quot;就绪，点击开始处理&quot;)</span><br><span class="line">       self.current_file_status_label.setText(&quot;&quot;)</span><br><span class="line">       self.overwrite_all = None</span><br><span class="line"></span><br><span class="line">   def start_processing(self):</span><br><span class="line">       &quot;&quot;&quot;开始处理文件队列&quot;&quot;&quot;</span><br><span class="line">       if not self.processing_queue or self.total_files_to_process == 0:</span><br><span class="line">           QMessageBox.information(self, &quot;提示&quot;, &quot;没有可处理的文件&quot;)</span><br><span class="line">           return</span><br><span class="line"></span><br><span class="line">       self.process_button.setEnabled(False)</span><br><span class="line">       self.browse_files_button.setEnabled(False)</span><br><span class="line">       self.browse_folder_button.setEnabled(False)</span><br><span class="line">       self.process_next_file()</span><br><span class="line"></span><br><span class="line">   def process_next_file(self):</span><br><span class="line">       &quot;&quot;&quot;处理队列中的下一个文件&quot;&quot;&quot;</span><br><span class="line">       if not self.processing_queue:</span><br><span class="line">           self.on_all_processing_finished()</span><br><span class="line">           return</span><br><span class="line"></span><br><span class="line">       current_pdf_path = self.processing_queue.pop(0)</span><br><span class="line">       pdf_filename = os.path.basename(current_pdf_path)</span><br><span class="line">       pdf_dir = os.path.dirname(current_pdf_path)</span><br><span class="line"></span><br><span class="line">       # 创建输出目录</span><br><span class="line">       output_dir = os.path.join(pdf_dir, pdf_filename.replace(&#x27;.pdf&#x27;, &#x27;&#x27;) + &quot;_无水印&quot;)</span><br><span class="line">       os.makedirs(output_dir, exist_ok=True)</span><br><span class="line"></span><br><span class="line">       # 构建输出文件路径</span><br><span class="line">       output_filename = os.path.splitext(pdf_filename)[0] + &quot;_无水印.docx&quot;</span><br><span class="line">       output_word_path = os.path.join(output_dir, output_filename)</span><br><span class="line"></span><br><span class="line">       # 检查文件是否已存在</span><br><span class="line">       if os.path.exists(output_word_path):</span><br><span class="line">           # 如果已设置全局覆盖策略，则直接应用</span><br><span class="line">           if self.overwrite_all is not None:</span><br><span class="line">               if not self.overwrite_all:</span><br><span class="line">                   # 跳过此文件</span><br><span class="line">                   self.current_file_status_label.setText(f&quot;已跳过已存在文件: &#123;pdf_filename&#125;&quot;)</span><br><span class="line">                   self.processed_count += 1</span><br><span class="line">                   self.update_progress()</span><br><span class="line">                   QApplication.processEvents()  # 更新界面</span><br><span class="line">                   self.process_next_file()</span><br><span class="line">                   return</span><br><span class="line">           else:</span><br><span class="line">               # 显示覆盖选择对话框</span><br><span class="line">               self.current_file_path = current_pdf_path</span><br><span class="line">               self.current_output_path = output_word_path</span><br><span class="line">               self.status_label.setText(f&quot;文件已存在: &#123;pdf_filename&#125;&quot;)</span><br><span class="line">               self.current_file_status_label.setText(&quot;请选择处理方式&quot;)</span><br><span class="line">               self.overwrite_layout.setVisible(True)</span><br><span class="line">               self.overwrite_all_checkbox.setVisible(True)</span><br><span class="line">               return</span><br><span class="line"></span><br><span class="line">       # 启动处理线程</span><br><span class="line">       self.status_label.setText(f&quot;正在处理第 &#123;self.processed_count + 1&#125; / &#123;self.total_files_to_process&#125; 个文件...&quot;)</span><br><span class="line">       self.current_file_status_label.setText(f&quot;正在处理: &#123;pdf_filename&#125;&quot;)</span><br><span class="line"></span><br><span class="line">       self.processing_thread = ProcessingThread(current_pdf_path, output_word_path)</span><br><span class="line">       self.processing_thread.finished.connect(self.on_file_processed)</span><br><span class="line">       self.processing_thread.progress_updated.connect(self.current_file_status_label.setText)</span><br><span class="line">       self.processing_thread.start()</span><br><span class="line"></span><br><span class="line">   def handle_overwrite_choice(self, overwrite: bool):</span><br><span class="line">       &quot;&quot;&quot;处理文件覆盖选择&quot;&quot;&quot;</span><br><span class="line">       self.overwrite_layout.setVisible(False)</span><br><span class="line"></span><br><span class="line">       # 检查是否需要应用到所有文件</span><br><span class="line">       if self.overwrite_all_checkbox.isChecked():</span><br><span class="line">           self.overwrite_all = overwrite</span><br><span class="line"></span><br><span class="line">       if overwrite:</span><br><span class="line">           # 继续处理当前文件，覆盖已存在文件</span><br><span class="line">           self.processing_thread = ProcessingThread(self.current_file_path, self.current_output_path)</span><br><span class="line">           self.processing_thread.finished.connect(self.on_file_processed)</span><br><span class="line">           self.processing_thread.progress_updated.connect(self.current_file_status_label.setText)</span><br><span class="line">           self.processing_thread.start()</span><br><span class="line">       else:</span><br><span class="line">           # 跳过当前文件</span><br><span class="line">           self.current_file_status_label.setText(f&quot;已跳过已存在文件: &#123;os.path.basename(self.current_file_path)&#125;&quot;)</span><br><span class="line">           self.processed_count += 1</span><br><span class="line">           self.update_progress()</span><br><span class="line">           self.process_next_file()</span><br><span class="line"></span><br><span class="line">   def on_file_processed(self, success: bool, file_path: str, result: str):</span><br><span class="line">       &quot;&quot;&quot;文件处理完成回调&quot;&quot;&quot;</span><br><span class="line">       filename = os.path.basename(file_path)</span><br><span class="line"></span><br><span class="line">       if success:</span><br><span class="line">           self.success_count += 1</span><br><span class="line">           self.current_file_status_label.setText(f&quot;处理成功: &#123;filename&#125; -&gt; &#123;os.path.basename(result)&#125;&quot;)</span><br><span class="line">       else:</span><br><span class="line">           self.failure_count += 1</span><br><span class="line">           self.failed_files.append(f&quot;&#123;filename&#125;: &#123;result&#125;&quot;)</span><br><span class="line">           self.current_file_status_label.setText(f&quot;处理失败: &#123;filename&#125; - &#123;result&#125;&quot;)</span><br><span class="line"></span><br><span class="line">       self.processed_count += 1</span><br><span class="line">       self.update_progress()</span><br><span class="line">       self.process_next_file()</span><br><span class="line"></span><br><span class="line">   def update_progress(self):</span><br><span class="line">       &quot;&quot;&quot;更新进度显示&quot;&quot;&quot;</span><br><span class="line">       progress_percentage = int((self.processed_count / self.total_files_to_process) * 100)</span><br><span class="line">       self.progress_bar.setValue(progress_percentage)</span><br><span class="line">       self.stats_label.setText(f&quot;处理统计: &#123;self.success_count&#125; 成功, &#123;self.failure_count&#125; 失败&quot;)</span><br><span class="line"></span><br><span class="line">   def on_all_processing_finished(self):</span><br><span class="line">       &quot;&quot;&quot;所有文件处理完成&quot;&quot;&quot;</span><br><span class="line">       self.status_label.setText(&quot;所有文件处理完成!&quot;)</span><br><span class="line">       self.current_file_status_label.setText(&quot;&quot;)</span><br><span class="line"></span><br><span class="line">       # 显示处理结果摘要</span><br><span class="line">       result_msg = f&quot;处理完成！共处理 &#123;self.total_files_to_process&#125; 个文件n&quot;</span><br><span class="line">       result_msg += f&quot;成功: &#123;self.success_count&#125; 个n&quot;</span><br><span class="line">       result_msg += f&quot;失败: &#123;self.failure_count&#125; 个&quot;</span><br><span class="line"></span><br><span class="line">       if self.failed_files:</span><br><span class="line">           result_msg += &quot;nn处理失败的文件：n&quot; + &quot;n&quot;.join(self.failed_files)</span><br><span class="line"></span><br><span class="line">       QMessageBox.information(self, &quot;处理完成&quot;, result_msg)</span><br><span class="line"></span><br><span class="line">       # 重置界面状态</span><br><span class="line">       self.process_button.setEnabled(True)</span><br><span class="line">       self.browse_files_button.setEnabled(True)</span><br><span class="line">       self.browse_folder_button.setEnabled(False)</span><br><span class="line">       self.overwrite_all = None</span><br><span class="line">       self.overwrite_all_checkbox.setChecked(False)</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">   # 确保中文正常显示</span><br><span class="line">   import matplotlib</span><br><span class="line">   matplotlib.rcParams[&quot;font.family&quot;] = [&quot;SimHei&quot;, &quot;WenQuanYi Micro Hei&quot;, &quot;Heiti TC&quot;]</span><br><span class="line"></span><br><span class="line">   app = QApplication(sys.argv)</span><br><span class="line">   window = PdfWatermarkRemoverApp()</span><br><span class="line">   window.show()</span><br><span class="line">   sys.exit(app.exec_())</span><br></pre></td></tr></table></figure></div><p>以上代码实现了一个功能完整的 PDF 水印去除工具，包含了从 PDF 内容提取、水印识别与去除到 Word 文档生成的全流程。工具支持单个文件处理和文件夹批量处理，提供了友好的图形界面和详细的处理状态反馈。你可以直接使用这段代码，也可以根据实际需求进行进一步的定制和优化。</p><p>PS:代码仅供参考，内容不一定正确，要根据实际情况处理喵</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在日常办公和学习中，我们经常会遇到带有水印的 PDF 文档，这些水印不仅影响阅读体验，还可能干扰文档的二次编辑和使用。本文将带你从零开始，一步步构建一个功能完善的 PDF 水印去除工具，实现从单文件处理到批量转换的完整解决方案。&lt;/p&gt;
&lt;p&gt;需求分析：为什么需要 PDF </summary>
      
    
    
    
    <category term="-Python -PDF -Word" scheme="http://example.com/categories/Python-PDF-Word/"/>
    
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
    <category term="PyMuPDF" scheme="http://example.com/tags/PyMuPDF/"/>
    
    <category term="水印去除" scheme="http://example.com/tags/%E6%B0%B4%E5%8D%B0%E5%8E%BB%E9%99%A4/"/>
    
    <category term="PDF处理" scheme="http://example.com/tags/PDF%E5%A4%84%E7%90%86/"/>
    
    <category term="PyQt5" scheme="http://example.com/tags/PyQt5/"/>
    
    <category term="Word" scheme="http://example.com/tags/Word/"/>
    
  </entry>
  
  <entry>
    <title>揭秘xlsxwriter：富文本格式如何精准“染色”？</title>
    <link href="http://example.com/2025/07/16/xlsxwriter%EF%BC%9A%E5%AF%8C%E6%96%87%E6%9C%AC%E6%A0%BC%E5%BC%8F%E5%A6%82%E4%BD%95%E7%B2%BE%E5%87%86%E2%80%9C%E6%9F%93%E8%89%B2%E2%80%9D%EF%BC%9F/"/>
    <id>http://example.com/2025/07/16/xlsxwriter%EF%BC%9A%E5%AF%8C%E6%96%87%E6%9C%AC%E6%A0%BC%E5%BC%8F%E5%A6%82%E4%BD%95%E7%B2%BE%E5%87%86%E2%80%9C%E6%9F%93%E8%89%B2%E2%80%9D%EF%BC%9F/</id>
    <published>2025-07-16T02:48:10.000Z</published>
    <updated>2025-07-17T07:21:29.971Z</updated>
    
    <content type="html"><![CDATA[<p>核心概念</p><p>xlsxwriter 通过<strong>单元格格式</strong>和<strong>文本位置索引</strong>来精确控制文本区间样式，其判定逻辑基于以下关键内容：</p><h3 id="1-文本区间定义方式-xA"><a href="#1-文本区间定义方式-xA" class="headerlink" title="1. 文本区间定义方式&#xA;"></a>1. 文本区间定义方式&#xA;</h3><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 基本语法（非真实代码，仅示意逻辑）</span><br><span class="line">worksheet.write_rich_string(</span><br><span class="line">    row, col,</span><br><span class="line">    [format1, &quot;红色文本&quot;, format2, &quot;普通文本&quot;]</span><br><span class="line">)</span><br></pre></td></tr></table></figure></div><ul><li><p><strong>位置判定</strong>：根据字符串在参数列表中的顺序确定位置</p></li><li><p><strong>格式继承</strong>：格式对象作用于紧随其后的文本段</p></li></ul><h3 id="2-关键判定规则-xA"><a href="#2-关键判定规则-xA" class="headerlink" title="2. 关键判定规则&#xA;"></a>2. 关键判定规则&#xA;</h3><table><thead><tr><th>判定维度&#xA;</th><th>说明&#xA;</th></tr></thead><tbody><tr><td>格式对象位置&#xA;</td><td>格式总是应用于下一个字符串元素&#xA;</td></tr><tr><td>文本分段&#xA;</td><td>每个字符串元素被视为独立文本段&#xA;</td></tr><tr><td>空格式处理&#xA;</td><td>None 或省略格式时继承单元格默认格式&#xA;</td></tr><tr><td>特殊字符&#xA;</td><td>换行符 (\n) 会创建新文本段但不中断格式应用&#xA;</td></tr></tbody></table><h3 id="3-实际应用示例-xA"><a href="#3-实际应用示例-xA" class="headerlink" title="3. 实际应用示例&#xA;"></a>3. 实际应用示例&#xA;</h3><h4 id="案例-1：基础红黑文本-xA"><a href="#案例-1：基础红黑文本-xA" class="headerlink" title="案例 1：基础红黑文本&#xA;"></a>案例 1：基础红黑文本&#xA;</h4><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">red = workbook.add_format(&#123;&#x27;color&#x27;: &#x27;red&#x27;&#125;)</span><br><span class="line">black = workbook.add_format(&#123;&#x27;color&#x27;: &#x27;black&#x27;&#125;)</span><br><span class="line"></span><br><span class="line"># &quot;答案&quot;红色，&quot;:&quot;黑色，&quot;42&quot;红色</span><br><span class="line">worksheet.write_rich_string(&#x27;A1&#x27;,</span><br><span class="line">    red, &#x27;答案&#x27;,</span><br><span class="line">    black, &#x27;:&#x27;,</span><br><span class="line">    red, &#x27;42&#x27;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></div><p>内存中的区间映射：</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[0-2): 红色格式 (对应&quot;答案&quot;)</span><br><span class="line">[2-3): 黑色格式 (对应&quot;:&quot;) </span><br><span class="line">[3-5): 红色格式 (对应&quot;42&quot;)</span><br></pre></td></tr></table></figure></div><h4 id="案例-2：带格式继承的文本-xA"><a href="#案例-2：带格式继承的文本-xA" class="headerlink" title="案例 2：带格式继承的文本&#xA;"></a>案例 2：带格式继承的文本&#xA;</h4><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">bold = workbook.add_format(&#123;&#x27;bold&#x27;: True&#125;)</span><br><span class="line">default = workbook.add_format()</span><br><span class="line"></span><br><span class="line"># &quot;注意&quot;加粗，后续文本默认格式</span><br><span class="line">worksheet.write_rich_string(&#x27;A2&#x27;,</span><br><span class="line">    bold, &#x27;注意&#x27;,</span><br><span class="line">    None, &#x27;：请检查数据&#x27;  # None继承单元格默认格式</span><br><span class="line">)</span><br></pre></td></tr></table></figure></div><h3 id="4-特殊场景处理-xA"><a href="#4-特殊场景处理-xA" class="headerlink" title="4. 特殊场景处理&#xA;"></a>4. 特殊场景处理&#xA;</h3><h4 id="混合格式文本-xA"><a href="#混合格式文本-xA" class="headerlink" title="混合格式文本&#xA;"></a>混合格式文本&#xA;</h4><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 同一单词中部分字母标红</span><br><span class="line">worksheet.write_rich_string(&#x27;A3&#x27;,</span><br><span class="line">    black, &#x27;Pri&#x27;,</span><br><span class="line">    red, &#x27;mar&#x27;,</span><br><span class="line">    black, &#x27;y&#x27;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></div><p>效果：显示为 “Primary” 其中 “mar” 为红色</p><h4 id="动态文本构建-xA"><a href="#动态文本构建-xA" class="headerlink" title="动态文本构建&#xA;"></a>动态文本构建&#xA;</h4><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">parts = [black, &quot;随机值：&quot;]</span><br><span class="line">if highlight:</span><br><span class="line">    parts.extend([red, str(value)])</span><br><span class="line">else:</span><br><span class="line">    parts.extend([black, str(value)])</span><br><span class="line">    </span><br><span class="line">worksheet.write_rich_string(&#x27;A4&#x27;, *parts)</span><br></pre></td></tr></table></figure></div><h3 id="5-底层实现原理-xA"><a href="#5-底层实现原理-xA" class="headerlink" title="5. 底层实现原理&#xA;"></a>5. 底层实现原理&#xA;</h3><ul><li><strong>OpenXML 映射</strong>：最终生成类似以下 XML 结构</li></ul><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;r&gt;</span><br><span class="line">  &lt;rPr&gt;&lt;color rgb=&quot;FFFF0000&quot;/&gt;&lt;/rPr&gt;</span><br><span class="line">  &lt;t&gt;答案&lt;/t&gt;</span><br><span class="line">&lt;/r&gt;</span><br><span class="line">&lt;r&gt;</span><br><span class="line">  &lt;rPr&gt;&lt;color rgb=&quot;FF000000&quot;/&gt;&lt;/rPr&gt;</span><br><span class="line">  &lt;t&gt;:&lt;/t&gt;</span><br><span class="line">&lt;/r&gt;</span><br></pre></td></tr></table></figure></div><ul><li><strong>索引计算</strong>：库内部维护格式栈，根据参数顺序计算每个文本段的起止位置</li></ul><h3 id="6-使用限制与注意事项-xA"><a href="#6-使用限制与注意事项-xA" class="headerlink" title="6. 使用限制与注意事项&#xA;"></a>6. 使用限制与注意事项&#xA;</h3><ul><li><p><strong>不可变特性</strong>：一旦写入无法修改单个文本段格式</p></li><li><p><strong>性能影响</strong>：每个格式变化都会创建新的<code>&lt;r&gt;</code>元素，过多分段影响文件大小</p></li><li><p><strong>边界情况</strong>：</p><ul><li>空字符串仍会占用格式区间</li><li>连续的相同格式不会自动合并</li></ul></li></ul><h3 id="7-调试技巧-xA"><a href="#7-调试技巧-xA" class="headerlink" title="7. 调试技巧&#xA;"></a>7. 调试技巧&#xA;</h3><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 查看实际生成的XML（需要保存文件后解压查看）</span><br><span class="line">workbook.filename = &#x27;output.xlsx&#x27;</span><br><span class="line">workbook.close()</span><br><span class="line"># 解压后查看xl/worksheets/sheet1.xml</span><br></pre></td></tr></table></figure></div><h3 id="最佳实践建议-xA"><a href="#最佳实践建议-xA" class="headerlink" title="最佳实践建议&#xA;"></a>最佳实践建议&#xA;</h3><ul><li><p>批量合并相同格式的文本段</p></li><li><p>对静态内容预先生成格式列表</p></li><li><p>避免单个单元格内超过 20 个格式分段</p></li><li><p>对动态内容使用辅助函数构建参数列表</p></li></ul><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def build_rich_text(text_parts):</span><br><span class="line">    result = []</span><br><span class="line">    for text, fmt in text_parts:</span><br><span class="line">        result.extend([fmt, text])</span><br><span class="line">    return result</span><br></pre></td></tr></table></figure></div><p><strong>注</strong>：与 openpyxl 的 CellRichText 不同，xlsxwriter 采用更底层的格式绑定机制，对文本区间的判定完全基于参数序列顺序，不依赖任何文本标记符号。</p><h3 id="关键要点总结-xA"><a href="#关键要点总结-xA" class="headerlink" title="关键要点总结&#xA;"></a>关键要点总结&#xA;</h3><ol><li><p>xlsxwriter 的文本区间判定是<strong>顺序敏感</strong>的</p></li><li><p>格式对象总是<strong>向前绑定</strong>到下一个文本元素</p></li><li><p>实际渲染时会将文本区间映射为 OpenXML 的<code>&lt;r&gt;</code>元素</p></li><li><p>处理富文本时需要特别注意参数列表的构建顺序</p></li></ol><p>PS:代码仅供参考，内容不一定正确，要根据实际情况处理喵</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;核心概念&lt;/p&gt;
&lt;p&gt;xlsxwriter 通过&lt;strong&gt;单元格格式&lt;/strong&gt;和&lt;strong&gt;文本位置索引&lt;/strong&gt;来精确控制文本区间样式，其判定逻辑基于以下关键内容：&lt;/p&gt;
&lt;h3 id=&quot;1-文本区间定义方式-xA&quot;&gt;&lt;a href=&quot;#1-</summary>
      
    
    
    
    <category term="Python库应用" scheme="http://example.com/categories/Python%E5%BA%93%E5%BA%94%E7%94%A8/"/>
    
    
    <category term="Excel" scheme="http://example.com/tags/Excel/"/>
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
    <category term="xlsxwriter" scheme="http://example.com/tags/xlsxwriter/"/>
    
    <category term="格式化" scheme="http://example.com/tags/%E6%A0%BC%E5%BC%8F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>docker离线部署：穿越网络屏障的容器编排利器</title>
    <link href="http://example.com/2025/07/16/docker%E7%A6%BB%E7%BA%BF%E9%83%A8%E7%BD%B2%EF%BC%9A%E7%A9%BF%E8%B6%8A%E7%BD%91%E7%BB%9C%E5%B1%8F%E9%9A%9C%E7%9A%84%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E5%88%A9%E5%99%A8/"/>
    <id>http://example.com/2025/07/16/docker%E7%A6%BB%E7%BA%BF%E9%83%A8%E7%BD%B2%EF%BC%9A%E7%A9%BF%E8%B6%8A%E7%BD%91%E7%BB%9C%E5%B1%8F%E9%9A%9C%E7%9A%84%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E5%88%A9%E5%99%A8/</id>
    <published>2025-07-16T01:52:06.000Z</published>
    <updated>2025-07-17T07:21:51.249Z</updated>
    
    <content type="html"><![CDATA[<p>一、Docker Compose 离线安装步骤</p><p>在 GitHub 上找到对应的 docker-compose 网站，下载适合当前系统的离线安装包（如 docker-compose-linux-x86_64），并将其放置在 &#x2F;tmp 目录下。</p><h3 id="赋予执行权限并移动至系统路径-xA"><a href="#赋予执行权限并移动至系统路径-xA" class="headerlink" title="赋予执行权限并移动至系统路径&#xA;"></a>赋予执行权限并移动至系统路径&#xA;</h3><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 赋予可执行权限</span><br><span class="line">chmod +x /tmp/docker-compose-linux-x86_64</span><br><span class="line"></span><br><span class="line"># 移动到系统可执行目录</span><br><span class="line">sudo mv /tmp/docker-compose-linux-x86_64 /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure></div><h3 id="验证安装结果-xA"><a href="#验证安装结果-xA" class="headerlink" title="验证安装结果&#xA;"></a>验证安装结果&#xA;</h3><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker-compose --version</span><br><span class="line"># 输出示例：docker-compose version 2.20.3, build a8266d3</span><br></pre></td></tr></table></figure></div><p>二、常见问题与解决方法</p><h3 id="权限不足问题-xA"><a href="#权限不足问题-xA" class="headerlink" title="权限不足问题&#xA;"></a>权限不足问题&#xA;</h3><h4 id="问题-xA"><a href="#问题-xA" class="headerlink" title="问题&#xA;"></a>问题&#xA;</h4><p>执行 mv 时提示权限错误。</p><h4 id="解决-xA"><a href="#解决-xA" class="headerlink" title="解决&#xA;"></a>解决&#xA;</h4><p>使用 sudo 命令获取管理员权限：</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mv /tmp/docker-compose-linux-x86_64 /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure></div><h3 id="命令不存在问题-xA"><a href="#命令不存在问题-xA" class="headerlink" title="命令不存在问题&#xA;"></a>命令不存在问题&#xA;</h3><h4 id="问题-xA-1"><a href="#问题-xA-1" class="headerlink" title="问题&#xA;"></a>问题&#xA;</h4><p>输入 docker-compose 提示命令未找到。</p><h4 id="解决-xA-1"><a href="#解决-xA-1" class="headerlink" title="解决&#xA;"></a>解决&#xA;</h4><p>检查系统路径是否包含 &#x2F;usr&#x2F;local&#x2F;bin：</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo $PATH  # 若不含 /usr/local/bin，添加至环境变量</span><br><span class="line">export PATH=$PATH:/usr/local/bin</span><br></pre></td></tr></table></figure></div><h3 id="文件名空格问题-xA"><a href="#文件名空格问题-xA" class="headerlink" title="文件名空格问题&#xA;"></a>文件名空格问题&#xA;</h3><h4 id="问题-xA-2"><a href="#问题-xA-2" class="headerlink" title="问题&#xA;"></a>问题&#xA;</h4><p>脚本文件名含前导空格导致命令失败。</p><h4 id="解决-xA-2"><a href="#解决-xA-2" class="headerlink" title="解决&#xA;"></a>解决&#xA;</h4><p>重命名文件去除空格：</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv &#x27; replace_image_registry.sh&#x27; replace_image_registry.sh</span><br></pre></td></tr></table></figure></div><p>三、核心命令总结</p><h3 id="安装核心步骤-xA"><a href="#安装核心步骤-xA" class="headerlink" title="安装核心步骤&#xA;"></a>安装核心步骤&#xA;</h3><p>下载 → 赋权 → 移动 → 验证</p><h3 id="关键命令-xA"><a href="#关键命令-xA" class="headerlink" title="关键命令&#xA;"></a>关键命令&#xA;</h3><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chmod +x /tmp/docker-compose-linux-x86_64</span><br><span class="line">sudo mv /tmp/docker-compose-linux-x86_64 /usr/local/bin/docker-compose</span><br><span class="line">docker-compose --version</span><br></pre></td></tr></table></figure></div><p>PS:代码仅供参考，内容不一定正确，要根据实际情况处理喵</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;一、Docker Compose 离线安装步骤&lt;/p&gt;
&lt;p&gt;在 GitHub 上找到对应的 docker-compose 网站，下载适合当前系统的离线安装包（如 docker-compose-linux-x86_64），并将其放置在 &amp;#x2F;tmp 目录下。&lt;/p&gt;
</summary>
      
    
    
    
    <category term="容器技术" scheme="http://example.com/categories/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/"/>
    
    <category term="部署实践" scheme="http://example.com/categories/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/%E9%83%A8%E7%BD%B2%E5%AE%9E%E8%B7%B5/"/>
    
    
    <category term="Docker Compose" scheme="http://example.com/tags/Docker-Compose/"/>
    
    <category term="离线安装" scheme="http://example.com/tags/%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85/"/>
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Portainer容器管理实战：从镜像加速到安全部署</title>
    <link href="http://example.com/2025/07/15/Portainer%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86%E5%AE%9E%E6%88%98%EF%BC%9A%E4%BB%8E%E9%95%9C%E5%83%8F%E5%8A%A0%E9%80%9F%E5%88%B0%E5%AE%89%E5%85%A8%E9%83%A8%E7%BD%B2/"/>
    <id>http://example.com/2025/07/15/Portainer%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86%E5%AE%9E%E6%88%98%EF%BC%9A%E4%BB%8E%E9%95%9C%E5%83%8F%E5%8A%A0%E9%80%9F%E5%88%B0%E5%AE%89%E5%85%A8%E9%83%A8%E7%BD%B2/</id>
    <published>2025-07-15T09:50:31.000Z</published>
    <updated>2025-07-17T07:21:47.120Z</updated>
    
    <content type="html"><![CDATA[<p>一、背景：为什么选择从第三方镜像源拉取 Portainer？</p><p>近期在学习容器管理工具 Portainer 时，参考了一篇技术教程（知乎链接：<a class="link"   href="https://zhuanlan.zhihu.com/p/27740131259" >https://zhuanlan.zhi<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><a class="link"   href="https://zhuanlan.zhihu.com/p/27740131259" >hu<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><a class="link"   href="https://zhuanlan.zhihu.com/p/27740131259" >.com&#x2F;<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><a class="link"   href="https://zhuanlan.zhihu.com/p/27740131259" >p&#x2F;2<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><a class="link"   href="https://zhuanlan.zhihu.com/p/27740131259" >7740<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><a class="link"   href="https://zhuanlan.zhihu.com/p/27740131259" >1312<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><a class="link"   href="https://zhuanlan.zhihu.com/p/27740131259" >59<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>），教程中推荐使用官方镜像源部署。但由于网络环境限制，尝试从第三方镜像源<code>docker.1ms.run</code>拉取 Portainer 镜像，意外发现该镜像源提供了更稳定的下载速度，因此记录下完整操作流程，供遇到类似问题的开发者参考。</p><p>二、操作步骤：从镜像拉取到容器启动的全流程</p><h3 id="1-拉取-Portainer-镜像-xA"><a href="#1-拉取-Portainer-镜像-xA" class="headerlink" title="1. 拉取 Portainer 镜像&#xA;"></a>1. 拉取 Portainer 镜像&#xA;</h3><p>通常情况下，Portainer 官方镜像的拉取命令为：</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull portainer/portainer-ce:latest</span><br></pre></td></tr></table></figure></div><p>但本次尝试使用第三方镜像源：</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull docker.1ms.run/portainer/portainer-ce:latest</span><br></pre></td></tr></table></figure></div><p><strong>注意事项：</strong></p><ul><li>第三方镜像源可能存在安全风险，建议优先使用官方镜像（<code>portainer/portainer-ce</code>）。</li><li>若拉取失败，可检查镜像源是否可用（如执行<code>ping docker.1ms.run</code>），或切换至国内加速源（如 Docker 中国镜像站）。</li></ul><h3 id="2-验证镜像是否成功拉取-xA"><a href="#2-验证镜像是否成功拉取-xA" class="headerlink" title="2. 验证镜像是否成功拉取&#xA;"></a>2. 验证镜像是否成功拉取&#xA;</h3><p>通过<code>docker images</code>命令查看本地镜像列表：</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure></div><h3 id="3-启动-Portainer-容器-xA"><a href="#3-启动-Portainer-容器-xA" class="headerlink" title="3. 启动 Portainer 容器&#xA;"></a>3. 启动 Portainer 容器&#xA;</h3><p>使用以下命令启动容器，并配置挂载与端口映射：</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">  --name portainer \</span><br><span class="line">  -p 9000:9000 \</span><br><span class="line">  -v /var/run/docker.sock:/var/run/docker.sock \</span><br><span class="line">  -v portainer_data:/data \</span><br><span class="line">  --restart=always \</span><br><span class="line">  docker.1ms.run/portainer/portainer-ce:latest</span><br></pre></td></tr></table></figure></div><p><strong>参数解析：</strong></p><ul><li><p><code>-d</code>：后台运行容器；</p></li><li><p><code>-p 9000:9000</code>：映射宿主机 9000 端口到容器 9000 端口，用于访问 Web 界面；</p></li><li><p><code>-v /var/run/docker.sock:/var/run/docker.sock</code>：挂载 Docker 套接字，允许 Portainer 管理宿主机 Docker 环境；</p></li><li><p><code>-v portainer_data:/data</code>：创建数据卷持久化存储 Portainer 配置；</p></li><li><p><code>--restart=always</code>：确保容器随系统重启自动运行。</p></li></ul><h3 id="4-访问-Portainer-Web-界面-xA"><a href="#4-访问-Portainer-Web-界面-xA" class="headerlink" title="4. 访问 Portainer Web 界面&#xA;"></a>4. 访问 Portainer Web 界面&#xA;</h3><p>容器启动后，在浏览器中输入<code>http://宿主机IP:9000</code>，首次访问需设置管理员密码，随后进入 Portainer 管理界面。</p><p>三、遇到的问题与解决方案</p><h3 id="1-镜像拉取失败：manifest-unknown-xA"><a href="#1-镜像拉取失败：manifest-unknown-xA" class="headerlink" title="1. 镜像拉取失败：manifest unknown&#xA;"></a>1. 镜像拉取失败：manifest unknown&#xA;</h3><p><strong>错误信息：</strong></p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error response from daemon: manifest for docker.1ms.run/portainer-ce:latest not found: manifest unknown</span><br></pre></td></tr></table></figure></div><p><strong>原因：</strong></p><p>镜像源中无该镜像，或镜像名称拼写错误（如<code>portainer-ce</code>写成<code>portainer</code>）。</p><p><strong>解决方法：</strong></p><p>确认镜像名称正确性，或更换为官方镜像源拉取：</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull portainer/portainer-ce:latest</span><br></pre></td></tr></table></figure></div><h3 id="2-Docker-Hub-连接超时-xA"><a href="#2-Docker-Hub-连接超时-xA" class="headerlink" title="2. Docker Hub 连接超时&#xA;"></a>2. Docker Hub 连接超时&#xA;</h3><p><strong>错误信息：</strong></p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error response from daemon: Get &quot;https://registry-1.docker.io/v2/&quot;: context deadline exceeded</span><br></pre></td></tr></table></figure></div><p><strong>解决方法：</strong></p><p>配置国内镜像加速源，编辑<code>/etc/docker/daemon.json</code>添加：</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://registry.docker-cn.com&quot;, &quot;https://docker.mirrors.ustc.edu.cn&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>重启 Docker 服务：<code>sudo systemctl restart docker</code>。</p><p>四、使用第三方镜像源的风险与建议</p><ul><li><p><strong>安全风险</strong>：第三方镜像源可能被篡改，建议优先使用官方镜像（<code>portainer/portainer-ce</code>）。</p></li><li><p><strong>版本兼容性</strong>：第三方镜像可能非最新版本，建议定期通过<code>docker pull</code>更新镜像。</p></li><li><p><strong>网络稳定性</strong>：若第三方源频繁失效，优先使用官方源或国内大厂加速源（如阿里云、腾讯云镜像站）。</p></li></ul><p>五、总结：Portainer 的价值与容器管理实践</p><p>通过 Docker 部署 Portainer 后，可直观管理容器、镜像、网络及数据卷，尤其适合新手快速上手容器化部署。本次从第三方镜像源拉取的经历表明：技术实践中需在效率与安全性间权衡，建议在测试环境尝试非官方源，生产环境务必使用官方可信镜像。</p><p>后续可进一步探索 Portainer 的 Kubernetes 管理、RBAC 权限控制等高级功能，提升容器化应用的部署与运维效率。</p><p>PS:代码仅供参考，内容不一定正确，要根据实际情况处理喵</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;一、背景：为什么选择从第三方镜像源拉取 Portainer？&lt;/p&gt;
&lt;p&gt;近期在学习容器管理工具 Portainer 时，参考了一篇技术教程（知乎链接：&lt;a class=&quot;link&quot;   href=&quot;https://zhuanlan.zhihu.com/p/2774013</summary>
      
    
    
    
    <category term="Docker实践" scheme="http://example.com/categories/Docker%E5%AE%9E%E8%B7%B5/"/>
    
    
    <category term="Docker" scheme="http://example.com/tags/Docker/"/>
    
    <category term="Portainer" scheme="http://example.com/tags/Portainer/"/>
    
    <category term="镜像加速" scheme="http://example.com/tags/%E9%95%9C%E5%83%8F%E5%8A%A0%E9%80%9F/"/>
    
    <category term="容器管理" scheme="http://example.com/tags/%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Python 魔法：一键让 Excel 正确选项「脸红」</title>
    <link href="http://example.com/2025/07/15/Python-%E9%AD%94%E6%B3%95%EF%BC%9A%E4%B8%80%E9%94%AE%E8%AE%A9-Excel-%E6%AD%A3%E7%A1%AE%E9%80%89%E9%A1%B9%E3%80%8C%E8%84%B8%E7%BA%A2%E3%80%8D/"/>
    <id>http://example.com/2025/07/15/Python-%E9%AD%94%E6%B3%95%EF%BC%9A%E4%B8%80%E9%94%AE%E8%AE%A9-Excel-%E6%AD%A3%E7%A1%AE%E9%80%89%E9%A1%B9%E3%80%8C%E8%84%B8%E7%BA%A2%E3%80%8D/</id>
    <published>2025-07-15T09:21:07.000Z</published>
    <updated>2025-07-17T07:35:07.528Z</updated>
    
    <content type="html"><![CDATA[<p>在数据处理工作中，我们经常需要处理 Excel 文件中的试题数据，特别是需要对正确答案进行特殊标记。本文将分享我从最初实现到最终优化的完整改进过程。</p><p>初始需求</p><p>我们需要处理一个包含试题的 Excel 文件，具体要求：</p><ul><li><p>文件包含 “试题选项” 和 “试题答案” 两列</p></li><li><p>试题选项用 “$;$” 分隔多个选项</p></li><li><p>需要根据 “试题答案” 将正确答案标记为红色</p></li><li><p>处理后的结果直接修改原文件</p></li></ul><p>第一版实现</p><h3 id="核心思路：-xA"><a href="#核心思路：-xA" class="headerlink" title="核心思路：&#xA;"></a>核心思路：&#xA;</h3><ul><li><p>使用 pandas 读取 Excel 文件</p></li><li><p>用 openpyxl 修改原文件样式</p></li><li><p>在正确答案前后添加 “**” 标记</p></li><li><p>提示用户手动替换 “**” 为红色格式</p></li></ul><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 主要处理逻辑</span><br><span class="line">marked_options = []</span><br><span class="line">for i, option in enumerate(options):</span><br><span class="line">    if i in correct_indices:</span><br><span class="line">        marked_options.append(f&quot;**&#123;option&#125;**&quot;)  # 用**标记正确答案</span><br><span class="line">    else:</span><br><span class="line">        marked_options.append(option)</span><br><span class="line">cell.value = &#x27;$;$&#x27;.join(marked_options)</span><br></pre></td></tr></table></figure></div><p><strong>问题：</strong></p><p>不能自动设置红色，需要用户手动替换，** 的标记方式不够直观</p><p>第二版改进</p><h3 id="改进点：-xA"><a href="#改进点：-xA" class="headerlink" title="改进点：&#xA;"></a>改进点：&#xA;</h3><ul><li><p>改用 xlsxwriter 引擎</p></li><li><p>直接处理 ** 标记的内容并设置为红色</p></li><li><p>保留 ** 标记</p></li></ul><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 使用正则匹配**内容并设置格式</span><br><span class="line">for match in re.finditer(r&#x27;\*\*(.*?)\*\*&#x27;, cell_value):</span><br><span class="line">    parts.append(&#123;</span><br><span class="line">        &#x27;text&#x27;: f&quot;**&#123;match.group(1)&#125;**&quot;,</span><br><span class="line">        &#x27;format&#x27;: red_format</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure></div><p><strong>问题：</strong></p><p>使用 ** 将正确答案括起来的话，xlsxwriter 无法非常准确地解析出来，因为答案可能是 <strong>A</strong>$;$B$;$C$;$<strong>D</strong> 这样子的，相同的符号会干扰它的判断，从而导致效果不好</p><p>最终版改进</p><h3 id="改进思路：-xA"><a href="#改进思路：-xA" class="headerlink" title="改进思路：&#xA;"></a>改进思路：&#xA;</h3><ul><li><p>改回使用 openpyxl</p></li><li><p>正确答案用 [] 标记</p></li><li><p>非正确答案不做标记</p></li></ul><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">marked_options = []</span><br><span class="line">for i, option in enumerate(options):</span><br><span class="line">    if i in correct_indices:</span><br><span class="line">        marked_options.append(f&quot;[&#123;option&#125;]&quot;)  # 正确答案标记</span><br><span class="line">    else:</span><br><span class="line">        marked_options.append(option)</span><br></pre></td></tr></table></figure></div><p>然后再进行标红处理：</p><ul><li><p>使用富文本 (CellRichText) 直接设置红色</p></li><li><p>自动移除 [] 标记</p></li><li><p>添加异常处理，失败时回退到普通文本</p></li><li><p>更友好的提示信息</p></li></ul><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">rich_text = CellRichText()</span><br><span class="line">for i, option in enumerate(options):</span><br><span class="line">    if i &gt; 0:</span><br><span class="line">        rich_text.append(&#x27;$;$&#x27;)</span><br><span class="line">    clean_option = option.replace(&#x27;[&#x27;, &#x27;&#x27;).replace(&#x27;]&#x27;, &#x27;&#x27;)</span><br><span class="line">    if i in correct_indices:</span><br><span class="line">        rich_text.append(TextBlock(inline_red_font, clean_option))</span><br><span class="line">    else:</span><br><span class="line">        rich_text.append(clean_option)</span><br><span class="line">cell.value = rich_text</span><br></pre></td></tr></table></figure></div><h3 id="关键改进点：-xA"><a href="#关键改进点：-xA" class="headerlink" title="关键改进点：&#xA;"></a>关键改进点：&#xA;</h3><ul><li><p><strong>富文本支持</strong>：使用 CellRichText 和 TextBlock 实现对单个字符的样式设置</p></li><li><p><strong>自动清理</strong>：移除选项中的 [] 标记</p></li></ul><p>拓展功能：标记检查与统一分隔符</p><p>在最终版的基础上，我进一步完善了代码，增加了两项重要的功能：统一处理非标准分隔符和全面的标记检查报告。这使得整个流程更加健壮和智能化。</p><h3 id="1-统一分隔符-xA"><a href="#1-统一分隔符-xA" class="headerlink" title="1. 统一分隔符&#xA;"></a>1. 统一分隔符&#xA;</h3><p>很多时候，Excel 中的选项分隔符可能不统一，除了标准的$;$，还可能出现$;、$$等，甚至单空格加 $ 等多种形式。为了确保选项能够被正确解析，我加入了强大的正则表达式来识别并统一这些非标准分隔符为 $;$。</p><p>实现方式：使用 re.compile 定义了一个详细的正则表达式 separator_pattern，涵盖了多种常见的非标准分隔符。</p><p>效果：在处理每个选项字符串时，首先使用 separator_pattern.sub (‘$;$’, options_str) 将所有识别到的非标准分隔符统一替换为 $;$ 。这大大提高了数据处理的鲁棒性，减少了因格式不一致导致的问题。</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 正则表达式定义</span><br><span class="line">separator_pattern = re.compile(r&#x27;&#x27;&#x27;</span><br><span class="line">    \$;\$|       # 标准 $;$</span><br><span class="line">    \$[:：]\$|   # $:$ 或 $：$</span><br><span class="line">    ;\$|         # ;$</span><br><span class="line">    \$；|        # $；</span><br><span class="line">    [；:：]\$|   # ；$ 或 ：$</span><br><span class="line">    \$[;；:：]|  # $; 或 $；或 $: 或 $：</span><br><span class="line">    \$\$|        # $$</span><br><span class="line">    \s&#123;2,&#125;|      # 两个或更多空格</span><br><span class="line">    \$\s|\s\$|   # $ 后或前有单个空格</span><br><span class="line">    ;           # 单独的分号</span><br><span class="line">&#x27;&#x27;&#x27;, re.VERBOSE)</span><br><span class="line"></span><br><span class="line"># 替换处理</span><br><span class="line">modified_str = separator_pattern.sub(&#x27;$;$&#x27;, options_str)</span><br></pre></td></tr></table></figure></div><h3 id="2-标记检查报告-xA"><a href="#2-标记检查报告-xA" class="headerlink" title="2. 标记检查报告&#xA;"></a>2. 标记检查报告&#xA;</h3><p>仅仅对正确答案进行标记是不够的，我们还需要验证标记是否正确、是否有遗漏。此功能可以生成详细的报告，指出 “正确答案未被标记” 和 “错误答案被标记” 的情况。</p><h4 id="核心逻辑优化：-xA"><a href="#核心逻辑优化：-xA" class="headerlink" title="核心逻辑优化：&#xA;"></a>核心逻辑优化：&#xA;</h4><ul><li><p><strong>未标记检查</strong>：传统的检查方法是看 “标记索引” 中是否包含正确答案的索引。但如果正确答案完全没有被标记（即选项中根本没有 []），这种方法就无法识别。新的逻辑直接检查正确答案的选项内容是否被 [] 包裹 。只要正确答案未被 [] 包裹，无论是否有其他标记动作，都会被识别为 “未标记” 。</p></li><li><p><strong>错误标记检查</strong>：检查所有被 [] 包裹的选项，如果其索引不在正确答案的索引列表中，则视为错误标记 。</p></li></ul><h4 id="输出报告：-xA"><a href="#输出报告：-xA" class="headerlink" title="输出报告：&#xA;"></a>输出报告：&#xA;</h4><p>生成清晰的报告，包含：</p><ul><li><p>检查的总行数 。</p></li><li><p>“未标记正确答案的行” 数量及具体详情（Excel 行号、应标记的字母、未被包裹的实际内容） 。</p></li><li><p>“错误标记的行” 数量及具体详情（Excel 行号、错误标记的内容、正确的答案） 。</p></li></ul><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#未标记检查代码：</span><br><span class="line">has_unmarked = False</span><br><span class="line">for i in correct_indices:</span><br><span class="line">    opt = options[i]</span><br><span class="line">    if not (opt.strip().startswith(&#x27;[&#x27;) and opt.strip().endswith(&#x27;]&#x27;)):</span><br><span class="line">        has_unmarked = True</span><br><span class="line">        break</span><br><span class="line">if has_unmarked:</span><br><span class="line">    unmarked_rows.append(&#123;</span><br><span class="line">        &#x27;row&#x27;: row_num,</span><br><span class="line">        &#x27;expected&#x27;: [chr(65 + i) for i in correct_indices],</span><br><span class="line">        &#x27;actual&#x27;: [options[i].strip() for i in correct_indices]</span><br><span class="line">    &#125;)</span><br><span class="line">#错误标记检查代码：</span><br><span class="line">marked_indices = []</span><br><span class="line">for i, opt in enumerate(options):</span><br><span class="line">    if opt.strip().startswith(&#x27;[&#x27;) and opt.strip().endswith(&#x27;]&#x27;):</span><br><span class="line">        marked_indices.append(i)</span><br><span class="line"></span><br><span class="line">for i in marked_indices:</span><br><span class="line">    if i not in correct_indices:</span><br><span class="line">        wrong_marking.append(&#123;</span><br><span class="line">            &#x27;row&#x27;: row_num,</span><br><span class="line">            &#x27;wrong_marked&#x27;: options[i].strip(),</span><br><span class="line">            &#x27;correct&#x27;: [chr(65 + i) for i in correct_indices]</span><br><span class="line">        &#125;)</span><br><span class="line">        break</span><br></pre></td></tr></table></figure></div><h4 id="验证示例：-xA"><a href="#验证示例：-xA" class="headerlink" title="验证示例：&#xA;"></a>验证示例：&#xA;</h4><p>如果一个 Excel 行的正确答案是 D，但选项 D 没有被 [] 包裹，运行代码后会输出：</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">=== 标记检查报告 ===</span><br><span class="line">共检查 1000 行数据</span><br><span class="line"></span><br><span class="line">1. 未标记正确答案的行: 1 行</span><br><span class="line">    行X: 应标记[&#x27;D&#x27;]（内容：D、xxxxxxxx）未被[]包裹</span><br><span class="line"></span><br><span class="line">2. 错误标记的行: 0 行</span><br></pre></td></tr></table></figure></div><p>这使得我们能够精准识别 “应该标记但完全没标记” 的情况 。</p><p>PS:代码仅供参考，内容不一定正确，要根据实际情况处理喵</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在数据处理工作中，我们经常需要处理 Excel 文件中的试题数据，特别是需要对正确答案进行特殊标记。本文将分享我从最初实现到最终优化的完整改进过程。&lt;/p&gt;
&lt;p&gt;初始需求&lt;/p&gt;
&lt;p&gt;我们需要处理一个包含试题的 Excel 文件，具体要求：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;</summary>
      
    
    
    
    <category term="Excel" scheme="http://example.com/categories/Excel/"/>
    
    <category term="Python" scheme="http://example.com/categories/Excel/Python/"/>
    
    <category term="数据处理" scheme="http://example.com/categories/Excel/Python/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"/>
    
    
    <category term="Excel" scheme="http://example.com/tags/Excel/"/>
    
    <category term="Pandas" scheme="http://example.com/tags/Pandas/"/>
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
    <category term="Openpyxl" scheme="http://example.com/tags/Openpyxl/"/>
    
    <category term="Xlsxwriter" scheme="http://example.com/tags/Xlsxwriter/"/>
    
    <category term="正则表达式" scheme="http://example.com/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Python 魔法：一键让 Excel 正确选项「脸红」</title>
    <link href="http://example.com/2025/07/15/Python%E9%AD%94%E6%B3%95%EF%BC%9A%E5%A6%82%E4%BD%95%E7%94%A8%E7%89%B9%E5%BE%81%E8%AF%86%E5%88%AB%E8%AE%A9PDF%E6%B0%B4%E5%8D%B0%E9%9A%90%E5%BD%A2%EF%BC%9F/"/>
    <id>http://example.com/2025/07/15/Python%E9%AD%94%E6%B3%95%EF%BC%9A%E5%A6%82%E4%BD%95%E7%94%A8%E7%89%B9%E5%BE%81%E8%AF%86%E5%88%AB%E8%AE%A9PDF%E6%B0%B4%E5%8D%B0%E9%9A%90%E5%BD%A2%EF%BC%9F/</id>
    <published>2025-07-15T09:21:07.000Z</published>
    <updated>2025-07-17T07:21:39.721Z</updated>
    
    <content type="html"><![CDATA[<p>在日常工作中，我们经常会遇到带有特定特征的 PDF 水印，比如固定的字体大小、倾斜角度、透明度和颜色。这些特性为我们提供了更精准地识别水印的依据。今天，我们就来深入探讨如何利用 PyMuPDF (Fitz) 库，基于这些特征实现 PDF 水印的精确识别和去除，并整合多种实用方法，帮你应对不同场景。</p><p>特定特征水印的识别原理</p><p>PDF 文件中的文本和图形对象都包含了丰富的元数据信息，例如字体大小、旋转角度、透明度和颜色。当水印具有固定特征时，我们可以通过以下步骤实现精准识别：</p><ol><li><p><strong>解析 PDF 页面内容</strong>： 获取页面上所有的文本和图形对象。</p></li><li><p><strong>提取对象特征</strong>： 获取每个对象的字体大小、旋转角度、透明度和颜色等信息。</p></li><li><p><strong>特征匹配</strong>： 将提取到的特征与我们已知的水印特征进行比对。</p></li><li><p><strong>处理匹配对象</strong>： 对符合水印特征的对象进行删除或覆盖处理。</p></li></ol><p>典型的 PDF 水印通常具备以下特征：</p><ul><li><p>📐 固定倾斜角度 (常见 15-45 度)</p></li><li><p>🎨 固定颜色 (常见浅灰色 #C0C0C0)</p></li><li><p>🌫 固定透明度 (约 30-50%)</p></li><li><p>🔠 固定字体大小 (通常较大)</p></li><li><p>🔄 重复出现在每一页相同位置</p></li></ul><p>使用 PyMuPDF 实现基于特征的水印处理</p><h3 id="方法一：基于字体大小和旋转角度的水印识别-xA"><a href="#方法一：基于字体大小和旋转角度的水印识别-xA" class="headerlink" title="方法一：基于字体大小和旋转角度的水印识别&#xA;"></a>方法一：基于字体大小和旋转角度的水印识别&#xA;</h3><p>这个方法非常适合那些字体大小和倾斜角度都比较固定的水印。</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import fitz</span><br><span class="line">import math</span><br><span class="line"></span><br><span class="line">def remove_watermark_by_font_size_and_rotation(input_pdf, output_pdf, font_size, rotation_angle):</span><br><span class="line">    doc = fitz.open(input_pdf)</span><br><span class="line">    for page in doc:</span><br><span class="line">        text_infos = page.get_text(&quot;dict&quot;)</span><br><span class="line">        for block in text_infos[&quot;blocks&quot;]:</span><br><span class="line">            if &quot;lines&quot; in block:</span><br><span class="line">                for line in block[&quot;lines&quot;]:</span><br><span class="line">                    for span in line[&quot;spans&quot;]:</span><br><span class="line">                        current_size = span[&quot;size&quot;]</span><br><span class="line">                        matrix = fitz.Matrix(span[&quot;matrix&quot;])</span><br><span class="line">                        current_rotation = math.degrees(math.atan2(matrix.b, matrix.a))</span><br><span class="line">                        if (abs(current_size - font_size) &lt; 1.5 and </span><br><span class="line">                            abs(current_rotation - rotation_angle) &lt; 5.0):</span><br><span class="line">                            page.add_redact_annot(fitz.Rect(span[&quot;bbox&quot;]), text=&quot;&quot;)</span><br><span class="line">        page.apply_redactions()</span><br><span class="line">    doc.save(output_pdf)</span><br><span class="line">    doc.close()</span><br></pre></td></tr></table></figure></div><p><strong>代码解析</strong>：</p><ul><li><p>我们使用 <code>page.get_text(&quot;dict&quot;)</code> 获取页面上所有的文本信息，包括它们的各种属性。</p></li><li><p>从文本跨度 (span) 中提取 字体大小 和 变换矩阵。</p></li><li><p>通过分解变换矩阵来计算文本的 旋转角度。这里使用了 <code>math.atan2(matrix.b, matrix.a)</code> 来更准确地获取旋转角度。</p></li><li><p>将提取到的特征与你已知的水印特征进行比较，如果匹配（并允许一定的误差范围），就用一个空白矩形覆盖水印区域。</p></li></ul><p><strong>难易度</strong>：★★★☆☆</p><p><strong>优点</strong>： 对具有固定字体大小和倾斜角度的水印效果特别好，误判率低。</p><p><strong>缺点</strong>： 需要你预先知道水印的字体大小和旋转角度参数。</p><h3 id="方法二：基于透明度和颜色的水印识别-xA"><a href="#方法二：基于透明度和颜色的水印识别-xA" class="headerlink" title="方法二：基于透明度和颜色的水印识别&#xA;"></a>方法二：基于透明度和颜色的水印识别&#xA;</h3><p>这种方法适用于那些有固定透明度和颜色的水印，特别是半透明的浅色水印。</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import fitz</span><br><span class="line"></span><br><span class="line">def remove_watermark_by_opacity_and_color(input_pdf, output_pdf, opacity_threshold, color_rgb_target, color_tolerance=10):</span><br><span class="line">    doc = fitz.open(input_pdf)</span><br><span class="line">    for page in doc:</span><br><span class="line">        text_infos = page.get_text(&quot;dict&quot;)</span><br><span class="line">        for block in text_infos[&quot;blocks&quot;]:</span><br><span class="line">            if &quot;lines&quot; in block:</span><br><span class="line">                for line in block[&quot;lines&quot;]:</span><br><span class="line">                    for span in line[&quot;spans&quot;]:</span><br><span class="line">                        color_int = span[&quot;color&quot;]</span><br><span class="line">                        r = (color_int &gt;&gt; 16) &amp; 0xFF</span><br><span class="line">                        g = (color_int &gt;&gt; 8) &amp; 0xFF</span><br><span class="line">                        b = color_int &amp; 0xFF</span><br><span class="line">                        current_color_rgb = (r, g, b)</span><br><span class="line">                        color_match = (</span><br><span class="line">                            abs(current_color_rgb[0] - color_rgb_target[0]) &lt;= color_tolerance and</span><br><span class="line">                            abs(current_color_rgb[1] - color_rgb_target[1]) &lt;= color_tolerance and</span><br><span class="line">                            abs(current_color_rgb[2] - color_rgb_target[2]) &lt;= color_tolerance</span><br><span class="line">                        )</span><br><span class="line">                        if color_match:</span><br><span class="line">                            page.add_redact_annot(fitz.Rect(span[&quot;bbox&quot;]), text=&quot;&quot;)</span><br><span class="line">        page.apply_redactions()</span><br><span class="line">    doc.save(output_pdf)</span><br><span class="line">    doc.close()</span><br></pre></td></tr></table></figure></div><p><strong>代码解析</strong>：</p><ul><li><p>我们从文本跨度中提取 RGB 颜色值。</p></li><li><p>注意： 直接从 span 中提取透明度信息在 PyMuPDF 中比较复杂，因为它通常是 PDF 内容流中的图形状态参数。为了实现真正的透明度识别，你可能需要渲染页面为图像后分析像素的 alpha 通道，或者进行更复杂的 PDF 内容流解析。在上面的代码中，我暂时移除了透明度的判断，主要依赖颜色匹配。</p></li><li><p>比较提取的颜色与已知水印特征，并设置一个容差范围。</p></li></ul><p><strong>难易度</strong>：★★★★☆</p><p><strong>优点</strong>： 对具有固定颜色（特别是浅色）的水印效果好。</p><p><strong>缺点</strong>： 透明度提取是难点，可能需要深入解析 PDF 内部结构或借助图像处理库。</p><h3 id="方法三：综合多特征的水印识别-xA"><a href="#方法三：综合多特征的水印识别-xA" class="headerlink" title="方法三：综合多特征的水印识别&#xA;"></a>方法三：综合多特征的水印识别&#xA;</h3><p>当水印特征明确且固定时，这个方法能提供最高的识别准确性，因为它结合了多种特征进行判断。</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">import fitz</span><br><span class="line">import math</span><br><span class="line"></span><br><span class="line">def remove_watermark_by_multiple_features(input_pdf, output_pdf,</span><br><span class="line">                                        font_size, rotation_angle,</span><br><span class="line">                                        color_rgb,</span><br><span class="line">                                        size_tolerance=1.5, rotation_tolerance=5.0, color_tolerance=10):</span><br><span class="line">    doc = fitz.open(input_pdf)</span><br><span class="line">    for page in doc:</span><br><span class="line">        text_infos = page.get_text(&quot;dict&quot;)</span><br><span class="line">        for block in text_infos[&quot;blocks&quot;]:</span><br><span class="line">            if &quot;lines&quot; in block:</span><br><span class="line">                for line in block[&quot;lines&quot;]:</span><br><span class="line">                    for span in line[&quot;spans&quot;]:</span><br><span class="line">                        current_size = span[&quot;size&quot;]</span><br><span class="line">                        matrix = fitz.Matrix(span[&quot;matrix&quot;])</span><br><span class="line">                        current_rotation = math.degrees(math.atan2(matrix.b, matrix.a))</span><br><span class="line">                        color_int = span[&quot;color&quot;]</span><br><span class="line">                        r = (color_int &gt;&gt; 16) &amp; 0xFF</span><br><span class="line">                        g = (color_int &gt;&gt; 8) &amp; 0xFF</span><br><span class="line">                        b = color_int &amp; 0xFF</span><br><span class="line">                        current_color_rgb = (r, g, b)</span><br><span class="line">                        size_match = abs(current_size - font_size) &lt; size_tolerance</span><br><span class="line">                        rotation_match = abs(current_rotation - rotation_angle) &lt; rotation_tolerance</span><br><span class="line">                        color_match = (</span><br><span class="line">                            abs(current_color_rgb[0] - color_rgb[0]) &lt;= color_tolerance and</span><br><span class="line">                            abs(current_color_rgb[1] - color_rgb[1]) &lt;= color_tolerance and</span><br><span class="line">                            abs(current_color_rgb[2] - color_rgb[2]) &lt;= color_tolerance</span><br><span class="line">                        )</span><br><span class="line">                        if size_match and rotation_match and color_match:</span><br><span class="line">                            page.add_redact_annot(fitz.Rect(span[&quot;bbox&quot;]), text=&quot;&quot;)</span><br><span class="line">        page.apply_redactions()</span><br><span class="line">    doc.save(output_pdf)</span><br><span class="line">    doc.close()</span><br></pre></td></tr></table></figure></div><p><strong>代码解析</strong>：</p><ul><li><p>综合提取字体大小、旋转角度和颜色三个特征（为了简化和实用性，移除了直接在 span 中获取的透明度判断）。</p></li><li><p>设置了合理的匹配容差范围，你可以根据实际情况调整这些容差值。</p></li><li><p>只有当所有选定的特征都匹配时才判定为水印，这大大提高了识别的准确性。</p></li></ul><p><strong>难易度</strong>：★★★★★</p><p><strong>优点</strong>： 识别准确性高，误判率极低。</p><p><strong>缺点</strong>： 实现相对复杂，需要精确的水印特征参数。</p><h3 id="方法四：基于文本特征的直接删除法-xA"><a href="#方法四：基于文本特征的直接删除法-xA" class="headerlink" title="方法四：基于文本特征的直接删除法&#xA;"></a>方法四：基于文本特征的直接删除法&#xA;</h3><p>如果你知道水印的具体文本内容，或者可以通过一些简单的文本属性来识别，这个方法最直接、最快速。</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">import fitz</span><br><span class="line"></span><br><span class="line">def is_watermark_span(span, target_text=None, min_size=None, max_size=None, target_color_rgb=None, color_tolerance=10):</span><br><span class="line">    size_match = True</span><br><span class="line">    if min_size is not None and span[&quot;size&quot;] &lt; min_size:</span><br><span class="line">        size_match = False</span><br><span class="line">    if max_size is not None and span[&quot;size&quot;] &gt; max_size:</span><br><span class="line">        size_match = False</span><br><span class="line">    text_match = True</span><br><span class="line">    if target_text is not None and target_text.lower() not in span[&quot;text&quot;].lower():</span><br><span class="line">        text_match = False</span><br><span class="line">    color_match = True</span><br><span class="line">    if target_color_rgb is not None:</span><br><span class="line">        color_int = span[&quot;color&quot;]</span><br><span class="line">        r = (color_int &gt;&gt; 16) &amp; 0xFF</span><br><span class="line">        g = (color_int &gt;&gt; 8) &amp; 0xFF</span><br><span class="line">        b = color_int &amp; 0xFF</span><br><span class="line">        current_color_rgb = (r, g, b)</span><br><span class="line">        if not (abs(current_color_rgb[0] - target_color_rgb[0]) &lt;= color_tolerance and</span><br><span class="line">                abs(current_color_rgb[1] - target_color_rgb[1]) &lt;= color_tolerance and</span><br><span class="line">                abs(current_color_rgb[2] - target_color_rgb[2]) &lt;= color_tolerance):</span><br><span class="line">            color_match = False</span><br><span class="line">    return size_match and text_match and color_match</span><br><span class="line"></span><br><span class="line">def remove_watermark_by_text_features(doc_path, output_path, **kwargs):</span><br><span class="line">    doc = fitz.open(doc_path)</span><br><span class="line">    for page in doc:</span><br><span class="line">        for block in page.get_text(&quot;dict&quot;)[&quot;blocks&quot;]:</span><br><span class="line">            if block[&quot;type&quot;] == 0:</span><br><span class="line">                for line in block[&quot;lines&quot;]:</span><br><span class="line">                    for span in line[&quot;spans&quot;]:</span><br><span class="line">                        if is_watermark_span(span, **kwargs):</span><br><span class="line">                            page.add_redact_annot(span[&quot;bbox&quot;])</span><br><span class="line">        page.apply_redactions()</span><br><span class="line">    doc.save(output_path)</span><br><span class="line">    doc.close()</span><br></pre></td></tr></table></figure></div><p><strong>代码解析</strong>：</p><ul><li><p>通过一个可自定义的 <code>is_watermark_span</code> 函数直接搜索符合特定文本特征的水印内容。</p></li><li><p>你可以传入 <code>target_text</code>、<code>min_size</code>、<code>max_size</code> 和 <code>target_color_rgb</code> 等参数来精确定义水印的特征。</p></li><li><p>对判定为水印的文本进行覆盖处理。</p></li></ul><p><strong>难易度</strong>：★★☆☆☆</p><p><strong>优点</strong>： 实现简单，处理速度快，非常适合处理简单的文本水印。</p><p><strong>缺点</strong>： 仅适用于文本水印，无法处理图像水印。</p><h3 id="方法五：基于混合特征的高级识别法-xA"><a href="#方法五：基于混合特征的高级识别法-xA" class="headerlink" title="方法五：基于混合特征的高级识别法&#xA;"></a>方法五：基于混合特征的高级识别法&#xA;</h3><p>对于更复杂的 PDF 水印（例如包含文本和图像），这种方法结合了文本和图像特征识别，能够提供更高的识别精度。请注意，图像处理部分需要 numpy 和 opencv-python 库。</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">import fitz</span><br><span class="line">import numpy as np</span><br><span class="line">import cv2</span><br><span class="line"></span><br><span class="line">def advanced_watermark_removal(doc_path, output_path, watermark_template_path=None):</span><br><span class="line">    doc = fitz.open(doc_path)</span><br><span class="line">    if watermark_template_path:</span><br><span class="line">        watermark_template = cv2.imread(watermark_template_path, cv2.IMREAD_GRAYSCALE)</span><br><span class="line">        sift = cv2.SIFT_create()</span><br><span class="line">        kp1, des1 = sift.detectAndCompute(watermark_template, None)</span><br><span class="line">    </span><br><span class="line">    for page in doc:</span><br><span class="line">        text_spans_to_redact = []</span><br><span class="line">        image_regions_to_redact = []</span><br><span class="line">        text_infos = page.get_text(&quot;dict&quot;)</span><br><span class="line">        for block in text_infos[&quot;blocks&quot;]:</span><br><span class="line">            if &quot;lines&quot; in block:</span><br><span class="line">                for line in block[&quot;lines&quot;]:</span><br><span class="line">                    for span in line[&quot;spans&quot;]:</span><br><span class="line">                        if (100 &lt;= span[&quot;color_rgb&quot;][0] &lt;= 220 and </span><br><span class="line">                            100 &lt;= span[&quot;color_rgb&quot;][1] &lt;= 220 and </span><br><span class="line">                            100 &lt;= span[&quot;color_rgb&quot;][2] &lt;= 220) and span[&quot;size&quot;] &gt; 15:</span><br><span class="line">                            text_spans_to_redact.append(span[&quot;bbox&quot;])</span><br><span class="line">        </span><br><span class="line">        if watermark_template_path and des1 is not None:</span><br><span class="line">            pix = page.get_pixmap(matrix=fitz.Matrix(2,2))</span><br><span class="line">            img = cv2.cvtColor(np.frombuffer(pix.samples, np.uint8).reshape(</span><br><span class="line">                pix.h, pix.w, pix.n), cv2.COLOR_RGB2GRAY)</span><br><span class="line">            kp2, des2 = sift.detectAndCompute(img, None)</span><br><span class="line">            if des2 is not None and len(des1) &gt; 0 and len(des2) &gt; 0:</span><br><span class="line">                matcher = cv2.BFMatcher()</span><br><span class="line">                matches = matcher.knnMatch(des1, des2, k=2)</span><br><span class="line">                good_matches = [m for m, n in matches if m.distance &lt; 0.75 * n.distance]</span><br><span class="line">                if len(good_matches) &gt; 10:</span><br><span class="line">                    src_pts = np.float32([kp1[m.queryIdx].pt for m in good_matches]).reshape(-1, 1, 2)</span><br><span class="line">                    dst_pts = np.float32([kp2[m.trainIdx].pt for m in good_matches]).reshape(-1, 1, 2)</span><br><span class="line">                    M, mask = cv2.findHomography(src_pts, dst_pts, cv2.RANSAC, 5.0)</span><br><span class="line">                    if M is not None:</span><br><span class="line">                        h, w = watermark_template.shape</span><br><span class="line">                        pts = np.float32([[0, 0], [0, h-1], [w-1, h-1], [w-1, 0]]).reshape(-1, 1, 2)</span><br><span class="line">                        dst = cv2.perspectiveTransform(pts, M)</span><br><span class="line">                        min_x = int(np.min(dst[:, 0, 0]) / pix.matrix.a)</span><br><span class="line">                        min_y = int(np.min(dst[:, 0, 1]) / pix.matrix.d)</span><br><span class="line">                        max_x = int(np.max(dst[:, 0, 0]) / pix.matrix.a)</span><br><span class="line">                        max_y = int(np.max(dst[:, 0, 1]) / pix.matrix.d)</span><br><span class="line">                        image_regions_to_redact.append((min_x, min_y, max_x, max_y))</span><br><span class="line">        </span><br><span class="line">        for span_bbox in text_spans_to_redact:</span><br><span class="line">            page.add_redact_annot(fitz.Rect(span_bbox))</span><br><span class="line">        for region_bbox in image_regions_to_redact:</span><br><span class="line">            page.add_redact_annot(fitz.Rect(region_bbox))</span><br><span class="line">        page.apply_redactions()</span><br><span class="line">    doc.save(output_path)</span><br><span class="line">    doc.close()</span><br></pre></td></tr></table></figure></div><p><strong>代码解析</strong>：</p><ul><li><p><strong>文本特征识别</strong>： 沿用了之前 <code>is_watermark_text</code> 的概念，但你需要根据实际水印特性来完善这个逻辑。</p></li><li><p><strong>图像特征识别</strong>：</p></li><li><p>将 PDF 页面渲染为图像，并转换为灰度图，以便进行特征检测。</p></li><li><p>使用 SIFT 算法（或其他特征匹配算法如 ORB, SURF）来检测并匹配图像水印模板。</p></li><li><p>通过 <code>findHomography</code> 计算水印在页面上的变换，从而确定水印的精确位置和边界框。</p></li><li><p>注意： 图像处理库 (如 OpenCV) 通常在像素坐标系下操作，你需要将检测到的像素坐标转换回 PyMuPDF 使用的 PDF 坐标。</p></li><li><p><strong>综合处理</strong>： 将文本和图像识别的结果结合起来，对所有识别出的水印区域进行处理。</p></li></ul><p><strong>难易度</strong>：★★★★☆</p><p><strong>优点</strong>： 识别精度高，适用于复杂水印环境（文本与图像混合），鲁棒性强。</p><p><strong>缺点</strong>： 实现复杂，需要水印模板，处理速度相对较慢，需要额外的图像处理库。</p><h3 id="方法六：基于-PDF-底层结构的终极方案-xA"><a href="#方法六：基于-PDF-底层结构的终极方案-xA" class="headerlink" title="方法六：基于 PDF 底层结构的终极方案&#xA;"></a>方法六：基于 PDF 底层结构的终极方案&#xA;</h3><p>这种方法最为彻底，因为它直接操作 PDF 文件的底层结构。但它也要求你对 PDF 规范有深入的了解，操作不当可能会导致文件损坏。</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import fitz</span><br><span class="line"></span><br><span class="line">def deep_watermark_removal(doc_path, output_path):</span><br><span class="line">    print(&quot;警告：此方法在PyMuPDF中难以直接实现，推荐使用更安全的redaction方法&quot;)</span><br><span class="line">    doc = fitz.open(doc_path)</span><br><span class="line">    doc.save(output_path)</span><br><span class="line">    doc.close()</span><br></pre></td></tr></table></figure></div><p><strong>代码解析</strong>：</p><ul><li><p>这个方法旨在直接操作 PDF 的 XObject (外部对象，可以是图像或 Form XObject) 和内容流。</p></li><li><p><strong>重要提示</strong>： PyMuPDF (Fitz) 并没有直接暴露修改或删除底层 PDF 对象的 API。 <code>add_redact_annot</code> 是 PyMuPDF 中最安全和推荐的方式来 “删除” 页面内容的。直接修改 PDF 的底层内容流非常危险，操作不当很可能导致 PDF 文件损坏且无法打开。</p></li><li><p>因此，我调整了此方法的描述和代码示例，强调其复杂性和风险，并指出在 PyMuPDF 中，更推荐使用 <code>add_redact_annot</code> 来实现 “删除” 效果。如果你真的需要深入到 PDF 底层修改，可能需要更专业的 PDF 处理库或对 PDF 规范有极其深入的了解。</p></li></ul><p><strong>难易度</strong>：★★★★★ (理论上)</p><p><strong>优点</strong>： 理论上可以彻底清除不留痕迹，适用于各种类型水印。</p><p><strong>缺点</strong>： 实现非常复杂，需要深入的 PDF 结构知识，且在 PyMuPDF 中直接实现此类操作难度极高且风险大。</p><p>方法对比与选择建议</p><table><thead><tr><th>方法&#xA;</th><th>难易度&#xA;</th><th>适用场景&#xA;</th><th>关键优势&#xA;</th><th>局限性&#xA;</th></tr></thead><tbody><tr><td>字体大小 + 旋转角度&#xA;</td><td>★★★☆☆&#xA;</td><td>水印有固定大小和倾斜角度&#xA;</td><td>实现相对简单，识别准确率较高&#xA;</td><td>需要精确的大小和角度参数&#xA;</td></tr><tr><td>透明度 + 颜色&#xA;</td><td>★★★★☆&#xA;</td><td>水印有固定颜色（特别是浅色）&#xA;</td><td>对浅色水印效果好&#xA;</td><td>透明度提取是难点，可能需要深入解析 PDF 内部结构或借助图像处理库&#xA;</td></tr><tr><td>多特征综合&#xA;</td><td>★★★★★&#xA;</td><td>水印特征明确且固定&#xA;</td><td>识别准确性高，误判率极低&#xA;</td><td>实现相对复杂，需要精确的水印特征参数&#xA;</td></tr><tr><td>基于文本特征&#xA;</td><td>★★☆☆☆&#xA;</td><td>简单文本水印&#xA;</td><td>实现简单，处理速度快&#xA;</td><td>仅适用于文本水印，无法处理图像水印&#xA;</td></tr><tr><td>混合特征识别&#xA;</td><td>★★★★☆&#xA;</td><td>复杂水印环境（文本与图像混合）&#xA;</td><td>识别精度高&#xA;</td><td>实现复杂，需要水印模板，处理速度慢&#xA;</td></tr><tr><td>底层结构处理&#xA;</td><td>★★★★★&#xA;</td><td>各种类型水印&#xA;</td><td>理论上最彻底&#xA;</td><td>高风险，PyMuPDF 中难以直接实现，需要深厚知识&#xA;</td></tr></tbody></table><p>特征参数提取方法</p><p>在实际应用中，我们首先需要获取水印的特征参数。可以通过以下方式初步提取：</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">import fitz</span><br><span class="line">import math</span><br><span class="line">from collections import Counter</span><br><span class="line"></span><br><span class="line">def extract_watermark_features(pdf_path, page_num=0):</span><br><span class="line">    doc = fitz.open(pdf_path)</span><br><span class="line">    page = doc[page_num]</span><br><span class="line">    possible_font_sizes = []</span><br><span class="line">    possible_rotations = []</span><br><span class="line">    possible_colors = []</span><br><span class="line">    </span><br><span class="line">    text_infos = page.get_text(&quot;dict&quot;)</span><br><span class="line">    for block in text_infos[&quot;blocks&quot;]:</span><br><span class="line">        if &quot;lines&quot; in block:</span><br><span class="line">            for line in block[&quot;lines&quot;]:</span><br><span class="line">                for span in line[&quot;spans&quot;]:</span><br><span class="line">                    possible_font_sizes.append(round(span[&quot;size&quot;], 1))</span><br><span class="line">                    matrix = fitz.Matrix(span[&quot;matrix&quot;])</span><br><span class="line">                    rotation = round(math.degrees(math.atan2(matrix.b, matrix.a)), 1)</span><br><span class="line">                    possible_rotations.append(rotation)</span><br><span class="line">                    color_int = span[&quot;color&quot;]</span><br><span class="line">                    r = (color_int &gt;&gt; 16) &amp; 0xFF</span><br><span class="line">                    g = (color_int &gt;&gt; 8) &amp; 0xFF</span><br><span class="line">                    b = color_int &amp; 0xFF</span><br><span class="line">                    possible_colors.append((r, g, b))</span><br><span class="line">    </span><br><span class="line">    font_size = Counter(possible_font_sizes).most_common(1)[0][0] if possible_font_sizes else None</span><br><span class="line">    rotation_angle = Counter(possible_rotations).most_common(1)[0][0] if possible_rotations else None</span><br><span class="line">    if rotation_angle and rotation_angle &lt; 0:</span><br><span class="line">        rotation_angle += 360</span><br><span class="line">    color_rgb = Counter(possible_colors).most_common(1)[0][0] if possible_colors else None</span><br><span class="line">    </span><br><span class="line">    doc.close()</span><br><span class="line">    return &#123;</span><br><span class="line">        &quot;font_size&quot;: font_size,</span><br><span class="line">        &quot;rotation_angle&quot;: rotation_angle,</span><br><span class="line">        &quot;color_rgb&quot;: color_rgb,</span><br><span class="line">        &quot;opacity&quot;: 0.5</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div><p><strong>代码解析</strong>：</p><ul><li><p>此函数会遍历指定页面的所有文本跨度，收集它们的字体大小、旋转角度和颜色。</p></li><li><p>为了方便统计，对浮点数（大小和角度）进行了四舍五入。</p></li><li><p>使用 <code>collections.Counter</code> 找出最常见的字体大小、旋转角度和颜色，作为可能的水印特征。</p></li><li><p>注意： 提取透明度仍然是一个挑战，<code>opacity</code> 参数在此处仍作为占位符，需要通过其他方式（例如手动观察或更复杂的 PDF 内容流解析）来确定。</p></li></ul><p>总结与最佳实践</p><p>基于特征的 PDF 水印处理方法能够实现更精确的水印识别和去除，但这要求你对水印的特征有充分了解。在实际应用中，我建议你遵循以下最佳实践：</p><ol><li><p><strong>预处理分析</strong>： 首先使用 <code>extract_watermark_features</code> 函数分析水印特征，初步了解水印的字体大小、旋转角度、颜色等关键信息。必要时，手工观察水印，确认其透明度、具体文本内容或图像样式。</p></li><li><p><strong>从简到繁尝试</strong>： 从最简单的方法开始。如果水印是纯文本且特征明显，可以先尝试 基于文本特征的直接删除法。如果水印有固定的字体大小和倾斜角度，就用 基于字体大小和旋转角度的方法。只有当简单方法效果不佳时，再逐步增加特征维度，尝试 多特征综合识别。</p></li><li><p><strong>合理调整参数</strong>： 根据实际水印情况细致调整匹配容差值，在识别准确率和误判率之间取得最佳平衡。例如，对于字体大小，可以允许 1.0 到 2.0 的误差范围；对于旋转角度，可允许 3 到 5 度左右的误差。</p></li><li><p><strong>复杂场景组合</strong>： 对于包含多种类型水印的复杂 PDF，考虑结合多种方法进行处理。例如，对于既有文本又有图像的混合水印，可以结合 混合特征识别法。</p></li><li><p><strong>批量处理技巧</strong>： 如果你需要处理大量 PDF 文件，利用多线程或多进程可以显著提高处理效率。</p></li></ol><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">from concurrent.futures import ThreadPoolExecutor</span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line">def batch_process_pdfs(file_list, output_dir, **watermark_params):</span><br><span class="line">    os.makedirs(output_dir, exist_ok=True)</span><br><span class="line">    with ThreadPoolExecutor(max_workers=os.cpu_count()) as executor:</span><br><span class="line">        futures = []</span><br><span class="line">        for file_path in file_list:</span><br><span class="line">            file_name = os.path.basename(file_path)</span><br><span class="line">            output_path = os.path.join(output_dir, file_name)</span><br><span class="line">            futures.append(executor.submit(</span><br><span class="line">                remove_watermark_by_multiple_features,</span><br><span class="line">                file_path, output_path, **watermark_params</span><br><span class="line">            ))</span><br><span class="line">        for future in futures:</span><br><span class="line">            try:</span><br><span class="line">                future.result()</span><br><span class="line">                print(f&quot;文件处理完成：&#123;file_path&#125;&quot;)</span><br><span class="line">            except Exception as exc:</span><br><span class="line">                print(f&quot;文件 &#123;file_path&#125; 处理时发生错误：&#123;exc&#125;&quot;)</span><br></pre></td></tr></table></figure></div><ol><li><strong>操作安全保障</strong>： 在处理任何重要文件之前，务必先备份原始文件！这能确保即使处理不当，你也不会丢失原始数据。同时，请始终遵守相关法律法规，仅处理你有权修改的文档，尊重知识产权和版权保护。</li></ol><p>通过合理选择和组合这些方法，你就能高效且精准地处理各种具有特定特征的 PDF 水印。</p><p>PS:代码仅供参考，内容不一定正确，要根据实际情况处理喵</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在日常工作中，我们经常会遇到带有特定特征的 PDF 水印，比如固定的字体大小、倾斜角度、透明度和颜色。这些特性为我们提供了更精准地识别水印的依据。今天，我们就来深入探讨如何利用 PyMuPDF (Fitz) 库，基于这些特征实现 PDF 水印的精确识别和去除，并整合多种实用</summary>
      
    
    
    
    <category term="PDF 处理" scheme="http://example.com/categories/PDF-%E5%A4%84%E7%90%86/"/>
    
    <category term="Python" scheme="http://example.com/categories/PDF-%E5%A4%84%E7%90%86/Python/"/>
    
    <category term="数据处理" scheme="http://example.com/categories/PDF-%E5%A4%84%E7%90%86/Python/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"/>
    
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
    <category term="PyMuPDF" scheme="http://example.com/tags/PyMuPDF/"/>
    
    <category term="PDF" scheme="http://example.com/tags/PDF/"/>
    
    <category term="水印去除" scheme="http://example.com/tags/%E6%B0%B4%E5%8D%B0%E5%8E%BB%E9%99%A4/"/>
    
    <category term="特征识别" scheme="http://example.com/tags/%E7%89%B9%E5%BE%81%E8%AF%86%E5%88%AB/"/>
    
    <category term="文本处理" scheme="http://example.com/tags/%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>从零开始的爬虫生活（一）：环境搭建与基础库应用</title>
    <link href="http://example.com/2025/07/15/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84%E7%88%AC%E8%99%AB%E7%94%9F%E6%B4%BB%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E5%9F%BA%E7%A1%80%E5%BA%93%E5%BA%94%E7%94%A8/"/>
    <id>http://example.com/2025/07/15/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84%E7%88%AC%E8%99%AB%E7%94%9F%E6%B4%BB%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E5%9F%BA%E7%A1%80%E5%BA%93%E5%BA%94%E7%94%A8/</id>
    <published>2025-07-15T09:15:15.000Z</published>
    <updated>2025-07-17T07:22:02.338Z</updated>
    
    <content type="html"><![CDATA[<p>一、环境搭建</p><p>在开始学习爬虫之前，我们需要先搭建好开发环境。以下是一些常用的工具和库：</p><h3 id="1-Python-环境-xA"><a href="#1-Python-环境-xA" class="headerlink" title="1. Python 环境&#xA;"></a>1. Python 环境&#xA;</h3><p>确保已经安装了 Python 3.x 版本。可以前往 <a class="link"   href="https://www.python.org/" >Python 官网<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 下载安装。</p><h3 id="2-常用库安装-xA"><a href="#2-常用库安装-xA" class="headerlink" title="2. 常用库安装&#xA;"></a>2. 常用库安装&#xA;</h3><p>使用 pip 命令安装以下库：</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pip install selenium</span><br><span class="line"></span><br><span class="line">pip install beautifulsoup4</span><br><span class="line"></span><br><span class="line">pip install pyquery</span><br><span class="line"></span><br><span class="line">pip install pymysql</span><br><span class="line"></span><br><span class="line">pip install pymongo</span><br><span class="line"></span><br><span class="line">pip install redis</span><br></pre></td></tr></table></figure></div><h3 id="3-浏览器驱动-xA"><a href="#3-浏览器驱动-xA" class="headerlink" title="3. 浏览器驱动&#xA;"></a>3. 浏览器驱动&#xA;</h3><ul><li><p><strong>ChromeDriver</strong>：根据你使用的 Chrome 浏览器版本，下载对应的 ChromeDriver。</p></li><li><p><strong>PhantomJS（已弃用）</strong>：在 Selenium 4.x 中已移除，建议使用无头模式的 Chrome。</p></li></ul><p><strong>配置 Chrome 无头模式示例：</strong></p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">from selenium import webdriver</span><br><span class="line">from selenium.webdriver.chrome.options import Options</span><br><span class="line"></span><br><span class="line"># 配置 Chrome 为无头模式</span><br><span class="line">chrome_options = Options()</span><br><span class="line">chrome_options.add_argument(&quot;--headless&quot;)  # 无头模式，不显示浏览器窗口</span><br><span class="line"></span><br><span class="line"># 创建 Chrome 浏览器实例</span><br><span class="line">driver = webdriver.Chrome(options=chrome_options)</span><br><span class="line"></span><br><span class="line">driver.get(&quot;https://www.example.com&quot;)</span><br><span class="line">print(driver.title)</span><br><span class="line">driver.quit()</span><br></pre></td></tr></table></figure></div><p>二、基础库应用</p><h3 id="1-BeautifulSoup-库-xA"><a href="#1-BeautifulSoup-库-xA" class="headerlink" title="1. BeautifulSoup 库&#xA;"></a>1. BeautifulSoup 库&#xA;</h3><p>BeautifulSoup 是一个用于解析 HTML 和 XML 文档的库。<strong>示例：</strong></p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">from bs4 import BeautifulSoup</span><br><span class="line"></span><br><span class="line">html_doc = &quot;&quot;&quot;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;title&gt;示例页面&lt;/title&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;h1&gt;标题&lt;/h1&gt;</span><br><span class="line">        &lt;p&gt;段落内容&lt;/p&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">soup = BeautifulSoup(html_doc, &#x27;html.parser&#x27;)</span><br><span class="line">print(soup.title.string)  # 输出标题内容</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">soup = BeautifulSoup(html_doc, &#x27;html.parser&#x27;)</span><br><span class="line"></span><br><span class="line">print(soup.title.string)  # 输出标题内容</span><br></pre></td></tr></table></figure></div><h3 id="2-PyQuery-库-xA"><a href="#2-PyQuery-库-xA" class="headerlink" title="2. PyQuery 库&#xA;"></a>2. PyQuery 库&#xA;</h3><p>PyQuery 是一个类 jQuery 的 Python 库，用于操作 HTML 文档。<strong>示例：</strong></p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">from pyquery import PyQuery as pq</span><br><span class="line"></span><br><span class="line">html_doc = &quot;&quot;&quot;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;title&gt;示例页面&lt;/title&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;h1&gt;标题&lt;/h1&gt;</span><br><span class="line">        &lt;p&gt;段落内容&lt;/p&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">doc = pq(html_doc)</span><br><span class="line">print(doc(&#x27;title&#x27;).text())  # 输出标题内容</span><br></pre></td></tr></table></figure></div><h3 id="3-Requests-库-xA"><a href="#3-Requests-库-xA" class="headerlink" title="3. Requests 库&#xA;"></a>3. Requests 库&#xA;</h3><p>Requests 是一个简单的 HTTP 库，用于发送网络请求。<strong>示例：</strong></p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line"></span><br><span class="line">url = &quot;https://www.example.com&quot;</span><br><span class="line">response = requests.get(url)</span><br><span class="line">print(response.text)  # 输出网页内容</span><br></pre></td></tr></table></figure></div><p>三、数据存储</p><h3 id="1-MySQL-数据库-xA"><a href="#1-MySQL-数据库-xA" class="headerlink" title="1. MySQL 数据库&#xA;"></a>1. MySQL 数据库&#xA;</h3><p>使用 PyMySQL 连接和操作 MySQL 数据库：</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import pymysql</span><br><span class="line"></span><br><span class="line">conn = pymysql.connect(</span><br><span class="line">    host=&#x27;localhost&#x27;,</span><br><span class="line">    user=&#x27;root&#x27;,</span><br><span class="line">    password=&#x27;123456&#x27;,</span><br><span class="line">    port=3306,</span><br><span class="line">    db=&#x27;mysql&#x27;</span><br><span class="line">)</span><br><span class="line">cursor = conn.cursor()</span><br><span class="line">cursor.execute(&#x27;SELECT * FROM db&#x27;)</span><br><span class="line">print(cursor.fetchone())</span><br><span class="line">conn.close()</span><br></pre></td></tr></table></figure></div><h3 id="2-MongoDB-数据库-xA"><a href="#2-MongoDB-数据库-xA" class="headerlink" title="2. MongoDB 数据库&#xA;"></a>2. MongoDB 数据库&#xA;</h3><p>使用 PyMongo 连接和操作 MongoDB 数据库：</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import pymongo</span><br><span class="line"></span><br><span class="line">client = pymongo.MongoClient(&#x27;localhost&#x27;)</span><br><span class="line">db = client[&#x27;newtestdb&#x27;]</span><br><span class="line">db[&#x27;table&#x27;].insert_one(&#123;&#x27;name&#x27;: &#x27;Bob&#x27;&#125;)</span><br><span class="line">result = db[&#x27;table&#x27;].find_one(&#123;&#x27;name&#x27;: &#x27;Bob&#x27;&#125;)</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure></div><h3 id="3-Redis-数据库-xA"><a href="#3-Redis-数据库-xA" class="headerlink" title="3. Redis 数据库&#xA;"></a>3. Redis 数据库&#xA;</h3><p>使用 RedisPy 连接和操作 Redis 数据库：</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import redis</span><br><span class="line"></span><br><span class="line">r = redis.Redis(&#x27;localhost&#x27;, 6379)</span><br><span class="line">r.set(&#x27;name&#x27;, &#x27;Bob&#x27;)</span><br><span class="line">result = r.get(&#x27;name&#x27;)</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure></div><p>四、爬虫基本流程</p><p>爬虫的基本流程如下：</p><ol><li><p>发送请求：使用 Requests 库发送 HTTP 请求获取网页内容。</p></li><li><p>解析响应：使用 BeautifulSoup 或 PyQuery 库解析网页内容，提取所需数据。</p></li><li><p>保存数据：将提取的数据存储到数据库或文件中。</p></li></ol><p><strong>示例：爬取猫眼电影 TOP100</strong></p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line">import re</span><br><span class="line">import json</span><br><span class="line">from multiprocessing import Pool</span><br><span class="line"></span><br><span class="line">def get_one_page(url):</span><br><span class="line">    headers = &#123;</span><br><span class="line">        &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/137.0.0.0 Safari/537.36 Edg/137.0.0.0&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">    response = requests.get(url, headers=headers)</span><br><span class="line">    if response.status_code == 200:</span><br><span class="line">        return response.text</span><br><span class="line">    return None</span><br><span class="line"></span><br><span class="line">def parse_one_page(html):</span><br><span class="line">    pattern = re.compile(&#x27;&lt;dd&gt;.*?board-index.*?&gt;(d+)&lt;/i&gt;.*?data-src=&quot;(.*?)&quot;.*?name&quot;&gt;&lt;a&#x27;</span><br><span class="line">                         + &#x27;.*?&gt;(.*?)&lt;/a&gt;.*?star&quot;&gt;(.*?)&lt;/p&gt;.*?releasetime&quot;&gt;(.*?)&lt;/p&gt;&#x27;</span><br><span class="line">                         + &#x27;.*?integer&quot;&gt;(.*?)&lt;/i&gt;.*?fraction&quot;&gt;(.*?)&lt;/i&gt;.*?&lt;/dd&gt;&#x27;, re.S)</span><br><span class="line">    items = re.findall(pattern, html)</span><br><span class="line">    for item in items:</span><br><span class="line">        yield &#123;</span><br><span class="line">            &#x27;index&#x27;: item[0],</span><br><span class="line">            &#x27;image&#x27;: item[1],</span><br><span class="line">            &#x27;title&#x27;: item[2],</span><br><span class="line">            &#x27;actor&#x27;: item[3].strip()[3:],</span><br><span class="line">            &#x27;time&#x27;: item[4].strip()[5:],</span><br><span class="line">            &#x27;score&#x27;: item[5] + item[6]</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">def write_to_file(content):</span><br><span class="line">    with open(&#x27;result.txt&#x27;, &#x27;a&#x27;, encoding=&#x27;utf-8&#x27;) as f:</span><br><span class="line">        f.write(json.dumps(content, ensure_ascii=False) + &#x27;n&#x27;)</span><br><span class="line"></span><br><span class="line">def main(offset):</span><br><span class="line">    url = &#x27;http://maoyan.com/board/4?offset=&#x27; + str(offset)</span><br><span class="line">    html = get_one_page(url)</span><br><span class="line">    for item in parse_one_page(html):</span><br><span class="line">        print(item)</span><br><span class="line">        write_to_file(item)</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    pool = Pool()</span><br><span class="line">    pool.map(main, [i * 10 for i in range(10)])</span><br></pre></td></tr></table></figure></div><p>五、动态网页处理</p><p>对于动态加载的网页，可以使用 Selenium 模拟浏览器操作。<strong>示例：</strong></p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">from selenium import webdriver</span><br><span class="line">from selenium.webdriver.common.by import By</span><br><span class="line"></span><br><span class="line">driver = webdriver.Chrome()</span><br><span class="line">driver.get(&#x27;https://www.taobao.com&#x27;)</span><br><span class="line">input = driver.find_element(By.ID, &#x27;q&#x27;)</span><br><span class="line">input.send_keys(&#x27;美食&#x27;)</span><br><span class="line">button = driver.find_element(By.CLASS_NAME, &#x27;btn-search&#x27;)</span><br><span class="line">button.click()</span><br><span class="line">driver.quit()</span><br></pre></td></tr></table></figure></div><p>六、爬虫框架</p><h3 id="1-Scrapy-框架-xA"><a href="#1-Scrapy-框架-xA" class="headerlink" title="1. Scrapy 框架&#xA;"></a>1. Scrapy 框架&#xA;</h3><p>Scrapy 是一个强大的爬虫框架，可以简化爬虫开发过程。<strong>安装命令：</strong></p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install scrapy</span><br></pre></td></tr></table></figure></div><p>未完待续……</p><p>PS:代码仅供参考，内容不一定正确，要根据实际情况处理喵</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;一、环境搭建&lt;/p&gt;
&lt;p&gt;在开始学习爬虫之前，我们需要先搭建好开发环境。以下是一些常用的工具和库：&lt;/p&gt;
&lt;h3 id=&quot;1-Python-环境-xA&quot;&gt;&lt;a href=&quot;#1-Python-环境-xA&quot; class=&quot;headerlink&quot; title=&quot;1. Pyt</summary>
      
    
    
    
    <category term="爬虫教程" scheme="http://example.com/categories/%E7%88%AC%E8%99%AB%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="Python爬虫" scheme="http://example.com/tags/Python%E7%88%AC%E8%99%AB/"/>
    
    <category term="数据抓取" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E6%8A%93%E5%8F%96/"/>
    
    <category term="Selenium" scheme="http://example.com/tags/Selenium/"/>
    
    <category term="BeautifulSoup" scheme="http://example.com/tags/BeautifulSoup/"/>
    
    <category term="数据存储" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/"/>
    
  </entry>
  
  <entry>
    <title>Dify镜像源替换与服务启动</title>
    <link href="http://example.com/2025/07/15/Dify-%E9%83%A8%E7%BD%B2%E6%B5%81%E7%A8%8B%EF%BC%9A%E9%95%9C%E5%83%8F%E6%BA%90%E6%9B%BF%E6%8D%A2%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%90%AF%E5%8A%A8/"/>
    <id>http://example.com/2025/07/15/Dify-%E9%83%A8%E7%BD%B2%E6%B5%81%E7%A8%8B%EF%BC%9A%E9%95%9C%E5%83%8F%E6%BA%90%E6%9B%BF%E6%8D%A2%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%90%AF%E5%8A%A8/</id>
    <published>2025-07-15T02:17:31.000Z</published>
    <updated>2025-07-17T07:21:54.243Z</updated>
    
    <content type="html"><![CDATA[<p>一、Dify 镜像源替换操作</p><h3 id="批量替换镜像前缀-xA"><a href="#批量替换镜像前缀-xA" class="headerlink" title="批量替换镜像前缀&#xA;"></a>批量替换镜像前缀&#xA;</h3><p>在 docker-compose.yaml 所在目录执行全局替换，添加 docker.1ms.run&#x2F; 前缀：</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i &#x27;s/image: /image: docker.1ms.run\\//g&#x27; docker-compose.yaml</span><br></pre></td></tr></table></figure></div><h3 id="特殊镜像路径修正-xA"><a href="#特殊镜像路径修正-xA" class="headerlink" title="特殊镜像路径修正&#xA;"></a>特殊镜像路径修正&#xA;</h3><h4 id="问题路径-xA"><a href="#问题路径-xA" class="headerlink" title="问题路径&#xA;"></a>问题路径&#xA;</h4><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">image: docker.1ms.run/docker.elastic.co/elasticsearch/elasticsearch:8.14.3</span><br></pre></td></tr></table></figure></div><h4 id="修正命令-xA"><a href="#修正命令-xA" class="headerlink" title="修正命令&#xA;"></a>修正命令&#xA;</h4><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i &#x27;s|docker.1ms.run/docker.elastic.co/|docker.1ms.run/elastic/|g&#x27; docker-compose.yaml</span><br></pre></td></tr></table></figure></div><h4 id="正确路径-xA"><a href="#正确路径-xA" class="headerlink" title="正确路径&#xA;"></a>正确路径&#xA;</h4><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">image: docker.1ms.run/elastic/elasticsearch:8.14.3</span><br></pre></td></tr></table></figure></div><h3 id="基础镜像补充替换-xA"><a href="#基础镜像补充替换-xA" class="headerlink" title="基础镜像补充替换&#xA;"></a>基础镜像补充替换&#xA;</h3><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sed -i &#x27;s|image: postgres:|image: docker.1ms.run/postgres:|g&#x27; docker-compose.yaml</span><br><span class="line"></span><br><span class="line">sed -i &#x27;s|image: redis:|image: docker.1ms.run/redis:|g&#x27; docker-compose.yaml</span><br><span class="line"></span><br><span class="line">sed -i &#x27;s|image: nginx:|image: docker.1ms.run/nginx:|g&#x27; docker-compose.yaml</span><br></pre></td></tr></table></figure></div><p>二、部署前准备工作</p><p>赋予挂载目录权限：</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod -R 777 ./volumes ./elasticsearch</span><br></pre></td></tr></table></figure></div><p>三、启动与验证 Dify 服务</p><h3 id="后台启动服务-xA"><a href="#后台启动服务-xA" class="headerlink" title="后台启动服务&#xA;"></a>后台启动服务&#xA;</h3><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure></div><h3 id="验证服务状态-xA"><a href="#验证服务状态-xA" class="headerlink" title="验证服务状态&#xA;"></a>验证服务状态&#xA;</h3><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker-compose ps  # 检查容器运行状态</span><br><span class="line"></span><br><span class="line">docker-compose logs -f  # 查看实时日志</span><br></pre></td></tr></table></figure></div><h3 id="访问-Dify-界面-xA"><a href="#访问-Dify-界面-xA" class="headerlink" title="访问 Dify 界面&#xA;"></a>访问 Dify 界面&#xA;</h3><p>浏览器输入 http:&#x2F;&#x2F; 服务器 IP:3000，默认账号 <a class="link"   href="mailto:&#97;&#x64;&#109;&#x69;&#110;&#64;&#x65;&#120;&#97;&#109;&#x70;&#x6c;&#x65;&#x2e;&#99;&#x6f;&#109;" >admin@example.com<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>，密码 password。</p><p>四、部署过程常见问题</p><h3 id="镜像路径嵌套错误-xA"><a href="#镜像路径嵌套错误-xA" class="headerlink" title="镜像路径嵌套错误&#xA;"></a>镜像路径嵌套错误&#xA;</h3><h4 id="问题-xA"><a href="#问题-xA" class="headerlink" title="问题&#xA;"></a>问题&#xA;</h4><p>镜像路径包含 docker.1ms.run&#x2F;docker.elastic.co&#x2F; 嵌套结构。</p><h4 id="解决-xA"><a href="#解决-xA" class="headerlink" title="解决&#xA;"></a>解决&#xA;</h4><p>使用 sed 精准替换：</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i &#x27;s|docker.1ms.run/docker.elastic.co/|docker.1ms.run/elastic/|g&#x27; docker-compose.yaml</span><br></pre></td></tr></table></figure></div><h3 id="权限不足导致启动失败-xA"><a href="#权限不足导致启动失败-xA" class="headerlink" title="权限不足导致启动失败&#xA;"></a>权限不足导致启动失败&#xA;</h3><h4 id="问题-xA-1"><a href="#问题-xA-1" class="headerlink" title="问题&#xA;"></a>问题&#xA;</h4><p>挂载目录无读写权限。</p><h4 id="解决-xA-1"><a href="#解决-xA-1" class="headerlink" title="解决&#xA;"></a>解决&#xA;</h4><p>递归设置目录权限：</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod -R 777 ./volumes</span><br></pre></td></tr></table></figure></div><h3 id="服务启动异常-xA"><a href="#服务启动异常-xA" class="headerlink" title="服务启动异常&#xA;"></a>服务启动异常&#xA;</h3><h4 id="解决-xA-2"><a href="#解决-xA-2" class="headerlink" title="解决&#xA;"></a>解决&#xA;</h4><p>通过日志排查问题：&#x20;</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker-compose logs -f  # 查看所有服务日志</span><br><span class="line"></span><br><span class="line">docker-compose logs dify-api  # 查看指定服务日志</span><br></pre></td></tr></table></figure></div><p>五、核心操作总结</p><h3 id="镜像替换流程-xA"><a href="#镜像替换流程-xA" class="headerlink" title="镜像替换流程&#xA;"></a>镜像替换流程&#xA;</h3><p>全局前缀替换 → 特殊镜像路径修正 → 基础镜像补充替换</p><h3 id="启动验证流程-xA"><a href="#启动验证流程-xA" class="headerlink" title="启动验证流程&#xA;"></a>启动验证流程&#xA;</h3><p>docker-compose up -d → docker-compose ps → 访问 Web 界面</p><h3 id="关键命令-xA"><a href="#关键命令-xA" class="headerlink" title="关键命令&#xA;"></a>关键命令&#xA;</h3><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sed -i &#x27;s/image: /image: docker.1ms.run\\//g&#x27; docker-compose.yaml</span><br><span class="line"></span><br><span class="line">chmod -R 777 ./volumes</span><br><span class="line"></span><br><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure></div><p>PS:代码仅供参考，内容不一定正确，要根据实际情况处理喵</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;一、Dify 镜像源替换操作&lt;/p&gt;
&lt;h3 id=&quot;批量替换镜像前缀-xA&quot;&gt;&lt;a href=&quot;#批量替换镜像前缀-xA&quot; class=&quot;headerlink&quot; title=&quot;批量替换镜像前缀&amp;#xA;&quot;&gt;&lt;/a&gt;批量替换镜像前缀&amp;#xA;&lt;/h3&gt;&lt;p&gt;在 docker</summary>
      
    
    
    
    <category term="Dify" scheme="http://example.com/categories/Dify/"/>
    
    
    <category term="Dify" scheme="http://example.com/tags/Dify/"/>
    
    <category term="镜像源" scheme="http://example.com/tags/%E9%95%9C%E5%83%8F%E6%BA%90/"/>
    
  </entry>
  
</feed>
